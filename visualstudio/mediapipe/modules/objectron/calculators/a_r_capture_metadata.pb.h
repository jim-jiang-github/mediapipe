// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mediapipe/modules/objectron/calculators/a_r_capture_metadata.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_mediapipe_2fmodules_2fobjectron_2fcalculators_2fa_5fr_5fcapture_5fmetadata_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_mediapipe_2fmodules_2fobjectron_2fcalculators_2fa_5fr_5fcapture_5fmetadata_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3015000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3015008 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_mediapipe_2fmodules_2fobjectron_2fcalculators_2fa_5fr_5fcapture_5fmetadata_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_mediapipe_2fmodules_2fobjectron_2fcalculators_2fa_5fr_5fcapture_5fmetadata_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[20]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_mediapipe_2fmodules_2fobjectron_2fcalculators_2fa_5fr_5fcapture_5fmetadata_2eproto;
namespace mediapipe {
class ARBlendShapeMap;
struct ARBlendShapeMapDefaultTypeInternal;
extern ARBlendShapeMapDefaultTypeInternal _ARBlendShapeMap_default_instance_;
class ARBlendShapeMap_MapEntry;
struct ARBlendShapeMap_MapEntryDefaultTypeInternal;
extern ARBlendShapeMap_MapEntryDefaultTypeInternal _ARBlendShapeMap_MapEntry_default_instance_;
class ARCamera;
struct ARCameraDefaultTypeInternal;
extern ARCameraDefaultTypeInternal _ARCamera_default_instance_;
class ARCamera_EulerAngles;
struct ARCamera_EulerAnglesDefaultTypeInternal;
extern ARCamera_EulerAnglesDefaultTypeInternal _ARCamera_EulerAngles_default_instance_;
class ARFaceAnchor;
struct ARFaceAnchorDefaultTypeInternal;
extern ARFaceAnchorDefaultTypeInternal _ARFaceAnchor_default_instance_;
class ARFaceGeometry;
struct ARFaceGeometryDefaultTypeInternal;
extern ARFaceGeometryDefaultTypeInternal _ARFaceGeometry_default_instance_;
class ARFaceGeometry_TextureCoordinate;
struct ARFaceGeometry_TextureCoordinateDefaultTypeInternal;
extern ARFaceGeometry_TextureCoordinateDefaultTypeInternal _ARFaceGeometry_TextureCoordinate_default_instance_;
class ARFaceGeometry_Vertex;
struct ARFaceGeometry_VertexDefaultTypeInternal;
extern ARFaceGeometry_VertexDefaultTypeInternal _ARFaceGeometry_Vertex_default_instance_;
class ARFrame;
struct ARFrameDefaultTypeInternal;
extern ARFrameDefaultTypeInternal _ARFrame_default_instance_;
class ARLightEstimate;
struct ARLightEstimateDefaultTypeInternal;
extern ARLightEstimateDefaultTypeInternal _ARLightEstimate_default_instance_;
class ARLightEstimate_DirectionVector;
struct ARLightEstimate_DirectionVectorDefaultTypeInternal;
extern ARLightEstimate_DirectionVectorDefaultTypeInternal _ARLightEstimate_DirectionVector_default_instance_;
class ARPlaneAnchor;
struct ARPlaneAnchorDefaultTypeInternal;
extern ARPlaneAnchorDefaultTypeInternal _ARPlaneAnchor_default_instance_;
class ARPlaneAnchor_PlaneVector;
struct ARPlaneAnchor_PlaneVectorDefaultTypeInternal;
extern ARPlaneAnchor_PlaneVectorDefaultTypeInternal _ARPlaneAnchor_PlaneVector_default_instance_;
class ARPlaneGeometry;
struct ARPlaneGeometryDefaultTypeInternal;
extern ARPlaneGeometryDefaultTypeInternal _ARPlaneGeometry_default_instance_;
class ARPlaneGeometry_TextureCoordinate;
struct ARPlaneGeometry_TextureCoordinateDefaultTypeInternal;
extern ARPlaneGeometry_TextureCoordinateDefaultTypeInternal _ARPlaneGeometry_TextureCoordinate_default_instance_;
class ARPlaneGeometry_Vertex;
struct ARPlaneGeometry_VertexDefaultTypeInternal;
extern ARPlaneGeometry_VertexDefaultTypeInternal _ARPlaneGeometry_Vertex_default_instance_;
class ARPointCloud;
struct ARPointCloudDefaultTypeInternal;
extern ARPointCloudDefaultTypeInternal _ARPointCloud_default_instance_;
class ARPointCloud_Point;
struct ARPointCloud_PointDefaultTypeInternal;
extern ARPointCloud_PointDefaultTypeInternal _ARPointCloud_Point_default_instance_;
class AVCameraCalibrationData;
struct AVCameraCalibrationDataDefaultTypeInternal;
extern AVCameraCalibrationDataDefaultTypeInternal _AVCameraCalibrationData_default_instance_;
class AVDepthData;
struct AVDepthDataDefaultTypeInternal;
extern AVDepthDataDefaultTypeInternal _AVDepthData_default_instance_;
}  // namespace mediapipe
PROTOBUF_NAMESPACE_OPEN
template<> ::mediapipe::ARBlendShapeMap* Arena::CreateMaybeMessage<::mediapipe::ARBlendShapeMap>(Arena*);
template<> ::mediapipe::ARBlendShapeMap_MapEntry* Arena::CreateMaybeMessage<::mediapipe::ARBlendShapeMap_MapEntry>(Arena*);
template<> ::mediapipe::ARCamera* Arena::CreateMaybeMessage<::mediapipe::ARCamera>(Arena*);
template<> ::mediapipe::ARCamera_EulerAngles* Arena::CreateMaybeMessage<::mediapipe::ARCamera_EulerAngles>(Arena*);
template<> ::mediapipe::ARFaceAnchor* Arena::CreateMaybeMessage<::mediapipe::ARFaceAnchor>(Arena*);
template<> ::mediapipe::ARFaceGeometry* Arena::CreateMaybeMessage<::mediapipe::ARFaceGeometry>(Arena*);
template<> ::mediapipe::ARFaceGeometry_TextureCoordinate* Arena::CreateMaybeMessage<::mediapipe::ARFaceGeometry_TextureCoordinate>(Arena*);
template<> ::mediapipe::ARFaceGeometry_Vertex* Arena::CreateMaybeMessage<::mediapipe::ARFaceGeometry_Vertex>(Arena*);
template<> ::mediapipe::ARFrame* Arena::CreateMaybeMessage<::mediapipe::ARFrame>(Arena*);
template<> ::mediapipe::ARLightEstimate* Arena::CreateMaybeMessage<::mediapipe::ARLightEstimate>(Arena*);
template<> ::mediapipe::ARLightEstimate_DirectionVector* Arena::CreateMaybeMessage<::mediapipe::ARLightEstimate_DirectionVector>(Arena*);
template<> ::mediapipe::ARPlaneAnchor* Arena::CreateMaybeMessage<::mediapipe::ARPlaneAnchor>(Arena*);
template<> ::mediapipe::ARPlaneAnchor_PlaneVector* Arena::CreateMaybeMessage<::mediapipe::ARPlaneAnchor_PlaneVector>(Arena*);
template<> ::mediapipe::ARPlaneGeometry* Arena::CreateMaybeMessage<::mediapipe::ARPlaneGeometry>(Arena*);
template<> ::mediapipe::ARPlaneGeometry_TextureCoordinate* Arena::CreateMaybeMessage<::mediapipe::ARPlaneGeometry_TextureCoordinate>(Arena*);
template<> ::mediapipe::ARPlaneGeometry_Vertex* Arena::CreateMaybeMessage<::mediapipe::ARPlaneGeometry_Vertex>(Arena*);
template<> ::mediapipe::ARPointCloud* Arena::CreateMaybeMessage<::mediapipe::ARPointCloud>(Arena*);
template<> ::mediapipe::ARPointCloud_Point* Arena::CreateMaybeMessage<::mediapipe::ARPointCloud_Point>(Arena*);
template<> ::mediapipe::AVCameraCalibrationData* Arena::CreateMaybeMessage<::mediapipe::AVCameraCalibrationData>(Arena*);
template<> ::mediapipe::AVDepthData* Arena::CreateMaybeMessage<::mediapipe::AVDepthData>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mediapipe {

enum AVDepthData_Accuracy : int {
  AVDepthData_Accuracy_UNDEFINED_ACCURACY = 0,
  AVDepthData_Accuracy_RELATIVE = 1,
  AVDepthData_Accuracy_ABSOLUTE = 2
};
bool AVDepthData_Accuracy_IsValid(int value);
constexpr AVDepthData_Accuracy AVDepthData_Accuracy_Accuracy_MIN = AVDepthData_Accuracy_UNDEFINED_ACCURACY;
constexpr AVDepthData_Accuracy AVDepthData_Accuracy_Accuracy_MAX = AVDepthData_Accuracy_ABSOLUTE;
constexpr int AVDepthData_Accuracy_Accuracy_ARRAYSIZE = AVDepthData_Accuracy_Accuracy_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AVDepthData_Accuracy_descriptor();
template<typename T>
inline const std::string& AVDepthData_Accuracy_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AVDepthData_Accuracy>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AVDepthData_Accuracy_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AVDepthData_Accuracy_descriptor(), enum_t_value);
}
inline bool AVDepthData_Accuracy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AVDepthData_Accuracy* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AVDepthData_Accuracy>(
    AVDepthData_Accuracy_descriptor(), name, value);
}
enum AVDepthData_Quality : int {
  AVDepthData_Quality_UNDEFINED_QUALITY = 0,
  AVDepthData_Quality_HIGH = 1,
  AVDepthData_Quality_LOW = 2
};
bool AVDepthData_Quality_IsValid(int value);
constexpr AVDepthData_Quality AVDepthData_Quality_Quality_MIN = AVDepthData_Quality_UNDEFINED_QUALITY;
constexpr AVDepthData_Quality AVDepthData_Quality_Quality_MAX = AVDepthData_Quality_LOW;
constexpr int AVDepthData_Quality_Quality_ARRAYSIZE = AVDepthData_Quality_Quality_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AVDepthData_Quality_descriptor();
template<typename T>
inline const std::string& AVDepthData_Quality_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AVDepthData_Quality>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AVDepthData_Quality_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AVDepthData_Quality_descriptor(), enum_t_value);
}
inline bool AVDepthData_Quality_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AVDepthData_Quality* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AVDepthData_Quality>(
    AVDepthData_Quality_descriptor(), name, value);
}
enum ARCamera_TrackingState : int {
  ARCamera_TrackingState_UNDEFINED_TRACKING_STATE = 0,
  ARCamera_TrackingState_UNAVAILABLE = 1,
  ARCamera_TrackingState_LIMITED = 2,
  ARCamera_TrackingState_NORMAL = 3
};
bool ARCamera_TrackingState_IsValid(int value);
constexpr ARCamera_TrackingState ARCamera_TrackingState_TrackingState_MIN = ARCamera_TrackingState_UNDEFINED_TRACKING_STATE;
constexpr ARCamera_TrackingState ARCamera_TrackingState_TrackingState_MAX = ARCamera_TrackingState_NORMAL;
constexpr int ARCamera_TrackingState_TrackingState_ARRAYSIZE = ARCamera_TrackingState_TrackingState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ARCamera_TrackingState_descriptor();
template<typename T>
inline const std::string& ARCamera_TrackingState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ARCamera_TrackingState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ARCamera_TrackingState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ARCamera_TrackingState_descriptor(), enum_t_value);
}
inline bool ARCamera_TrackingState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ARCamera_TrackingState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ARCamera_TrackingState>(
    ARCamera_TrackingState_descriptor(), name, value);
}
enum ARCamera_TrackingStateReason : int {
  ARCamera_TrackingStateReason_UNDEFINED_TRACKING_STATE_REASON = 0,
  ARCamera_TrackingStateReason_NONE = 1,
  ARCamera_TrackingStateReason_INITIALIZING = 2,
  ARCamera_TrackingStateReason_EXCESSIVE_MOTION = 3,
  ARCamera_TrackingStateReason_INSUFFICIENT_FEATURES = 4,
  ARCamera_TrackingStateReason_RELOCALIZING = 5
};
bool ARCamera_TrackingStateReason_IsValid(int value);
constexpr ARCamera_TrackingStateReason ARCamera_TrackingStateReason_TrackingStateReason_MIN = ARCamera_TrackingStateReason_UNDEFINED_TRACKING_STATE_REASON;
constexpr ARCamera_TrackingStateReason ARCamera_TrackingStateReason_TrackingStateReason_MAX = ARCamera_TrackingStateReason_RELOCALIZING;
constexpr int ARCamera_TrackingStateReason_TrackingStateReason_ARRAYSIZE = ARCamera_TrackingStateReason_TrackingStateReason_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ARCamera_TrackingStateReason_descriptor();
template<typename T>
inline const std::string& ARCamera_TrackingStateReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ARCamera_TrackingStateReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ARCamera_TrackingStateReason_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ARCamera_TrackingStateReason_descriptor(), enum_t_value);
}
inline bool ARCamera_TrackingStateReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ARCamera_TrackingStateReason* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ARCamera_TrackingStateReason>(
    ARCamera_TrackingStateReason_descriptor(), name, value);
}
enum ARPlaneAnchor_Alignment : int {
  ARPlaneAnchor_Alignment_UNDEFINED = 0,
  ARPlaneAnchor_Alignment_HORIZONTAL = 1,
  ARPlaneAnchor_Alignment_VERTICAL = 2
};
bool ARPlaneAnchor_Alignment_IsValid(int value);
constexpr ARPlaneAnchor_Alignment ARPlaneAnchor_Alignment_Alignment_MIN = ARPlaneAnchor_Alignment_UNDEFINED;
constexpr ARPlaneAnchor_Alignment ARPlaneAnchor_Alignment_Alignment_MAX = ARPlaneAnchor_Alignment_VERTICAL;
constexpr int ARPlaneAnchor_Alignment_Alignment_ARRAYSIZE = ARPlaneAnchor_Alignment_Alignment_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ARPlaneAnchor_Alignment_descriptor();
template<typename T>
inline const std::string& ARPlaneAnchor_Alignment_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ARPlaneAnchor_Alignment>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ARPlaneAnchor_Alignment_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ARPlaneAnchor_Alignment_descriptor(), enum_t_value);
}
inline bool ARPlaneAnchor_Alignment_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ARPlaneAnchor_Alignment* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ARPlaneAnchor_Alignment>(
    ARPlaneAnchor_Alignment_descriptor(), name, value);
}
enum ARPlaneAnchor_PlaneClassification : int {
  ARPlaneAnchor_PlaneClassification_NONE = 0,
  ARPlaneAnchor_PlaneClassification_WALL = 1,
  ARPlaneAnchor_PlaneClassification_FLOOR = 2,
  ARPlaneAnchor_PlaneClassification_CEILING = 3,
  ARPlaneAnchor_PlaneClassification_TABLE = 4,
  ARPlaneAnchor_PlaneClassification_SEAT = 5
};
bool ARPlaneAnchor_PlaneClassification_IsValid(int value);
constexpr ARPlaneAnchor_PlaneClassification ARPlaneAnchor_PlaneClassification_PlaneClassification_MIN = ARPlaneAnchor_PlaneClassification_NONE;
constexpr ARPlaneAnchor_PlaneClassification ARPlaneAnchor_PlaneClassification_PlaneClassification_MAX = ARPlaneAnchor_PlaneClassification_SEAT;
constexpr int ARPlaneAnchor_PlaneClassification_PlaneClassification_ARRAYSIZE = ARPlaneAnchor_PlaneClassification_PlaneClassification_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ARPlaneAnchor_PlaneClassification_descriptor();
template<typename T>
inline const std::string& ARPlaneAnchor_PlaneClassification_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ARPlaneAnchor_PlaneClassification>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ARPlaneAnchor_PlaneClassification_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ARPlaneAnchor_PlaneClassification_descriptor(), enum_t_value);
}
inline bool ARPlaneAnchor_PlaneClassification_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ARPlaneAnchor_PlaneClassification* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ARPlaneAnchor_PlaneClassification>(
    ARPlaneAnchor_PlaneClassification_descriptor(), name, value);
}
enum ARPlaneAnchor_PlaneClassificationStatus : int {
  ARPlaneAnchor_PlaneClassificationStatus_UNKNOWN = 0,
  ARPlaneAnchor_PlaneClassificationStatus_UNAVAILABLE = 1,
  ARPlaneAnchor_PlaneClassificationStatus_UNDETERMINED = 2,
  ARPlaneAnchor_PlaneClassificationStatus_KNOWN = 3
};
bool ARPlaneAnchor_PlaneClassificationStatus_IsValid(int value);
constexpr ARPlaneAnchor_PlaneClassificationStatus ARPlaneAnchor_PlaneClassificationStatus_PlaneClassificationStatus_MIN = ARPlaneAnchor_PlaneClassificationStatus_UNKNOWN;
constexpr ARPlaneAnchor_PlaneClassificationStatus ARPlaneAnchor_PlaneClassificationStatus_PlaneClassificationStatus_MAX = ARPlaneAnchor_PlaneClassificationStatus_KNOWN;
constexpr int ARPlaneAnchor_PlaneClassificationStatus_PlaneClassificationStatus_ARRAYSIZE = ARPlaneAnchor_PlaneClassificationStatus_PlaneClassificationStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ARPlaneAnchor_PlaneClassificationStatus_descriptor();
template<typename T>
inline const std::string& ARPlaneAnchor_PlaneClassificationStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ARPlaneAnchor_PlaneClassificationStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ARPlaneAnchor_PlaneClassificationStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ARPlaneAnchor_PlaneClassificationStatus_descriptor(), enum_t_value);
}
inline bool ARPlaneAnchor_PlaneClassificationStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ARPlaneAnchor_PlaneClassificationStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ARPlaneAnchor_PlaneClassificationStatus>(
    ARPlaneAnchor_PlaneClassificationStatus_descriptor(), name, value);
}
// ===================================================================

class AVCameraCalibrationData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.AVCameraCalibrationData) */ {
 public:
  inline AVCameraCalibrationData() : AVCameraCalibrationData(nullptr) {}
  ~AVCameraCalibrationData() override;
  explicit constexpr AVCameraCalibrationData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AVCameraCalibrationData(const AVCameraCalibrationData& from);
  AVCameraCalibrationData(AVCameraCalibrationData&& from) noexcept
    : AVCameraCalibrationData() {
    *this = ::std::move(from);
  }

  inline AVCameraCalibrationData& operator=(const AVCameraCalibrationData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AVCameraCalibrationData& operator=(AVCameraCalibrationData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AVCameraCalibrationData& default_instance() {
    return *internal_default_instance();
  }
  static inline const AVCameraCalibrationData* internal_default_instance() {
    return reinterpret_cast<const AVCameraCalibrationData*>(
               &_AVCameraCalibrationData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AVCameraCalibrationData& a, AVCameraCalibrationData& b) {
    a.Swap(&b);
  }
  inline void Swap(AVCameraCalibrationData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AVCameraCalibrationData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AVCameraCalibrationData* New() const final {
    return CreateMaybeMessage<AVCameraCalibrationData>(nullptr);
  }

  AVCameraCalibrationData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AVCameraCalibrationData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AVCameraCalibrationData& from);
  void MergeFrom(const AVCameraCalibrationData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AVCameraCalibrationData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.AVCameraCalibrationData";
  }
  protected:
  explicit AVCameraCalibrationData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntrinsicMatrixFieldNumber = 1,
    kExtrinsicMatrixFieldNumber = 4,
    kLensDistortionLookupValuesFieldNumber = 6,
    kInverseLensDistortionLookupValuesFieldNumber = 7,
    kIntrinsicMatrixReferenceDimensionWidthFieldNumber = 2,
    kIntrinsicMatrixReferenceDimensionHeightFieldNumber = 3,
    kPixelSizeFieldNumber = 5,
    kLensDistortionCenterXFieldNumber = 8,
    kLensDistortionCenterYFieldNumber = 9,
  };
  // repeated float intrinsic_matrix = 1 [packed = true];
  int intrinsic_matrix_size() const;
  private:
  int _internal_intrinsic_matrix_size() const;
  public:
  void clear_intrinsic_matrix();
  private:
  float _internal_intrinsic_matrix(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_intrinsic_matrix() const;
  void _internal_add_intrinsic_matrix(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_intrinsic_matrix();
  public:
  float intrinsic_matrix(int index) const;
  void set_intrinsic_matrix(int index, float value);
  void add_intrinsic_matrix(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      intrinsic_matrix() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_intrinsic_matrix();

  // repeated float extrinsic_matrix = 4 [packed = true];
  int extrinsic_matrix_size() const;
  private:
  int _internal_extrinsic_matrix_size() const;
  public:
  void clear_extrinsic_matrix();
  private:
  float _internal_extrinsic_matrix(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_extrinsic_matrix() const;
  void _internal_add_extrinsic_matrix(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_extrinsic_matrix();
  public:
  float extrinsic_matrix(int index) const;
  void set_extrinsic_matrix(int index, float value);
  void add_extrinsic_matrix(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      extrinsic_matrix() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_extrinsic_matrix();

  // repeated float lens_distortion_lookup_values = 6 [packed = true];
  int lens_distortion_lookup_values_size() const;
  private:
  int _internal_lens_distortion_lookup_values_size() const;
  public:
  void clear_lens_distortion_lookup_values();
  private:
  float _internal_lens_distortion_lookup_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_lens_distortion_lookup_values() const;
  void _internal_add_lens_distortion_lookup_values(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_lens_distortion_lookup_values();
  public:
  float lens_distortion_lookup_values(int index) const;
  void set_lens_distortion_lookup_values(int index, float value);
  void add_lens_distortion_lookup_values(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      lens_distortion_lookup_values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_lens_distortion_lookup_values();

  // repeated float inverse_lens_distortion_lookup_values = 7 [packed = true];
  int inverse_lens_distortion_lookup_values_size() const;
  private:
  int _internal_inverse_lens_distortion_lookup_values_size() const;
  public:
  void clear_inverse_lens_distortion_lookup_values();
  private:
  float _internal_inverse_lens_distortion_lookup_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_inverse_lens_distortion_lookup_values() const;
  void _internal_add_inverse_lens_distortion_lookup_values(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_inverse_lens_distortion_lookup_values();
  public:
  float inverse_lens_distortion_lookup_values(int index) const;
  void set_inverse_lens_distortion_lookup_values(int index, float value);
  void add_inverse_lens_distortion_lookup_values(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      inverse_lens_distortion_lookup_values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_inverse_lens_distortion_lookup_values();

  // optional float intrinsic_matrix_reference_dimension_width = 2;
  bool has_intrinsic_matrix_reference_dimension_width() const;
  private:
  bool _internal_has_intrinsic_matrix_reference_dimension_width() const;
  public:
  void clear_intrinsic_matrix_reference_dimension_width();
  float intrinsic_matrix_reference_dimension_width() const;
  void set_intrinsic_matrix_reference_dimension_width(float value);
  private:
  float _internal_intrinsic_matrix_reference_dimension_width() const;
  void _internal_set_intrinsic_matrix_reference_dimension_width(float value);
  public:

  // optional float intrinsic_matrix_reference_dimension_height = 3;
  bool has_intrinsic_matrix_reference_dimension_height() const;
  private:
  bool _internal_has_intrinsic_matrix_reference_dimension_height() const;
  public:
  void clear_intrinsic_matrix_reference_dimension_height();
  float intrinsic_matrix_reference_dimension_height() const;
  void set_intrinsic_matrix_reference_dimension_height(float value);
  private:
  float _internal_intrinsic_matrix_reference_dimension_height() const;
  void _internal_set_intrinsic_matrix_reference_dimension_height(float value);
  public:

  // optional float pixel_size = 5;
  bool has_pixel_size() const;
  private:
  bool _internal_has_pixel_size() const;
  public:
  void clear_pixel_size();
  float pixel_size() const;
  void set_pixel_size(float value);
  private:
  float _internal_pixel_size() const;
  void _internal_set_pixel_size(float value);
  public:

  // optional float lens_distortion_center_x = 8;
  bool has_lens_distortion_center_x() const;
  private:
  bool _internal_has_lens_distortion_center_x() const;
  public:
  void clear_lens_distortion_center_x();
  float lens_distortion_center_x() const;
  void set_lens_distortion_center_x(float value);
  private:
  float _internal_lens_distortion_center_x() const;
  void _internal_set_lens_distortion_center_x(float value);
  public:

  // optional float lens_distortion_center_y = 9;
  bool has_lens_distortion_center_y() const;
  private:
  bool _internal_has_lens_distortion_center_y() const;
  public:
  void clear_lens_distortion_center_y();
  float lens_distortion_center_y() const;
  void set_lens_distortion_center_y(float value);
  private:
  float _internal_lens_distortion_center_y() const;
  void _internal_set_lens_distortion_center_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:mediapipe.AVCameraCalibrationData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > intrinsic_matrix_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > extrinsic_matrix_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > lens_distortion_lookup_values_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > inverse_lens_distortion_lookup_values_;
  float intrinsic_matrix_reference_dimension_width_;
  float intrinsic_matrix_reference_dimension_height_;
  float pixel_size_;
  float lens_distortion_center_x_;
  float lens_distortion_center_y_;
  friend struct ::TableStruct_mediapipe_2fmodules_2fobjectron_2fcalculators_2fa_5fr_5fcapture_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class AVDepthData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.AVDepthData) */ {
 public:
  inline AVDepthData() : AVDepthData(nullptr) {}
  ~AVDepthData() override;
  explicit constexpr AVDepthData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AVDepthData(const AVDepthData& from);
  AVDepthData(AVDepthData&& from) noexcept
    : AVDepthData() {
    *this = ::std::move(from);
  }

  inline AVDepthData& operator=(const AVDepthData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AVDepthData& operator=(AVDepthData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AVDepthData& default_instance() {
    return *internal_default_instance();
  }
  static inline const AVDepthData* internal_default_instance() {
    return reinterpret_cast<const AVDepthData*>(
               &_AVDepthData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AVDepthData& a, AVDepthData& b) {
    a.Swap(&b);
  }
  inline void Swap(AVDepthData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AVDepthData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AVDepthData* New() const final {
    return CreateMaybeMessage<AVDepthData>(nullptr);
  }

  AVDepthData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AVDepthData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AVDepthData& from);
  void MergeFrom(const AVDepthData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AVDepthData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.AVDepthData";
  }
  protected:
  explicit AVDepthData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AVDepthData_Accuracy Accuracy;
  static constexpr Accuracy UNDEFINED_ACCURACY =
    AVDepthData_Accuracy_UNDEFINED_ACCURACY;
  static constexpr Accuracy RELATIVE =
    AVDepthData_Accuracy_RELATIVE;
  static constexpr Accuracy ABSOLUTE =
    AVDepthData_Accuracy_ABSOLUTE;
  static inline bool Accuracy_IsValid(int value) {
    return AVDepthData_Accuracy_IsValid(value);
  }
  static constexpr Accuracy Accuracy_MIN =
    AVDepthData_Accuracy_Accuracy_MIN;
  static constexpr Accuracy Accuracy_MAX =
    AVDepthData_Accuracy_Accuracy_MAX;
  static constexpr int Accuracy_ARRAYSIZE =
    AVDepthData_Accuracy_Accuracy_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Accuracy_descriptor() {
    return AVDepthData_Accuracy_descriptor();
  }
  template<typename T>
  static inline const std::string& Accuracy_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Accuracy>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Accuracy_Name.");
    return AVDepthData_Accuracy_Name(enum_t_value);
  }
  static inline bool Accuracy_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Accuracy* value) {
    return AVDepthData_Accuracy_Parse(name, value);
  }

  typedef AVDepthData_Quality Quality;
  static constexpr Quality UNDEFINED_QUALITY =
    AVDepthData_Quality_UNDEFINED_QUALITY;
  static constexpr Quality HIGH =
    AVDepthData_Quality_HIGH;
  static constexpr Quality LOW =
    AVDepthData_Quality_LOW;
  static inline bool Quality_IsValid(int value) {
    return AVDepthData_Quality_IsValid(value);
  }
  static constexpr Quality Quality_MIN =
    AVDepthData_Quality_Quality_MIN;
  static constexpr Quality Quality_MAX =
    AVDepthData_Quality_Quality_MAX;
  static constexpr int Quality_ARRAYSIZE =
    AVDepthData_Quality_Quality_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Quality_descriptor() {
    return AVDepthData_Quality_descriptor();
  }
  template<typename T>
  static inline const std::string& Quality_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Quality>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Quality_Name.");
    return AVDepthData_Quality_Name(enum_t_value);
  }
  static inline bool Quality_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Quality* value) {
    return AVDepthData_Quality_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDepthDataMapFieldNumber = 1,
    kDepthDataTypeFieldNumber = 2,
    kDepthDataMapRawValuesFieldNumber = 11,
    kCameraCalibrationDataFieldNumber = 6,
    kDepthDataFilteredFieldNumber = 4,
    kDepthDataQualityFieldNumber = 5,
    kDepthDataMapOriginalMinimumValueFieldNumber = 7,
    kDepthDataMapOriginalMaximumValueFieldNumber = 8,
    kDepthDataMapWidthFieldNumber = 9,
    kDepthDataMapHeightFieldNumber = 10,
    kDepthDataAccuracyFieldNumber = 3,
  };
  // optional bytes depth_data_map = 1;
  bool has_depth_data_map() const;
  private:
  bool _internal_has_depth_data_map() const;
  public:
  void clear_depth_data_map();
  const std::string& depth_data_map() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_depth_data_map(ArgT0&& arg0, ArgT... args);
  std::string* mutable_depth_data_map();
  std::string* release_depth_data_map();
  void set_allocated_depth_data_map(std::string* depth_data_map);
  private:
  const std::string& _internal_depth_data_map() const;
  void _internal_set_depth_data_map(const std::string& value);
  std::string* _internal_mutable_depth_data_map();
  public:

  // optional string depth_data_type = 2;
  bool has_depth_data_type() const;
  private:
  bool _internal_has_depth_data_type() const;
  public:
  void clear_depth_data_type();
  const std::string& depth_data_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_depth_data_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_depth_data_type();
  std::string* release_depth_data_type();
  void set_allocated_depth_data_type(std::string* depth_data_type);
  private:
  const std::string& _internal_depth_data_type() const;
  void _internal_set_depth_data_type(const std::string& value);
  std::string* _internal_mutable_depth_data_type();
  public:

  // optional bytes depth_data_map_raw_values = 11;
  bool has_depth_data_map_raw_values() const;
  private:
  bool _internal_has_depth_data_map_raw_values() const;
  public:
  void clear_depth_data_map_raw_values();
  const std::string& depth_data_map_raw_values() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_depth_data_map_raw_values(ArgT0&& arg0, ArgT... args);
  std::string* mutable_depth_data_map_raw_values();
  std::string* release_depth_data_map_raw_values();
  void set_allocated_depth_data_map_raw_values(std::string* depth_data_map_raw_values);
  private:
  const std::string& _internal_depth_data_map_raw_values() const;
  void _internal_set_depth_data_map_raw_values(const std::string& value);
  std::string* _internal_mutable_depth_data_map_raw_values();
  public:

  // optional .mediapipe.AVCameraCalibrationData camera_calibration_data = 6;
  bool has_camera_calibration_data() const;
  private:
  bool _internal_has_camera_calibration_data() const;
  public:
  void clear_camera_calibration_data();
  const ::mediapipe::AVCameraCalibrationData& camera_calibration_data() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::mediapipe::AVCameraCalibrationData* release_camera_calibration_data();
  ::mediapipe::AVCameraCalibrationData* mutable_camera_calibration_data();
  void set_allocated_camera_calibration_data(::mediapipe::AVCameraCalibrationData* camera_calibration_data);
  private:
  const ::mediapipe::AVCameraCalibrationData& _internal_camera_calibration_data() const;
  ::mediapipe::AVCameraCalibrationData* _internal_mutable_camera_calibration_data();
  public:
  void unsafe_arena_set_allocated_camera_calibration_data(
      ::mediapipe::AVCameraCalibrationData* camera_calibration_data);
  ::mediapipe::AVCameraCalibrationData* unsafe_arena_release_camera_calibration_data();

  // optional bool depth_data_filtered = 4;
  bool has_depth_data_filtered() const;
  private:
  bool _internal_has_depth_data_filtered() const;
  public:
  void clear_depth_data_filtered();
  bool depth_data_filtered() const;
  void set_depth_data_filtered(bool value);
  private:
  bool _internal_depth_data_filtered() const;
  void _internal_set_depth_data_filtered(bool value);
  public:

  // optional .mediapipe.AVDepthData.Quality depth_data_quality = 5;
  bool has_depth_data_quality() const;
  private:
  bool _internal_has_depth_data_quality() const;
  public:
  void clear_depth_data_quality();
  ::mediapipe::AVDepthData_Quality depth_data_quality() const;
  void set_depth_data_quality(::mediapipe::AVDepthData_Quality value);
  private:
  ::mediapipe::AVDepthData_Quality _internal_depth_data_quality() const;
  void _internal_set_depth_data_quality(::mediapipe::AVDepthData_Quality value);
  public:

  // optional float depth_data_map_original_minimum_value = 7;
  bool has_depth_data_map_original_minimum_value() const;
  private:
  bool _internal_has_depth_data_map_original_minimum_value() const;
  public:
  void clear_depth_data_map_original_minimum_value();
  float depth_data_map_original_minimum_value() const;
  void set_depth_data_map_original_minimum_value(float value);
  private:
  float _internal_depth_data_map_original_minimum_value() const;
  void _internal_set_depth_data_map_original_minimum_value(float value);
  public:

  // optional float depth_data_map_original_maximum_value = 8;
  bool has_depth_data_map_original_maximum_value() const;
  private:
  bool _internal_has_depth_data_map_original_maximum_value() const;
  public:
  void clear_depth_data_map_original_maximum_value();
  float depth_data_map_original_maximum_value() const;
  void set_depth_data_map_original_maximum_value(float value);
  private:
  float _internal_depth_data_map_original_maximum_value() const;
  void _internal_set_depth_data_map_original_maximum_value(float value);
  public:

  // optional int32 depth_data_map_width = 9;
  bool has_depth_data_map_width() const;
  private:
  bool _internal_has_depth_data_map_width() const;
  public:
  void clear_depth_data_map_width();
  ::PROTOBUF_NAMESPACE_ID::int32 depth_data_map_width() const;
  void set_depth_data_map_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_depth_data_map_width() const;
  void _internal_set_depth_data_map_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 depth_data_map_height = 10;
  bool has_depth_data_map_height() const;
  private:
  bool _internal_has_depth_data_map_height() const;
  public:
  void clear_depth_data_map_height();
  ::PROTOBUF_NAMESPACE_ID::int32 depth_data_map_height() const;
  void set_depth_data_map_height(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_depth_data_map_height() const;
  void _internal_set_depth_data_map_height(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional .mediapipe.AVDepthData.Accuracy depth_data_accuracy = 3 [default = RELATIVE];
  bool has_depth_data_accuracy() const;
  private:
  bool _internal_has_depth_data_accuracy() const;
  public:
  void clear_depth_data_accuracy();
  ::mediapipe::AVDepthData_Accuracy depth_data_accuracy() const;
  void set_depth_data_accuracy(::mediapipe::AVDepthData_Accuracy value);
  private:
  ::mediapipe::AVDepthData_Accuracy _internal_depth_data_accuracy() const;
  void _internal_set_depth_data_accuracy(::mediapipe::AVDepthData_Accuracy value);
  public:

  // @@protoc_insertion_point(class_scope:mediapipe.AVDepthData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr depth_data_map_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr depth_data_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr depth_data_map_raw_values_;
  ::mediapipe::AVCameraCalibrationData* camera_calibration_data_;
  bool depth_data_filtered_;
  int depth_data_quality_;
  float depth_data_map_original_minimum_value_;
  float depth_data_map_original_maximum_value_;
  ::PROTOBUF_NAMESPACE_ID::int32 depth_data_map_width_;
  ::PROTOBUF_NAMESPACE_ID::int32 depth_data_map_height_;
  int depth_data_accuracy_;
  friend struct ::TableStruct_mediapipe_2fmodules_2fobjectron_2fcalculators_2fa_5fr_5fcapture_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class ARLightEstimate_DirectionVector PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.ARLightEstimate.DirectionVector) */ {
 public:
  inline ARLightEstimate_DirectionVector() : ARLightEstimate_DirectionVector(nullptr) {}
  ~ARLightEstimate_DirectionVector() override;
  explicit constexpr ARLightEstimate_DirectionVector(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ARLightEstimate_DirectionVector(const ARLightEstimate_DirectionVector& from);
  ARLightEstimate_DirectionVector(ARLightEstimate_DirectionVector&& from) noexcept
    : ARLightEstimate_DirectionVector() {
    *this = ::std::move(from);
  }

  inline ARLightEstimate_DirectionVector& operator=(const ARLightEstimate_DirectionVector& from) {
    CopyFrom(from);
    return *this;
  }
  inline ARLightEstimate_DirectionVector& operator=(ARLightEstimate_DirectionVector&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ARLightEstimate_DirectionVector& default_instance() {
    return *internal_default_instance();
  }
  static inline const ARLightEstimate_DirectionVector* internal_default_instance() {
    return reinterpret_cast<const ARLightEstimate_DirectionVector*>(
               &_ARLightEstimate_DirectionVector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ARLightEstimate_DirectionVector& a, ARLightEstimate_DirectionVector& b) {
    a.Swap(&b);
  }
  inline void Swap(ARLightEstimate_DirectionVector* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ARLightEstimate_DirectionVector* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ARLightEstimate_DirectionVector* New() const final {
    return CreateMaybeMessage<ARLightEstimate_DirectionVector>(nullptr);
  }

  ARLightEstimate_DirectionVector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ARLightEstimate_DirectionVector>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ARLightEstimate_DirectionVector& from);
  void MergeFrom(const ARLightEstimate_DirectionVector& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ARLightEstimate_DirectionVector* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.ARLightEstimate.DirectionVector";
  }
  protected:
  explicit ARLightEstimate_DirectionVector(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // optional float x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // optional float y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // optional float z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:mediapipe.ARLightEstimate.DirectionVector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  float z_;
  friend struct ::TableStruct_mediapipe_2fmodules_2fobjectron_2fcalculators_2fa_5fr_5fcapture_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class ARLightEstimate PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.ARLightEstimate) */ {
 public:
  inline ARLightEstimate() : ARLightEstimate(nullptr) {}
  ~ARLightEstimate() override;
  explicit constexpr ARLightEstimate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ARLightEstimate(const ARLightEstimate& from);
  ARLightEstimate(ARLightEstimate&& from) noexcept
    : ARLightEstimate() {
    *this = ::std::move(from);
  }

  inline ARLightEstimate& operator=(const ARLightEstimate& from) {
    CopyFrom(from);
    return *this;
  }
  inline ARLightEstimate& operator=(ARLightEstimate&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ARLightEstimate& default_instance() {
    return *internal_default_instance();
  }
  static inline const ARLightEstimate* internal_default_instance() {
    return reinterpret_cast<const ARLightEstimate*>(
               &_ARLightEstimate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ARLightEstimate& a, ARLightEstimate& b) {
    a.Swap(&b);
  }
  inline void Swap(ARLightEstimate* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ARLightEstimate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ARLightEstimate* New() const final {
    return CreateMaybeMessage<ARLightEstimate>(nullptr);
  }

  ARLightEstimate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ARLightEstimate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ARLightEstimate& from);
  void MergeFrom(const ARLightEstimate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ARLightEstimate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.ARLightEstimate";
  }
  protected:
  explicit ARLightEstimate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ARLightEstimate_DirectionVector DirectionVector;

  // accessors -------------------------------------------------------

  enum : int {
    kSphericalHarmonicsCoefficientsFieldNumber = 3,
    kPrimaryLightDirectionFieldNumber = 4,
    kAmbientIntensityFieldNumber = 1,
    kAmbientColorTemperatureFieldNumber = 2,
    kPrimaryLightIntensityFieldNumber = 5,
  };
  // repeated float spherical_harmonics_coefficients = 3 [packed = true];
  int spherical_harmonics_coefficients_size() const;
  private:
  int _internal_spherical_harmonics_coefficients_size() const;
  public:
  void clear_spherical_harmonics_coefficients();
  private:
  float _internal_spherical_harmonics_coefficients(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_spherical_harmonics_coefficients() const;
  void _internal_add_spherical_harmonics_coefficients(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_spherical_harmonics_coefficients();
  public:
  float spherical_harmonics_coefficients(int index) const;
  void set_spherical_harmonics_coefficients(int index, float value);
  void add_spherical_harmonics_coefficients(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      spherical_harmonics_coefficients() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_spherical_harmonics_coefficients();

  // optional .mediapipe.ARLightEstimate.DirectionVector primary_light_direction = 4;
  bool has_primary_light_direction() const;
  private:
  bool _internal_has_primary_light_direction() const;
  public:
  void clear_primary_light_direction();
  const ::mediapipe::ARLightEstimate_DirectionVector& primary_light_direction() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::mediapipe::ARLightEstimate_DirectionVector* release_primary_light_direction();
  ::mediapipe::ARLightEstimate_DirectionVector* mutable_primary_light_direction();
  void set_allocated_primary_light_direction(::mediapipe::ARLightEstimate_DirectionVector* primary_light_direction);
  private:
  const ::mediapipe::ARLightEstimate_DirectionVector& _internal_primary_light_direction() const;
  ::mediapipe::ARLightEstimate_DirectionVector* _internal_mutable_primary_light_direction();
  public:
  void unsafe_arena_set_allocated_primary_light_direction(
      ::mediapipe::ARLightEstimate_DirectionVector* primary_light_direction);
  ::mediapipe::ARLightEstimate_DirectionVector* unsafe_arena_release_primary_light_direction();

  // optional double ambient_intensity = 1;
  bool has_ambient_intensity() const;
  private:
  bool _internal_has_ambient_intensity() const;
  public:
  void clear_ambient_intensity();
  double ambient_intensity() const;
  void set_ambient_intensity(double value);
  private:
  double _internal_ambient_intensity() const;
  void _internal_set_ambient_intensity(double value);
  public:

  // optional double ambient_color_temperature = 2;
  bool has_ambient_color_temperature() const;
  private:
  bool _internal_has_ambient_color_temperature() const;
  public:
  void clear_ambient_color_temperature();
  double ambient_color_temperature() const;
  void set_ambient_color_temperature(double value);
  private:
  double _internal_ambient_color_temperature() const;
  void _internal_set_ambient_color_temperature(double value);
  public:

  // optional float primary_light_intensity = 5;
  bool has_primary_light_intensity() const;
  private:
  bool _internal_has_primary_light_intensity() const;
  public:
  void clear_primary_light_intensity();
  float primary_light_intensity() const;
  void set_primary_light_intensity(float value);
  private:
  float _internal_primary_light_intensity() const;
  void _internal_set_primary_light_intensity(float value);
  public:

  // @@protoc_insertion_point(class_scope:mediapipe.ARLightEstimate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > spherical_harmonics_coefficients_;
  ::mediapipe::ARLightEstimate_DirectionVector* primary_light_direction_;
  double ambient_intensity_;
  double ambient_color_temperature_;
  float primary_light_intensity_;
  friend struct ::TableStruct_mediapipe_2fmodules_2fobjectron_2fcalculators_2fa_5fr_5fcapture_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class ARCamera_EulerAngles PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.ARCamera.EulerAngles) */ {
 public:
  inline ARCamera_EulerAngles() : ARCamera_EulerAngles(nullptr) {}
  ~ARCamera_EulerAngles() override;
  explicit constexpr ARCamera_EulerAngles(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ARCamera_EulerAngles(const ARCamera_EulerAngles& from);
  ARCamera_EulerAngles(ARCamera_EulerAngles&& from) noexcept
    : ARCamera_EulerAngles() {
    *this = ::std::move(from);
  }

  inline ARCamera_EulerAngles& operator=(const ARCamera_EulerAngles& from) {
    CopyFrom(from);
    return *this;
  }
  inline ARCamera_EulerAngles& operator=(ARCamera_EulerAngles&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ARCamera_EulerAngles& default_instance() {
    return *internal_default_instance();
  }
  static inline const ARCamera_EulerAngles* internal_default_instance() {
    return reinterpret_cast<const ARCamera_EulerAngles*>(
               &_ARCamera_EulerAngles_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ARCamera_EulerAngles& a, ARCamera_EulerAngles& b) {
    a.Swap(&b);
  }
  inline void Swap(ARCamera_EulerAngles* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ARCamera_EulerAngles* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ARCamera_EulerAngles* New() const final {
    return CreateMaybeMessage<ARCamera_EulerAngles>(nullptr);
  }

  ARCamera_EulerAngles* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ARCamera_EulerAngles>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ARCamera_EulerAngles& from);
  void MergeFrom(const ARCamera_EulerAngles& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ARCamera_EulerAngles* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.ARCamera.EulerAngles";
  }
  protected:
  explicit ARCamera_EulerAngles(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRollFieldNumber = 1,
    kPitchFieldNumber = 2,
    kYawFieldNumber = 3,
  };
  // optional float roll = 1;
  bool has_roll() const;
  private:
  bool _internal_has_roll() const;
  public:
  void clear_roll();
  float roll() const;
  void set_roll(float value);
  private:
  float _internal_roll() const;
  void _internal_set_roll(float value);
  public:

  // optional float pitch = 2;
  bool has_pitch() const;
  private:
  bool _internal_has_pitch() const;
  public:
  void clear_pitch();
  float pitch() const;
  void set_pitch(float value);
  private:
  float _internal_pitch() const;
  void _internal_set_pitch(float value);
  public:

  // optional float yaw = 3;
  bool has_yaw() const;
  private:
  bool _internal_has_yaw() const;
  public:
  void clear_yaw();
  float yaw() const;
  void set_yaw(float value);
  private:
  float _internal_yaw() const;
  void _internal_set_yaw(float value);
  public:

  // @@protoc_insertion_point(class_scope:mediapipe.ARCamera.EulerAngles)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float roll_;
  float pitch_;
  float yaw_;
  friend struct ::TableStruct_mediapipe_2fmodules_2fobjectron_2fcalculators_2fa_5fr_5fcapture_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class ARCamera PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.ARCamera) */ {
 public:
  inline ARCamera() : ARCamera(nullptr) {}
  ~ARCamera() override;
  explicit constexpr ARCamera(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ARCamera(const ARCamera& from);
  ARCamera(ARCamera&& from) noexcept
    : ARCamera() {
    *this = ::std::move(from);
  }

  inline ARCamera& operator=(const ARCamera& from) {
    CopyFrom(from);
    return *this;
  }
  inline ARCamera& operator=(ARCamera&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ARCamera& default_instance() {
    return *internal_default_instance();
  }
  static inline const ARCamera* internal_default_instance() {
    return reinterpret_cast<const ARCamera*>(
               &_ARCamera_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ARCamera& a, ARCamera& b) {
    a.Swap(&b);
  }
  inline void Swap(ARCamera* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ARCamera* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ARCamera* New() const final {
    return CreateMaybeMessage<ARCamera>(nullptr);
  }

  ARCamera* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ARCamera>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ARCamera& from);
  void MergeFrom(const ARCamera& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ARCamera* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.ARCamera";
  }
  protected:
  explicit ARCamera(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ARCamera_EulerAngles EulerAngles;

  typedef ARCamera_TrackingState TrackingState;
  static constexpr TrackingState UNDEFINED_TRACKING_STATE =
    ARCamera_TrackingState_UNDEFINED_TRACKING_STATE;
  static constexpr TrackingState UNAVAILABLE =
    ARCamera_TrackingState_UNAVAILABLE;
  static constexpr TrackingState LIMITED =
    ARCamera_TrackingState_LIMITED;
  static constexpr TrackingState NORMAL =
    ARCamera_TrackingState_NORMAL;
  static inline bool TrackingState_IsValid(int value) {
    return ARCamera_TrackingState_IsValid(value);
  }
  static constexpr TrackingState TrackingState_MIN =
    ARCamera_TrackingState_TrackingState_MIN;
  static constexpr TrackingState TrackingState_MAX =
    ARCamera_TrackingState_TrackingState_MAX;
  static constexpr int TrackingState_ARRAYSIZE =
    ARCamera_TrackingState_TrackingState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TrackingState_descriptor() {
    return ARCamera_TrackingState_descriptor();
  }
  template<typename T>
  static inline const std::string& TrackingState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TrackingState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TrackingState_Name.");
    return ARCamera_TrackingState_Name(enum_t_value);
  }
  static inline bool TrackingState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TrackingState* value) {
    return ARCamera_TrackingState_Parse(name, value);
  }

  typedef ARCamera_TrackingStateReason TrackingStateReason;
  static constexpr TrackingStateReason UNDEFINED_TRACKING_STATE_REASON =
    ARCamera_TrackingStateReason_UNDEFINED_TRACKING_STATE_REASON;
  static constexpr TrackingStateReason NONE =
    ARCamera_TrackingStateReason_NONE;
  static constexpr TrackingStateReason INITIALIZING =
    ARCamera_TrackingStateReason_INITIALIZING;
  static constexpr TrackingStateReason EXCESSIVE_MOTION =
    ARCamera_TrackingStateReason_EXCESSIVE_MOTION;
  static constexpr TrackingStateReason INSUFFICIENT_FEATURES =
    ARCamera_TrackingStateReason_INSUFFICIENT_FEATURES;
  static constexpr TrackingStateReason RELOCALIZING =
    ARCamera_TrackingStateReason_RELOCALIZING;
  static inline bool TrackingStateReason_IsValid(int value) {
    return ARCamera_TrackingStateReason_IsValid(value);
  }
  static constexpr TrackingStateReason TrackingStateReason_MIN =
    ARCamera_TrackingStateReason_TrackingStateReason_MIN;
  static constexpr TrackingStateReason TrackingStateReason_MAX =
    ARCamera_TrackingStateReason_TrackingStateReason_MAX;
  static constexpr int TrackingStateReason_ARRAYSIZE =
    ARCamera_TrackingStateReason_TrackingStateReason_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TrackingStateReason_descriptor() {
    return ARCamera_TrackingStateReason_descriptor();
  }
  template<typename T>
  static inline const std::string& TrackingStateReason_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TrackingStateReason>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TrackingStateReason_Name.");
    return ARCamera_TrackingStateReason_Name(enum_t_value);
  }
  static inline bool TrackingStateReason_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TrackingStateReason* value) {
    return ARCamera_TrackingStateReason_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTransformFieldNumber = 3,
    kIntrinsicsFieldNumber = 7,
    kProjectionMatrixFieldNumber = 8,
    kViewMatrixFieldNumber = 9,
    kEulerAnglesFieldNumber = 4,
    kImageResolutionWidthFieldNumber = 5,
    kImageResolutionHeightFieldNumber = 6,
    kTrackingStateFieldNumber = 1,
    kTrackingStateReasonFieldNumber = 2,
  };
  // repeated float transform = 3 [packed = true];
  int transform_size() const;
  private:
  int _internal_transform_size() const;
  public:
  void clear_transform();
  private:
  float _internal_transform(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_transform() const;
  void _internal_add_transform(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_transform();
  public:
  float transform(int index) const;
  void set_transform(int index, float value);
  void add_transform(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      transform() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_transform();

  // repeated float intrinsics = 7 [packed = true];
  int intrinsics_size() const;
  private:
  int _internal_intrinsics_size() const;
  public:
  void clear_intrinsics();
  private:
  float _internal_intrinsics(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_intrinsics() const;
  void _internal_add_intrinsics(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_intrinsics();
  public:
  float intrinsics(int index) const;
  void set_intrinsics(int index, float value);
  void add_intrinsics(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      intrinsics() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_intrinsics();

  // repeated float projection_matrix = 8 [packed = true];
  int projection_matrix_size() const;
  private:
  int _internal_projection_matrix_size() const;
  public:
  void clear_projection_matrix();
  private:
  float _internal_projection_matrix(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_projection_matrix() const;
  void _internal_add_projection_matrix(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_projection_matrix();
  public:
  float projection_matrix(int index) const;
  void set_projection_matrix(int index, float value);
  void add_projection_matrix(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      projection_matrix() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_projection_matrix();

  // repeated float view_matrix = 9 [packed = true];
  int view_matrix_size() const;
  private:
  int _internal_view_matrix_size() const;
  public:
  void clear_view_matrix();
  private:
  float _internal_view_matrix(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_view_matrix() const;
  void _internal_add_view_matrix(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_view_matrix();
  public:
  float view_matrix(int index) const;
  void set_view_matrix(int index, float value);
  void add_view_matrix(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      view_matrix() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_view_matrix();

  // optional .mediapipe.ARCamera.EulerAngles euler_angles = 4;
  bool has_euler_angles() const;
  private:
  bool _internal_has_euler_angles() const;
  public:
  void clear_euler_angles();
  const ::mediapipe::ARCamera_EulerAngles& euler_angles() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::mediapipe::ARCamera_EulerAngles* release_euler_angles();
  ::mediapipe::ARCamera_EulerAngles* mutable_euler_angles();
  void set_allocated_euler_angles(::mediapipe::ARCamera_EulerAngles* euler_angles);
  private:
  const ::mediapipe::ARCamera_EulerAngles& _internal_euler_angles() const;
  ::mediapipe::ARCamera_EulerAngles* _internal_mutable_euler_angles();
  public:
  void unsafe_arena_set_allocated_euler_angles(
      ::mediapipe::ARCamera_EulerAngles* euler_angles);
  ::mediapipe::ARCamera_EulerAngles* unsafe_arena_release_euler_angles();

  // optional int32 image_resolution_width = 5;
  bool has_image_resolution_width() const;
  private:
  bool _internal_has_image_resolution_width() const;
  public:
  void clear_image_resolution_width();
  ::PROTOBUF_NAMESPACE_ID::int32 image_resolution_width() const;
  void set_image_resolution_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_image_resolution_width() const;
  void _internal_set_image_resolution_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 image_resolution_height = 6;
  bool has_image_resolution_height() const;
  private:
  bool _internal_has_image_resolution_height() const;
  public:
  void clear_image_resolution_height();
  ::PROTOBUF_NAMESPACE_ID::int32 image_resolution_height() const;
  void set_image_resolution_height(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_image_resolution_height() const;
  void _internal_set_image_resolution_height(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional .mediapipe.ARCamera.TrackingState tracking_state = 1 [default = UNAVAILABLE];
  bool has_tracking_state() const;
  private:
  bool _internal_has_tracking_state() const;
  public:
  void clear_tracking_state();
  ::mediapipe::ARCamera_TrackingState tracking_state() const;
  void set_tracking_state(::mediapipe::ARCamera_TrackingState value);
  private:
  ::mediapipe::ARCamera_TrackingState _internal_tracking_state() const;
  void _internal_set_tracking_state(::mediapipe::ARCamera_TrackingState value);
  public:

  // optional .mediapipe.ARCamera.TrackingStateReason tracking_state_reason = 2 [default = NONE];
  bool has_tracking_state_reason() const;
  private:
  bool _internal_has_tracking_state_reason() const;
  public:
  void clear_tracking_state_reason();
  ::mediapipe::ARCamera_TrackingStateReason tracking_state_reason() const;
  void set_tracking_state_reason(::mediapipe::ARCamera_TrackingStateReason value);
  private:
  ::mediapipe::ARCamera_TrackingStateReason _internal_tracking_state_reason() const;
  void _internal_set_tracking_state_reason(::mediapipe::ARCamera_TrackingStateReason value);
  public:

  // @@protoc_insertion_point(class_scope:mediapipe.ARCamera)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > transform_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > intrinsics_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > projection_matrix_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > view_matrix_;
  ::mediapipe::ARCamera_EulerAngles* euler_angles_;
  ::PROTOBUF_NAMESPACE_ID::int32 image_resolution_width_;
  ::PROTOBUF_NAMESPACE_ID::int32 image_resolution_height_;
  int tracking_state_;
  int tracking_state_reason_;
  friend struct ::TableStruct_mediapipe_2fmodules_2fobjectron_2fcalculators_2fa_5fr_5fcapture_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class ARFaceGeometry_Vertex PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.ARFaceGeometry.Vertex) */ {
 public:
  inline ARFaceGeometry_Vertex() : ARFaceGeometry_Vertex(nullptr) {}
  ~ARFaceGeometry_Vertex() override;
  explicit constexpr ARFaceGeometry_Vertex(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ARFaceGeometry_Vertex(const ARFaceGeometry_Vertex& from);
  ARFaceGeometry_Vertex(ARFaceGeometry_Vertex&& from) noexcept
    : ARFaceGeometry_Vertex() {
    *this = ::std::move(from);
  }

  inline ARFaceGeometry_Vertex& operator=(const ARFaceGeometry_Vertex& from) {
    CopyFrom(from);
    return *this;
  }
  inline ARFaceGeometry_Vertex& operator=(ARFaceGeometry_Vertex&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ARFaceGeometry_Vertex& default_instance() {
    return *internal_default_instance();
  }
  static inline const ARFaceGeometry_Vertex* internal_default_instance() {
    return reinterpret_cast<const ARFaceGeometry_Vertex*>(
               &_ARFaceGeometry_Vertex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ARFaceGeometry_Vertex& a, ARFaceGeometry_Vertex& b) {
    a.Swap(&b);
  }
  inline void Swap(ARFaceGeometry_Vertex* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ARFaceGeometry_Vertex* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ARFaceGeometry_Vertex* New() const final {
    return CreateMaybeMessage<ARFaceGeometry_Vertex>(nullptr);
  }

  ARFaceGeometry_Vertex* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ARFaceGeometry_Vertex>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ARFaceGeometry_Vertex& from);
  void MergeFrom(const ARFaceGeometry_Vertex& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ARFaceGeometry_Vertex* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.ARFaceGeometry.Vertex";
  }
  protected:
  explicit ARFaceGeometry_Vertex(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // optional float x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // optional float y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // optional float z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:mediapipe.ARFaceGeometry.Vertex)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  float z_;
  friend struct ::TableStruct_mediapipe_2fmodules_2fobjectron_2fcalculators_2fa_5fr_5fcapture_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class ARFaceGeometry_TextureCoordinate PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.ARFaceGeometry.TextureCoordinate) */ {
 public:
  inline ARFaceGeometry_TextureCoordinate() : ARFaceGeometry_TextureCoordinate(nullptr) {}
  ~ARFaceGeometry_TextureCoordinate() override;
  explicit constexpr ARFaceGeometry_TextureCoordinate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ARFaceGeometry_TextureCoordinate(const ARFaceGeometry_TextureCoordinate& from);
  ARFaceGeometry_TextureCoordinate(ARFaceGeometry_TextureCoordinate&& from) noexcept
    : ARFaceGeometry_TextureCoordinate() {
    *this = ::std::move(from);
  }

  inline ARFaceGeometry_TextureCoordinate& operator=(const ARFaceGeometry_TextureCoordinate& from) {
    CopyFrom(from);
    return *this;
  }
  inline ARFaceGeometry_TextureCoordinate& operator=(ARFaceGeometry_TextureCoordinate&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ARFaceGeometry_TextureCoordinate& default_instance() {
    return *internal_default_instance();
  }
  static inline const ARFaceGeometry_TextureCoordinate* internal_default_instance() {
    return reinterpret_cast<const ARFaceGeometry_TextureCoordinate*>(
               &_ARFaceGeometry_TextureCoordinate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ARFaceGeometry_TextureCoordinate& a, ARFaceGeometry_TextureCoordinate& b) {
    a.Swap(&b);
  }
  inline void Swap(ARFaceGeometry_TextureCoordinate* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ARFaceGeometry_TextureCoordinate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ARFaceGeometry_TextureCoordinate* New() const final {
    return CreateMaybeMessage<ARFaceGeometry_TextureCoordinate>(nullptr);
  }

  ARFaceGeometry_TextureCoordinate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ARFaceGeometry_TextureCoordinate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ARFaceGeometry_TextureCoordinate& from);
  void MergeFrom(const ARFaceGeometry_TextureCoordinate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ARFaceGeometry_TextureCoordinate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.ARFaceGeometry.TextureCoordinate";
  }
  protected:
  explicit ARFaceGeometry_TextureCoordinate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUFieldNumber = 1,
    kVFieldNumber = 2,
  };
  // optional float u = 1;
  bool has_u() const;
  private:
  bool _internal_has_u() const;
  public:
  void clear_u();
  float u() const;
  void set_u(float value);
  private:
  float _internal_u() const;
  void _internal_set_u(float value);
  public:

  // optional float v = 2;
  bool has_v() const;
  private:
  bool _internal_has_v() const;
  public:
  void clear_v();
  float v() const;
  void set_v(float value);
  private:
  float _internal_v() const;
  void _internal_set_v(float value);
  public:

  // @@protoc_insertion_point(class_scope:mediapipe.ARFaceGeometry.TextureCoordinate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float u_;
  float v_;
  friend struct ::TableStruct_mediapipe_2fmodules_2fobjectron_2fcalculators_2fa_5fr_5fcapture_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class ARFaceGeometry PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.ARFaceGeometry) */ {
 public:
  inline ARFaceGeometry() : ARFaceGeometry(nullptr) {}
  ~ARFaceGeometry() override;
  explicit constexpr ARFaceGeometry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ARFaceGeometry(const ARFaceGeometry& from);
  ARFaceGeometry(ARFaceGeometry&& from) noexcept
    : ARFaceGeometry() {
    *this = ::std::move(from);
  }

  inline ARFaceGeometry& operator=(const ARFaceGeometry& from) {
    CopyFrom(from);
    return *this;
  }
  inline ARFaceGeometry& operator=(ARFaceGeometry&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ARFaceGeometry& default_instance() {
    return *internal_default_instance();
  }
  static inline const ARFaceGeometry* internal_default_instance() {
    return reinterpret_cast<const ARFaceGeometry*>(
               &_ARFaceGeometry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ARFaceGeometry& a, ARFaceGeometry& b) {
    a.Swap(&b);
  }
  inline void Swap(ARFaceGeometry* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ARFaceGeometry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ARFaceGeometry* New() const final {
    return CreateMaybeMessage<ARFaceGeometry>(nullptr);
  }

  ARFaceGeometry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ARFaceGeometry>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ARFaceGeometry& from);
  void MergeFrom(const ARFaceGeometry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ARFaceGeometry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.ARFaceGeometry";
  }
  protected:
  explicit ARFaceGeometry(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ARFaceGeometry_Vertex Vertex;
  typedef ARFaceGeometry_TextureCoordinate TextureCoordinate;

  // accessors -------------------------------------------------------

  enum : int {
    kVerticesFieldNumber = 1,
    kTextureCoordinatesFieldNumber = 3,
    kTriangleIndicesFieldNumber = 5,
    kVertexCountFieldNumber = 2,
    kTextureCoordinateCountFieldNumber = 4,
    kTriangleCountFieldNumber = 6,
  };
  // repeated .mediapipe.ARFaceGeometry.Vertex vertices = 1;
  int vertices_size() const;
  private:
  int _internal_vertices_size() const;
  public:
  void clear_vertices();
  ::mediapipe::ARFaceGeometry_Vertex* mutable_vertices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARFaceGeometry_Vertex >*
      mutable_vertices();
  private:
  const ::mediapipe::ARFaceGeometry_Vertex& _internal_vertices(int index) const;
  ::mediapipe::ARFaceGeometry_Vertex* _internal_add_vertices();
  public:
  const ::mediapipe::ARFaceGeometry_Vertex& vertices(int index) const;
  ::mediapipe::ARFaceGeometry_Vertex* add_vertices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARFaceGeometry_Vertex >&
      vertices() const;

  // repeated .mediapipe.ARFaceGeometry.TextureCoordinate texture_coordinates = 3;
  int texture_coordinates_size() const;
  private:
  int _internal_texture_coordinates_size() const;
  public:
  void clear_texture_coordinates();
  ::mediapipe::ARFaceGeometry_TextureCoordinate* mutable_texture_coordinates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARFaceGeometry_TextureCoordinate >*
      mutable_texture_coordinates();
  private:
  const ::mediapipe::ARFaceGeometry_TextureCoordinate& _internal_texture_coordinates(int index) const;
  ::mediapipe::ARFaceGeometry_TextureCoordinate* _internal_add_texture_coordinates();
  public:
  const ::mediapipe::ARFaceGeometry_TextureCoordinate& texture_coordinates(int index) const;
  ::mediapipe::ARFaceGeometry_TextureCoordinate* add_texture_coordinates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARFaceGeometry_TextureCoordinate >&
      texture_coordinates() const;

  // repeated int32 triangle_indices = 5 [packed = true];
  int triangle_indices_size() const;
  private:
  int _internal_triangle_indices_size() const;
  public:
  void clear_triangle_indices();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_triangle_indices(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_triangle_indices() const;
  void _internal_add_triangle_indices(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_triangle_indices();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 triangle_indices(int index) const;
  void set_triangle_indices(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_triangle_indices(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      triangle_indices() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_triangle_indices();

  // optional int32 vertex_count = 2;
  bool has_vertex_count() const;
  private:
  bool _internal_has_vertex_count() const;
  public:
  void clear_vertex_count();
  ::PROTOBUF_NAMESPACE_ID::int32 vertex_count() const;
  void set_vertex_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_vertex_count() const;
  void _internal_set_vertex_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 texture_coordinate_count = 4;
  bool has_texture_coordinate_count() const;
  private:
  bool _internal_has_texture_coordinate_count() const;
  public:
  void clear_texture_coordinate_count();
  ::PROTOBUF_NAMESPACE_ID::int32 texture_coordinate_count() const;
  void set_texture_coordinate_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_texture_coordinate_count() const;
  void _internal_set_texture_coordinate_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 triangle_count = 6;
  bool has_triangle_count() const;
  private:
  bool _internal_has_triangle_count() const;
  public:
  void clear_triangle_count();
  ::PROTOBUF_NAMESPACE_ID::int32 triangle_count() const;
  void set_triangle_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_triangle_count() const;
  void _internal_set_triangle_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:mediapipe.ARFaceGeometry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARFaceGeometry_Vertex > vertices_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARFaceGeometry_TextureCoordinate > texture_coordinates_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > triangle_indices_;
  mutable std::atomic<int> _triangle_indices_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 vertex_count_;
  ::PROTOBUF_NAMESPACE_ID::int32 texture_coordinate_count_;
  ::PROTOBUF_NAMESPACE_ID::int32 triangle_count_;
  friend struct ::TableStruct_mediapipe_2fmodules_2fobjectron_2fcalculators_2fa_5fr_5fcapture_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class ARBlendShapeMap_MapEntry PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.ARBlendShapeMap.MapEntry) */ {
 public:
  inline ARBlendShapeMap_MapEntry() : ARBlendShapeMap_MapEntry(nullptr) {}
  ~ARBlendShapeMap_MapEntry() override;
  explicit constexpr ARBlendShapeMap_MapEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ARBlendShapeMap_MapEntry(const ARBlendShapeMap_MapEntry& from);
  ARBlendShapeMap_MapEntry(ARBlendShapeMap_MapEntry&& from) noexcept
    : ARBlendShapeMap_MapEntry() {
    *this = ::std::move(from);
  }

  inline ARBlendShapeMap_MapEntry& operator=(const ARBlendShapeMap_MapEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline ARBlendShapeMap_MapEntry& operator=(ARBlendShapeMap_MapEntry&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ARBlendShapeMap_MapEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const ARBlendShapeMap_MapEntry* internal_default_instance() {
    return reinterpret_cast<const ARBlendShapeMap_MapEntry*>(
               &_ARBlendShapeMap_MapEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ARBlendShapeMap_MapEntry& a, ARBlendShapeMap_MapEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(ARBlendShapeMap_MapEntry* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ARBlendShapeMap_MapEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ARBlendShapeMap_MapEntry* New() const final {
    return CreateMaybeMessage<ARBlendShapeMap_MapEntry>(nullptr);
  }

  ARBlendShapeMap_MapEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ARBlendShapeMap_MapEntry>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ARBlendShapeMap_MapEntry& from);
  void MergeFrom(const ARBlendShapeMap_MapEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ARBlendShapeMap_MapEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.ARBlendShapeMap.MapEntry";
  }
  protected:
  explicit ARBlendShapeMap_MapEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlendShapeLocationFieldNumber = 1,
    kBlendShapeCoefficientFieldNumber = 2,
  };
  // optional string blend_shape_location = 1;
  bool has_blend_shape_location() const;
  private:
  bool _internal_has_blend_shape_location() const;
  public:
  void clear_blend_shape_location();
  const std::string& blend_shape_location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_blend_shape_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_blend_shape_location();
  std::string* release_blend_shape_location();
  void set_allocated_blend_shape_location(std::string* blend_shape_location);
  private:
  const std::string& _internal_blend_shape_location() const;
  void _internal_set_blend_shape_location(const std::string& value);
  std::string* _internal_mutable_blend_shape_location();
  public:

  // optional float blend_shape_coefficient = 2;
  bool has_blend_shape_coefficient() const;
  private:
  bool _internal_has_blend_shape_coefficient() const;
  public:
  void clear_blend_shape_coefficient();
  float blend_shape_coefficient() const;
  void set_blend_shape_coefficient(float value);
  private:
  float _internal_blend_shape_coefficient() const;
  void _internal_set_blend_shape_coefficient(float value);
  public:

  // @@protoc_insertion_point(class_scope:mediapipe.ARBlendShapeMap.MapEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blend_shape_location_;
  float blend_shape_coefficient_;
  friend struct ::TableStruct_mediapipe_2fmodules_2fobjectron_2fcalculators_2fa_5fr_5fcapture_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class ARBlendShapeMap PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.ARBlendShapeMap) */ {
 public:
  inline ARBlendShapeMap() : ARBlendShapeMap(nullptr) {}
  ~ARBlendShapeMap() override;
  explicit constexpr ARBlendShapeMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ARBlendShapeMap(const ARBlendShapeMap& from);
  ARBlendShapeMap(ARBlendShapeMap&& from) noexcept
    : ARBlendShapeMap() {
    *this = ::std::move(from);
  }

  inline ARBlendShapeMap& operator=(const ARBlendShapeMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline ARBlendShapeMap& operator=(ARBlendShapeMap&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ARBlendShapeMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const ARBlendShapeMap* internal_default_instance() {
    return reinterpret_cast<const ARBlendShapeMap*>(
               &_ARBlendShapeMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ARBlendShapeMap& a, ARBlendShapeMap& b) {
    a.Swap(&b);
  }
  inline void Swap(ARBlendShapeMap* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ARBlendShapeMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ARBlendShapeMap* New() const final {
    return CreateMaybeMessage<ARBlendShapeMap>(nullptr);
  }

  ARBlendShapeMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ARBlendShapeMap>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ARBlendShapeMap& from);
  void MergeFrom(const ARBlendShapeMap& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ARBlendShapeMap* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.ARBlendShapeMap";
  }
  protected:
  explicit ARBlendShapeMap(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ARBlendShapeMap_MapEntry MapEntry;

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
  };
  // repeated .mediapipe.ARBlendShapeMap.MapEntry entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::mediapipe::ARBlendShapeMap_MapEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARBlendShapeMap_MapEntry >*
      mutable_entries();
  private:
  const ::mediapipe::ARBlendShapeMap_MapEntry& _internal_entries(int index) const;
  ::mediapipe::ARBlendShapeMap_MapEntry* _internal_add_entries();
  public:
  const ::mediapipe::ARBlendShapeMap_MapEntry& entries(int index) const;
  ::mediapipe::ARBlendShapeMap_MapEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARBlendShapeMap_MapEntry >&
      entries() const;

  // @@protoc_insertion_point(class_scope:mediapipe.ARBlendShapeMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARBlendShapeMap_MapEntry > entries_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mediapipe_2fmodules_2fobjectron_2fcalculators_2fa_5fr_5fcapture_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class ARFaceAnchor PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.ARFaceAnchor) */ {
 public:
  inline ARFaceAnchor() : ARFaceAnchor(nullptr) {}
  ~ARFaceAnchor() override;
  explicit constexpr ARFaceAnchor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ARFaceAnchor(const ARFaceAnchor& from);
  ARFaceAnchor(ARFaceAnchor&& from) noexcept
    : ARFaceAnchor() {
    *this = ::std::move(from);
  }

  inline ARFaceAnchor& operator=(const ARFaceAnchor& from) {
    CopyFrom(from);
    return *this;
  }
  inline ARFaceAnchor& operator=(ARFaceAnchor&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ARFaceAnchor& default_instance() {
    return *internal_default_instance();
  }
  static inline const ARFaceAnchor* internal_default_instance() {
    return reinterpret_cast<const ARFaceAnchor*>(
               &_ARFaceAnchor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ARFaceAnchor& a, ARFaceAnchor& b) {
    a.Swap(&b);
  }
  inline void Swap(ARFaceAnchor* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ARFaceAnchor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ARFaceAnchor* New() const final {
    return CreateMaybeMessage<ARFaceAnchor>(nullptr);
  }

  ARFaceAnchor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ARFaceAnchor>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ARFaceAnchor& from);
  void MergeFrom(const ARFaceAnchor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ARFaceAnchor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.ARFaceAnchor";
  }
  protected:
  explicit ARFaceAnchor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransformFieldNumber = 3,
    kGeometryFieldNumber = 1,
    kBlendShapesFieldNumber = 2,
    kIsTrackedFieldNumber = 4,
  };
  // repeated float transform = 3;
  int transform_size() const;
  private:
  int _internal_transform_size() const;
  public:
  void clear_transform();
  private:
  float _internal_transform(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_transform() const;
  void _internal_add_transform(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_transform();
  public:
  float transform(int index) const;
  void set_transform(int index, float value);
  void add_transform(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      transform() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_transform();

  // optional .mediapipe.ARFaceGeometry geometry = 1;
  bool has_geometry() const;
  private:
  bool _internal_has_geometry() const;
  public:
  void clear_geometry();
  const ::mediapipe::ARFaceGeometry& geometry() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::mediapipe::ARFaceGeometry* release_geometry();
  ::mediapipe::ARFaceGeometry* mutable_geometry();
  void set_allocated_geometry(::mediapipe::ARFaceGeometry* geometry);
  private:
  const ::mediapipe::ARFaceGeometry& _internal_geometry() const;
  ::mediapipe::ARFaceGeometry* _internal_mutable_geometry();
  public:
  void unsafe_arena_set_allocated_geometry(
      ::mediapipe::ARFaceGeometry* geometry);
  ::mediapipe::ARFaceGeometry* unsafe_arena_release_geometry();

  // optional .mediapipe.ARBlendShapeMap blend_shapes = 2;
  bool has_blend_shapes() const;
  private:
  bool _internal_has_blend_shapes() const;
  public:
  void clear_blend_shapes();
  const ::mediapipe::ARBlendShapeMap& blend_shapes() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::mediapipe::ARBlendShapeMap* release_blend_shapes();
  ::mediapipe::ARBlendShapeMap* mutable_blend_shapes();
  void set_allocated_blend_shapes(::mediapipe::ARBlendShapeMap* blend_shapes);
  private:
  const ::mediapipe::ARBlendShapeMap& _internal_blend_shapes() const;
  ::mediapipe::ARBlendShapeMap* _internal_mutable_blend_shapes();
  public:
  void unsafe_arena_set_allocated_blend_shapes(
      ::mediapipe::ARBlendShapeMap* blend_shapes);
  ::mediapipe::ARBlendShapeMap* unsafe_arena_release_blend_shapes();

  // optional bool is_tracked = 4;
  bool has_is_tracked() const;
  private:
  bool _internal_has_is_tracked() const;
  public:
  void clear_is_tracked();
  bool is_tracked() const;
  void set_is_tracked(bool value);
  private:
  bool _internal_is_tracked() const;
  void _internal_set_is_tracked(bool value);
  public:

  // @@protoc_insertion_point(class_scope:mediapipe.ARFaceAnchor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > transform_;
  ::mediapipe::ARFaceGeometry* geometry_;
  ::mediapipe::ARBlendShapeMap* blend_shapes_;
  bool is_tracked_;
  friend struct ::TableStruct_mediapipe_2fmodules_2fobjectron_2fcalculators_2fa_5fr_5fcapture_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class ARPlaneGeometry_Vertex PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.ARPlaneGeometry.Vertex) */ {
 public:
  inline ARPlaneGeometry_Vertex() : ARPlaneGeometry_Vertex(nullptr) {}
  ~ARPlaneGeometry_Vertex() override;
  explicit constexpr ARPlaneGeometry_Vertex(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ARPlaneGeometry_Vertex(const ARPlaneGeometry_Vertex& from);
  ARPlaneGeometry_Vertex(ARPlaneGeometry_Vertex&& from) noexcept
    : ARPlaneGeometry_Vertex() {
    *this = ::std::move(from);
  }

  inline ARPlaneGeometry_Vertex& operator=(const ARPlaneGeometry_Vertex& from) {
    CopyFrom(from);
    return *this;
  }
  inline ARPlaneGeometry_Vertex& operator=(ARPlaneGeometry_Vertex&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ARPlaneGeometry_Vertex& default_instance() {
    return *internal_default_instance();
  }
  static inline const ARPlaneGeometry_Vertex* internal_default_instance() {
    return reinterpret_cast<const ARPlaneGeometry_Vertex*>(
               &_ARPlaneGeometry_Vertex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ARPlaneGeometry_Vertex& a, ARPlaneGeometry_Vertex& b) {
    a.Swap(&b);
  }
  inline void Swap(ARPlaneGeometry_Vertex* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ARPlaneGeometry_Vertex* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ARPlaneGeometry_Vertex* New() const final {
    return CreateMaybeMessage<ARPlaneGeometry_Vertex>(nullptr);
  }

  ARPlaneGeometry_Vertex* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ARPlaneGeometry_Vertex>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ARPlaneGeometry_Vertex& from);
  void MergeFrom(const ARPlaneGeometry_Vertex& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ARPlaneGeometry_Vertex* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.ARPlaneGeometry.Vertex";
  }
  protected:
  explicit ARPlaneGeometry_Vertex(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // optional float x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // optional float y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // optional float z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:mediapipe.ARPlaneGeometry.Vertex)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  float z_;
  friend struct ::TableStruct_mediapipe_2fmodules_2fobjectron_2fcalculators_2fa_5fr_5fcapture_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class ARPlaneGeometry_TextureCoordinate PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.ARPlaneGeometry.TextureCoordinate) */ {
 public:
  inline ARPlaneGeometry_TextureCoordinate() : ARPlaneGeometry_TextureCoordinate(nullptr) {}
  ~ARPlaneGeometry_TextureCoordinate() override;
  explicit constexpr ARPlaneGeometry_TextureCoordinate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ARPlaneGeometry_TextureCoordinate(const ARPlaneGeometry_TextureCoordinate& from);
  ARPlaneGeometry_TextureCoordinate(ARPlaneGeometry_TextureCoordinate&& from) noexcept
    : ARPlaneGeometry_TextureCoordinate() {
    *this = ::std::move(from);
  }

  inline ARPlaneGeometry_TextureCoordinate& operator=(const ARPlaneGeometry_TextureCoordinate& from) {
    CopyFrom(from);
    return *this;
  }
  inline ARPlaneGeometry_TextureCoordinate& operator=(ARPlaneGeometry_TextureCoordinate&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ARPlaneGeometry_TextureCoordinate& default_instance() {
    return *internal_default_instance();
  }
  static inline const ARPlaneGeometry_TextureCoordinate* internal_default_instance() {
    return reinterpret_cast<const ARPlaneGeometry_TextureCoordinate*>(
               &_ARPlaneGeometry_TextureCoordinate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ARPlaneGeometry_TextureCoordinate& a, ARPlaneGeometry_TextureCoordinate& b) {
    a.Swap(&b);
  }
  inline void Swap(ARPlaneGeometry_TextureCoordinate* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ARPlaneGeometry_TextureCoordinate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ARPlaneGeometry_TextureCoordinate* New() const final {
    return CreateMaybeMessage<ARPlaneGeometry_TextureCoordinate>(nullptr);
  }

  ARPlaneGeometry_TextureCoordinate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ARPlaneGeometry_TextureCoordinate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ARPlaneGeometry_TextureCoordinate& from);
  void MergeFrom(const ARPlaneGeometry_TextureCoordinate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ARPlaneGeometry_TextureCoordinate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.ARPlaneGeometry.TextureCoordinate";
  }
  protected:
  explicit ARPlaneGeometry_TextureCoordinate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUFieldNumber = 1,
    kVFieldNumber = 2,
  };
  // optional float u = 1;
  bool has_u() const;
  private:
  bool _internal_has_u() const;
  public:
  void clear_u();
  float u() const;
  void set_u(float value);
  private:
  float _internal_u() const;
  void _internal_set_u(float value);
  public:

  // optional float v = 2;
  bool has_v() const;
  private:
  bool _internal_has_v() const;
  public:
  void clear_v();
  float v() const;
  void set_v(float value);
  private:
  float _internal_v() const;
  void _internal_set_v(float value);
  public:

  // @@protoc_insertion_point(class_scope:mediapipe.ARPlaneGeometry.TextureCoordinate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float u_;
  float v_;
  friend struct ::TableStruct_mediapipe_2fmodules_2fobjectron_2fcalculators_2fa_5fr_5fcapture_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class ARPlaneGeometry PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.ARPlaneGeometry) */ {
 public:
  inline ARPlaneGeometry() : ARPlaneGeometry(nullptr) {}
  ~ARPlaneGeometry() override;
  explicit constexpr ARPlaneGeometry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ARPlaneGeometry(const ARPlaneGeometry& from);
  ARPlaneGeometry(ARPlaneGeometry&& from) noexcept
    : ARPlaneGeometry() {
    *this = ::std::move(from);
  }

  inline ARPlaneGeometry& operator=(const ARPlaneGeometry& from) {
    CopyFrom(from);
    return *this;
  }
  inline ARPlaneGeometry& operator=(ARPlaneGeometry&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ARPlaneGeometry& default_instance() {
    return *internal_default_instance();
  }
  static inline const ARPlaneGeometry* internal_default_instance() {
    return reinterpret_cast<const ARPlaneGeometry*>(
               &_ARPlaneGeometry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ARPlaneGeometry& a, ARPlaneGeometry& b) {
    a.Swap(&b);
  }
  inline void Swap(ARPlaneGeometry* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ARPlaneGeometry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ARPlaneGeometry* New() const final {
    return CreateMaybeMessage<ARPlaneGeometry>(nullptr);
  }

  ARPlaneGeometry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ARPlaneGeometry>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ARPlaneGeometry& from);
  void MergeFrom(const ARPlaneGeometry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ARPlaneGeometry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.ARPlaneGeometry";
  }
  protected:
  explicit ARPlaneGeometry(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ARPlaneGeometry_Vertex Vertex;
  typedef ARPlaneGeometry_TextureCoordinate TextureCoordinate;

  // accessors -------------------------------------------------------

  enum : int {
    kVerticesFieldNumber = 1,
    kTextureCoordinatesFieldNumber = 3,
    kTriangleIndicesFieldNumber = 5,
    kBoundaryVerticesFieldNumber = 7,
    kVertexCountFieldNumber = 2,
    kTextureCoordinateCountFieldNumber = 4,
    kTriangleCountFieldNumber = 6,
    kBoundaryVertexCountFieldNumber = 8,
  };
  // repeated .mediapipe.ARPlaneGeometry.Vertex vertices = 1;
  int vertices_size() const;
  private:
  int _internal_vertices_size() const;
  public:
  void clear_vertices();
  ::mediapipe::ARPlaneGeometry_Vertex* mutable_vertices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARPlaneGeometry_Vertex >*
      mutable_vertices();
  private:
  const ::mediapipe::ARPlaneGeometry_Vertex& _internal_vertices(int index) const;
  ::mediapipe::ARPlaneGeometry_Vertex* _internal_add_vertices();
  public:
  const ::mediapipe::ARPlaneGeometry_Vertex& vertices(int index) const;
  ::mediapipe::ARPlaneGeometry_Vertex* add_vertices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARPlaneGeometry_Vertex >&
      vertices() const;

  // repeated .mediapipe.ARPlaneGeometry.TextureCoordinate texture_coordinates = 3;
  int texture_coordinates_size() const;
  private:
  int _internal_texture_coordinates_size() const;
  public:
  void clear_texture_coordinates();
  ::mediapipe::ARPlaneGeometry_TextureCoordinate* mutable_texture_coordinates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARPlaneGeometry_TextureCoordinate >*
      mutable_texture_coordinates();
  private:
  const ::mediapipe::ARPlaneGeometry_TextureCoordinate& _internal_texture_coordinates(int index) const;
  ::mediapipe::ARPlaneGeometry_TextureCoordinate* _internal_add_texture_coordinates();
  public:
  const ::mediapipe::ARPlaneGeometry_TextureCoordinate& texture_coordinates(int index) const;
  ::mediapipe::ARPlaneGeometry_TextureCoordinate* add_texture_coordinates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARPlaneGeometry_TextureCoordinate >&
      texture_coordinates() const;

  // repeated int32 triangle_indices = 5 [packed = true];
  int triangle_indices_size() const;
  private:
  int _internal_triangle_indices_size() const;
  public:
  void clear_triangle_indices();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_triangle_indices(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_triangle_indices() const;
  void _internal_add_triangle_indices(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_triangle_indices();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 triangle_indices(int index) const;
  void set_triangle_indices(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_triangle_indices(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      triangle_indices() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_triangle_indices();

  // repeated .mediapipe.ARPlaneGeometry.Vertex boundary_vertices = 7;
  int boundary_vertices_size() const;
  private:
  int _internal_boundary_vertices_size() const;
  public:
  void clear_boundary_vertices();
  ::mediapipe::ARPlaneGeometry_Vertex* mutable_boundary_vertices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARPlaneGeometry_Vertex >*
      mutable_boundary_vertices();
  private:
  const ::mediapipe::ARPlaneGeometry_Vertex& _internal_boundary_vertices(int index) const;
  ::mediapipe::ARPlaneGeometry_Vertex* _internal_add_boundary_vertices();
  public:
  const ::mediapipe::ARPlaneGeometry_Vertex& boundary_vertices(int index) const;
  ::mediapipe::ARPlaneGeometry_Vertex* add_boundary_vertices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARPlaneGeometry_Vertex >&
      boundary_vertices() const;

  // optional int32 vertex_count = 2;
  bool has_vertex_count() const;
  private:
  bool _internal_has_vertex_count() const;
  public:
  void clear_vertex_count();
  ::PROTOBUF_NAMESPACE_ID::int32 vertex_count() const;
  void set_vertex_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_vertex_count() const;
  void _internal_set_vertex_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 texture_coordinate_count = 4;
  bool has_texture_coordinate_count() const;
  private:
  bool _internal_has_texture_coordinate_count() const;
  public:
  void clear_texture_coordinate_count();
  ::PROTOBUF_NAMESPACE_ID::int32 texture_coordinate_count() const;
  void set_texture_coordinate_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_texture_coordinate_count() const;
  void _internal_set_texture_coordinate_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 triangle_count = 6;
  bool has_triangle_count() const;
  private:
  bool _internal_has_triangle_count() const;
  public:
  void clear_triangle_count();
  ::PROTOBUF_NAMESPACE_ID::int32 triangle_count() const;
  void set_triangle_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_triangle_count() const;
  void _internal_set_triangle_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 boundary_vertex_count = 8;
  bool has_boundary_vertex_count() const;
  private:
  bool _internal_has_boundary_vertex_count() const;
  public:
  void clear_boundary_vertex_count();
  ::PROTOBUF_NAMESPACE_ID::int32 boundary_vertex_count() const;
  void set_boundary_vertex_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_boundary_vertex_count() const;
  void _internal_set_boundary_vertex_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:mediapipe.ARPlaneGeometry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARPlaneGeometry_Vertex > vertices_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARPlaneGeometry_TextureCoordinate > texture_coordinates_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > triangle_indices_;
  mutable std::atomic<int> _triangle_indices_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARPlaneGeometry_Vertex > boundary_vertices_;
  ::PROTOBUF_NAMESPACE_ID::int32 vertex_count_;
  ::PROTOBUF_NAMESPACE_ID::int32 texture_coordinate_count_;
  ::PROTOBUF_NAMESPACE_ID::int32 triangle_count_;
  ::PROTOBUF_NAMESPACE_ID::int32 boundary_vertex_count_;
  friend struct ::TableStruct_mediapipe_2fmodules_2fobjectron_2fcalculators_2fa_5fr_5fcapture_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class ARPlaneAnchor_PlaneVector PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.ARPlaneAnchor.PlaneVector) */ {
 public:
  inline ARPlaneAnchor_PlaneVector() : ARPlaneAnchor_PlaneVector(nullptr) {}
  ~ARPlaneAnchor_PlaneVector() override;
  explicit constexpr ARPlaneAnchor_PlaneVector(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ARPlaneAnchor_PlaneVector(const ARPlaneAnchor_PlaneVector& from);
  ARPlaneAnchor_PlaneVector(ARPlaneAnchor_PlaneVector&& from) noexcept
    : ARPlaneAnchor_PlaneVector() {
    *this = ::std::move(from);
  }

  inline ARPlaneAnchor_PlaneVector& operator=(const ARPlaneAnchor_PlaneVector& from) {
    CopyFrom(from);
    return *this;
  }
  inline ARPlaneAnchor_PlaneVector& operator=(ARPlaneAnchor_PlaneVector&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ARPlaneAnchor_PlaneVector& default_instance() {
    return *internal_default_instance();
  }
  static inline const ARPlaneAnchor_PlaneVector* internal_default_instance() {
    return reinterpret_cast<const ARPlaneAnchor_PlaneVector*>(
               &_ARPlaneAnchor_PlaneVector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ARPlaneAnchor_PlaneVector& a, ARPlaneAnchor_PlaneVector& b) {
    a.Swap(&b);
  }
  inline void Swap(ARPlaneAnchor_PlaneVector* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ARPlaneAnchor_PlaneVector* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ARPlaneAnchor_PlaneVector* New() const final {
    return CreateMaybeMessage<ARPlaneAnchor_PlaneVector>(nullptr);
  }

  ARPlaneAnchor_PlaneVector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ARPlaneAnchor_PlaneVector>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ARPlaneAnchor_PlaneVector& from);
  void MergeFrom(const ARPlaneAnchor_PlaneVector& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ARPlaneAnchor_PlaneVector* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.ARPlaneAnchor.PlaneVector";
  }
  protected:
  explicit ARPlaneAnchor_PlaneVector(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // optional float x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // optional float y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // optional float z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:mediapipe.ARPlaneAnchor.PlaneVector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  float z_;
  friend struct ::TableStruct_mediapipe_2fmodules_2fobjectron_2fcalculators_2fa_5fr_5fcapture_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class ARPlaneAnchor PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.ARPlaneAnchor) */ {
 public:
  inline ARPlaneAnchor() : ARPlaneAnchor(nullptr) {}
  ~ARPlaneAnchor() override;
  explicit constexpr ARPlaneAnchor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ARPlaneAnchor(const ARPlaneAnchor& from);
  ARPlaneAnchor(ARPlaneAnchor&& from) noexcept
    : ARPlaneAnchor() {
    *this = ::std::move(from);
  }

  inline ARPlaneAnchor& operator=(const ARPlaneAnchor& from) {
    CopyFrom(from);
    return *this;
  }
  inline ARPlaneAnchor& operator=(ARPlaneAnchor&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ARPlaneAnchor& default_instance() {
    return *internal_default_instance();
  }
  static inline const ARPlaneAnchor* internal_default_instance() {
    return reinterpret_cast<const ARPlaneAnchor*>(
               &_ARPlaneAnchor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ARPlaneAnchor& a, ARPlaneAnchor& b) {
    a.Swap(&b);
  }
  inline void Swap(ARPlaneAnchor* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ARPlaneAnchor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ARPlaneAnchor* New() const final {
    return CreateMaybeMessage<ARPlaneAnchor>(nullptr);
  }

  ARPlaneAnchor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ARPlaneAnchor>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ARPlaneAnchor& from);
  void MergeFrom(const ARPlaneAnchor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ARPlaneAnchor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.ARPlaneAnchor";
  }
  protected:
  explicit ARPlaneAnchor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ARPlaneAnchor_PlaneVector PlaneVector;

  typedef ARPlaneAnchor_Alignment Alignment;
  static constexpr Alignment UNDEFINED =
    ARPlaneAnchor_Alignment_UNDEFINED;
  static constexpr Alignment HORIZONTAL =
    ARPlaneAnchor_Alignment_HORIZONTAL;
  static constexpr Alignment VERTICAL =
    ARPlaneAnchor_Alignment_VERTICAL;
  static inline bool Alignment_IsValid(int value) {
    return ARPlaneAnchor_Alignment_IsValid(value);
  }
  static constexpr Alignment Alignment_MIN =
    ARPlaneAnchor_Alignment_Alignment_MIN;
  static constexpr Alignment Alignment_MAX =
    ARPlaneAnchor_Alignment_Alignment_MAX;
  static constexpr int Alignment_ARRAYSIZE =
    ARPlaneAnchor_Alignment_Alignment_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Alignment_descriptor() {
    return ARPlaneAnchor_Alignment_descriptor();
  }
  template<typename T>
  static inline const std::string& Alignment_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Alignment>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Alignment_Name.");
    return ARPlaneAnchor_Alignment_Name(enum_t_value);
  }
  static inline bool Alignment_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Alignment* value) {
    return ARPlaneAnchor_Alignment_Parse(name, value);
  }

  typedef ARPlaneAnchor_PlaneClassification PlaneClassification;
  static constexpr PlaneClassification NONE =
    ARPlaneAnchor_PlaneClassification_NONE;
  static constexpr PlaneClassification WALL =
    ARPlaneAnchor_PlaneClassification_WALL;
  static constexpr PlaneClassification FLOOR =
    ARPlaneAnchor_PlaneClassification_FLOOR;
  static constexpr PlaneClassification CEILING =
    ARPlaneAnchor_PlaneClassification_CEILING;
  static constexpr PlaneClassification TABLE =
    ARPlaneAnchor_PlaneClassification_TABLE;
  static constexpr PlaneClassification SEAT =
    ARPlaneAnchor_PlaneClassification_SEAT;
  static inline bool PlaneClassification_IsValid(int value) {
    return ARPlaneAnchor_PlaneClassification_IsValid(value);
  }
  static constexpr PlaneClassification PlaneClassification_MIN =
    ARPlaneAnchor_PlaneClassification_PlaneClassification_MIN;
  static constexpr PlaneClassification PlaneClassification_MAX =
    ARPlaneAnchor_PlaneClassification_PlaneClassification_MAX;
  static constexpr int PlaneClassification_ARRAYSIZE =
    ARPlaneAnchor_PlaneClassification_PlaneClassification_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PlaneClassification_descriptor() {
    return ARPlaneAnchor_PlaneClassification_descriptor();
  }
  template<typename T>
  static inline const std::string& PlaneClassification_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PlaneClassification>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PlaneClassification_Name.");
    return ARPlaneAnchor_PlaneClassification_Name(enum_t_value);
  }
  static inline bool PlaneClassification_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PlaneClassification* value) {
    return ARPlaneAnchor_PlaneClassification_Parse(name, value);
  }

  typedef ARPlaneAnchor_PlaneClassificationStatus PlaneClassificationStatus;
  static constexpr PlaneClassificationStatus UNKNOWN =
    ARPlaneAnchor_PlaneClassificationStatus_UNKNOWN;
  static constexpr PlaneClassificationStatus UNAVAILABLE =
    ARPlaneAnchor_PlaneClassificationStatus_UNAVAILABLE;
  static constexpr PlaneClassificationStatus UNDETERMINED =
    ARPlaneAnchor_PlaneClassificationStatus_UNDETERMINED;
  static constexpr PlaneClassificationStatus KNOWN =
    ARPlaneAnchor_PlaneClassificationStatus_KNOWN;
  static inline bool PlaneClassificationStatus_IsValid(int value) {
    return ARPlaneAnchor_PlaneClassificationStatus_IsValid(value);
  }
  static constexpr PlaneClassificationStatus PlaneClassificationStatus_MIN =
    ARPlaneAnchor_PlaneClassificationStatus_PlaneClassificationStatus_MIN;
  static constexpr PlaneClassificationStatus PlaneClassificationStatus_MAX =
    ARPlaneAnchor_PlaneClassificationStatus_PlaneClassificationStatus_MAX;
  static constexpr int PlaneClassificationStatus_ARRAYSIZE =
    ARPlaneAnchor_PlaneClassificationStatus_PlaneClassificationStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PlaneClassificationStatus_descriptor() {
    return ARPlaneAnchor_PlaneClassificationStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& PlaneClassificationStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PlaneClassificationStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PlaneClassificationStatus_Name.");
    return ARPlaneAnchor_PlaneClassificationStatus_Name(enum_t_value);
  }
  static inline bool PlaneClassificationStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PlaneClassificationStatus* value) {
    return ARPlaneAnchor_PlaneClassificationStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTransformFieldNumber = 2,
    kIdentifierFieldNumber = 1,
    kGeometryFieldNumber = 4,
    kCenterFieldNumber = 5,
    kExtentFieldNumber = 6,
    kAlignmentFieldNumber = 3,
    kClassificationSupportedFieldNumber = 7,
    kClassificationFieldNumber = 8,
    kClassificationStatusFieldNumber = 9,
  };
  // repeated float transform = 2;
  int transform_size() const;
  private:
  int _internal_transform_size() const;
  public:
  void clear_transform();
  private:
  float _internal_transform(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_transform() const;
  void _internal_add_transform(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_transform();
  public:
  float transform(int index) const;
  void set_transform(int index, float value);
  void add_transform(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      transform() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_transform();

  // optional string identifier = 1;
  bool has_identifier() const;
  private:
  bool _internal_has_identifier() const;
  public:
  void clear_identifier();
  const std::string& identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identifier();
  std::string* release_identifier();
  void set_allocated_identifier(std::string* identifier);
  private:
  const std::string& _internal_identifier() const;
  void _internal_set_identifier(const std::string& value);
  std::string* _internal_mutable_identifier();
  public:

  // optional .mediapipe.ARPlaneGeometry geometry = 4;
  bool has_geometry() const;
  private:
  bool _internal_has_geometry() const;
  public:
  void clear_geometry();
  const ::mediapipe::ARPlaneGeometry& geometry() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::mediapipe::ARPlaneGeometry* release_geometry();
  ::mediapipe::ARPlaneGeometry* mutable_geometry();
  void set_allocated_geometry(::mediapipe::ARPlaneGeometry* geometry);
  private:
  const ::mediapipe::ARPlaneGeometry& _internal_geometry() const;
  ::mediapipe::ARPlaneGeometry* _internal_mutable_geometry();
  public:
  void unsafe_arena_set_allocated_geometry(
      ::mediapipe::ARPlaneGeometry* geometry);
  ::mediapipe::ARPlaneGeometry* unsafe_arena_release_geometry();

  // optional .mediapipe.ARPlaneAnchor.PlaneVector center = 5;
  bool has_center() const;
  private:
  bool _internal_has_center() const;
  public:
  void clear_center();
  const ::mediapipe::ARPlaneAnchor_PlaneVector& center() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::mediapipe::ARPlaneAnchor_PlaneVector* release_center();
  ::mediapipe::ARPlaneAnchor_PlaneVector* mutable_center();
  void set_allocated_center(::mediapipe::ARPlaneAnchor_PlaneVector* center);
  private:
  const ::mediapipe::ARPlaneAnchor_PlaneVector& _internal_center() const;
  ::mediapipe::ARPlaneAnchor_PlaneVector* _internal_mutable_center();
  public:
  void unsafe_arena_set_allocated_center(
      ::mediapipe::ARPlaneAnchor_PlaneVector* center);
  ::mediapipe::ARPlaneAnchor_PlaneVector* unsafe_arena_release_center();

  // optional .mediapipe.ARPlaneAnchor.PlaneVector extent = 6;
  bool has_extent() const;
  private:
  bool _internal_has_extent() const;
  public:
  void clear_extent();
  const ::mediapipe::ARPlaneAnchor_PlaneVector& extent() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::mediapipe::ARPlaneAnchor_PlaneVector* release_extent();
  ::mediapipe::ARPlaneAnchor_PlaneVector* mutable_extent();
  void set_allocated_extent(::mediapipe::ARPlaneAnchor_PlaneVector* extent);
  private:
  const ::mediapipe::ARPlaneAnchor_PlaneVector& _internal_extent() const;
  ::mediapipe::ARPlaneAnchor_PlaneVector* _internal_mutable_extent();
  public:
  void unsafe_arena_set_allocated_extent(
      ::mediapipe::ARPlaneAnchor_PlaneVector* extent);
  ::mediapipe::ARPlaneAnchor_PlaneVector* unsafe_arena_release_extent();

  // optional .mediapipe.ARPlaneAnchor.Alignment alignment = 3;
  bool has_alignment() const;
  private:
  bool _internal_has_alignment() const;
  public:
  void clear_alignment();
  ::mediapipe::ARPlaneAnchor_Alignment alignment() const;
  void set_alignment(::mediapipe::ARPlaneAnchor_Alignment value);
  private:
  ::mediapipe::ARPlaneAnchor_Alignment _internal_alignment() const;
  void _internal_set_alignment(::mediapipe::ARPlaneAnchor_Alignment value);
  public:

  // optional bool classification_supported = 7;
  bool has_classification_supported() const;
  private:
  bool _internal_has_classification_supported() const;
  public:
  void clear_classification_supported();
  bool classification_supported() const;
  void set_classification_supported(bool value);
  private:
  bool _internal_classification_supported() const;
  void _internal_set_classification_supported(bool value);
  public:

  // optional .mediapipe.ARPlaneAnchor.PlaneClassification classification = 8;
  bool has_classification() const;
  private:
  bool _internal_has_classification() const;
  public:
  void clear_classification();
  ::mediapipe::ARPlaneAnchor_PlaneClassification classification() const;
  void set_classification(::mediapipe::ARPlaneAnchor_PlaneClassification value);
  private:
  ::mediapipe::ARPlaneAnchor_PlaneClassification _internal_classification() const;
  void _internal_set_classification(::mediapipe::ARPlaneAnchor_PlaneClassification value);
  public:

  // optional .mediapipe.ARPlaneAnchor.PlaneClassificationStatus classification_status = 9;
  bool has_classification_status() const;
  private:
  bool _internal_has_classification_status() const;
  public:
  void clear_classification_status();
  ::mediapipe::ARPlaneAnchor_PlaneClassificationStatus classification_status() const;
  void set_classification_status(::mediapipe::ARPlaneAnchor_PlaneClassificationStatus value);
  private:
  ::mediapipe::ARPlaneAnchor_PlaneClassificationStatus _internal_classification_status() const;
  void _internal_set_classification_status(::mediapipe::ARPlaneAnchor_PlaneClassificationStatus value);
  public:

  // @@protoc_insertion_point(class_scope:mediapipe.ARPlaneAnchor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > transform_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_;
  ::mediapipe::ARPlaneGeometry* geometry_;
  ::mediapipe::ARPlaneAnchor_PlaneVector* center_;
  ::mediapipe::ARPlaneAnchor_PlaneVector* extent_;
  int alignment_;
  bool classification_supported_;
  int classification_;
  int classification_status_;
  friend struct ::TableStruct_mediapipe_2fmodules_2fobjectron_2fcalculators_2fa_5fr_5fcapture_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class ARPointCloud_Point PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.ARPointCloud.Point) */ {
 public:
  inline ARPointCloud_Point() : ARPointCloud_Point(nullptr) {}
  ~ARPointCloud_Point() override;
  explicit constexpr ARPointCloud_Point(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ARPointCloud_Point(const ARPointCloud_Point& from);
  ARPointCloud_Point(ARPointCloud_Point&& from) noexcept
    : ARPointCloud_Point() {
    *this = ::std::move(from);
  }

  inline ARPointCloud_Point& operator=(const ARPointCloud_Point& from) {
    CopyFrom(from);
    return *this;
  }
  inline ARPointCloud_Point& operator=(ARPointCloud_Point&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ARPointCloud_Point& default_instance() {
    return *internal_default_instance();
  }
  static inline const ARPointCloud_Point* internal_default_instance() {
    return reinterpret_cast<const ARPointCloud_Point*>(
               &_ARPointCloud_Point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ARPointCloud_Point& a, ARPointCloud_Point& b) {
    a.Swap(&b);
  }
  inline void Swap(ARPointCloud_Point* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ARPointCloud_Point* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ARPointCloud_Point* New() const final {
    return CreateMaybeMessage<ARPointCloud_Point>(nullptr);
  }

  ARPointCloud_Point* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ARPointCloud_Point>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ARPointCloud_Point& from);
  void MergeFrom(const ARPointCloud_Point& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ARPointCloud_Point* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.ARPointCloud.Point";
  }
  protected:
  explicit ARPointCloud_Point(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // optional float x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // optional float y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // optional float z = 3;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:mediapipe.ARPointCloud.Point)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  float z_;
  friend struct ::TableStruct_mediapipe_2fmodules_2fobjectron_2fcalculators_2fa_5fr_5fcapture_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class ARPointCloud PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.ARPointCloud) */ {
 public:
  inline ARPointCloud() : ARPointCloud(nullptr) {}
  ~ARPointCloud() override;
  explicit constexpr ARPointCloud(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ARPointCloud(const ARPointCloud& from);
  ARPointCloud(ARPointCloud&& from) noexcept
    : ARPointCloud() {
    *this = ::std::move(from);
  }

  inline ARPointCloud& operator=(const ARPointCloud& from) {
    CopyFrom(from);
    return *this;
  }
  inline ARPointCloud& operator=(ARPointCloud&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ARPointCloud& default_instance() {
    return *internal_default_instance();
  }
  static inline const ARPointCloud* internal_default_instance() {
    return reinterpret_cast<const ARPointCloud*>(
               &_ARPointCloud_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ARPointCloud& a, ARPointCloud& b) {
    a.Swap(&b);
  }
  inline void Swap(ARPointCloud* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ARPointCloud* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ARPointCloud* New() const final {
    return CreateMaybeMessage<ARPointCloud>(nullptr);
  }

  ARPointCloud* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ARPointCloud>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ARPointCloud& from);
  void MergeFrom(const ARPointCloud& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ARPointCloud* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.ARPointCloud";
  }
  protected:
  explicit ARPointCloud(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ARPointCloud_Point Point;

  // accessors -------------------------------------------------------

  enum : int {
    kPointFieldNumber = 2,
    kIdentifierFieldNumber = 3,
    kCountFieldNumber = 1,
  };
  // repeated .mediapipe.ARPointCloud.Point point = 2;
  int point_size() const;
  private:
  int _internal_point_size() const;
  public:
  void clear_point();
  ::mediapipe::ARPointCloud_Point* mutable_point(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARPointCloud_Point >*
      mutable_point();
  private:
  const ::mediapipe::ARPointCloud_Point& _internal_point(int index) const;
  ::mediapipe::ARPointCloud_Point* _internal_add_point();
  public:
  const ::mediapipe::ARPointCloud_Point& point(int index) const;
  ::mediapipe::ARPointCloud_Point* add_point();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARPointCloud_Point >&
      point() const;

  // repeated int64 identifier = 3 [packed = true];
  int identifier_size() const;
  private:
  int _internal_identifier_size() const;
  public:
  void clear_identifier();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_identifier(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_identifier() const;
  void _internal_add_identifier(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_identifier();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 identifier(int index) const;
  void set_identifier(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_identifier(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      identifier() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_identifier();

  // optional int32 count = 1;
  bool has_count() const;
  private:
  bool _internal_has_count() const;
  public:
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::int32 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_count() const;
  void _internal_set_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:mediapipe.ARPointCloud)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARPointCloud_Point > point_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > identifier_;
  mutable std::atomic<int> _identifier_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 count_;
  friend struct ::TableStruct_mediapipe_2fmodules_2fobjectron_2fcalculators_2fa_5fr_5fcapture_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class ARFrame PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.ARFrame) */ {
 public:
  inline ARFrame() : ARFrame(nullptr) {}
  ~ARFrame() override;
  explicit constexpr ARFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ARFrame(const ARFrame& from);
  ARFrame(ARFrame&& from) noexcept
    : ARFrame() {
    *this = ::std::move(from);
  }

  inline ARFrame& operator=(const ARFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline ARFrame& operator=(ARFrame&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ARFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const ARFrame* internal_default_instance() {
    return reinterpret_cast<const ARFrame*>(
               &_ARFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ARFrame& a, ARFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(ARFrame* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ARFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ARFrame* New() const final {
    return CreateMaybeMessage<ARFrame>(nullptr);
  }

  ARFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ARFrame>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ARFrame& from);
  void MergeFrom(const ARFrame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ARFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.ARFrame";
  }
  protected:
  explicit ARFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlaneAnchorFieldNumber = 7,
    kDepthDataFieldNumber = 2,
    kCameraFieldNumber = 4,
    kLightEstimateFieldNumber = 5,
    kFaceAnchorFieldNumber = 6,
    kRawFeaturePointsFieldNumber = 8,
    kTimestampFieldNumber = 1,
    kDepthDataTimestampFieldNumber = 3,
  };
  // repeated .mediapipe.ARPlaneAnchor plane_anchor = 7;
  int plane_anchor_size() const;
  private:
  int _internal_plane_anchor_size() const;
  public:
  void clear_plane_anchor();
  ::mediapipe::ARPlaneAnchor* mutable_plane_anchor(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARPlaneAnchor >*
      mutable_plane_anchor();
  private:
  const ::mediapipe::ARPlaneAnchor& _internal_plane_anchor(int index) const;
  ::mediapipe::ARPlaneAnchor* _internal_add_plane_anchor();
  public:
  const ::mediapipe::ARPlaneAnchor& plane_anchor(int index) const;
  ::mediapipe::ARPlaneAnchor* add_plane_anchor();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARPlaneAnchor >&
      plane_anchor() const;

  // optional .mediapipe.AVDepthData depth_data = 2;
  bool has_depth_data() const;
  private:
  bool _internal_has_depth_data() const;
  public:
  void clear_depth_data();
  const ::mediapipe::AVDepthData& depth_data() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::mediapipe::AVDepthData* release_depth_data();
  ::mediapipe::AVDepthData* mutable_depth_data();
  void set_allocated_depth_data(::mediapipe::AVDepthData* depth_data);
  private:
  const ::mediapipe::AVDepthData& _internal_depth_data() const;
  ::mediapipe::AVDepthData* _internal_mutable_depth_data();
  public:
  void unsafe_arena_set_allocated_depth_data(
      ::mediapipe::AVDepthData* depth_data);
  ::mediapipe::AVDepthData* unsafe_arena_release_depth_data();

  // optional .mediapipe.ARCamera camera = 4;
  bool has_camera() const;
  private:
  bool _internal_has_camera() const;
  public:
  void clear_camera();
  const ::mediapipe::ARCamera& camera() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::mediapipe::ARCamera* release_camera();
  ::mediapipe::ARCamera* mutable_camera();
  void set_allocated_camera(::mediapipe::ARCamera* camera);
  private:
  const ::mediapipe::ARCamera& _internal_camera() const;
  ::mediapipe::ARCamera* _internal_mutable_camera();
  public:
  void unsafe_arena_set_allocated_camera(
      ::mediapipe::ARCamera* camera);
  ::mediapipe::ARCamera* unsafe_arena_release_camera();

  // optional .mediapipe.ARLightEstimate light_estimate = 5;
  bool has_light_estimate() const;
  private:
  bool _internal_has_light_estimate() const;
  public:
  void clear_light_estimate();
  const ::mediapipe::ARLightEstimate& light_estimate() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::mediapipe::ARLightEstimate* release_light_estimate();
  ::mediapipe::ARLightEstimate* mutable_light_estimate();
  void set_allocated_light_estimate(::mediapipe::ARLightEstimate* light_estimate);
  private:
  const ::mediapipe::ARLightEstimate& _internal_light_estimate() const;
  ::mediapipe::ARLightEstimate* _internal_mutable_light_estimate();
  public:
  void unsafe_arena_set_allocated_light_estimate(
      ::mediapipe::ARLightEstimate* light_estimate);
  ::mediapipe::ARLightEstimate* unsafe_arena_release_light_estimate();

  // optional .mediapipe.ARFaceAnchor face_anchor = 6;
  bool has_face_anchor() const;
  private:
  bool _internal_has_face_anchor() const;
  public:
  void clear_face_anchor();
  const ::mediapipe::ARFaceAnchor& face_anchor() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::mediapipe::ARFaceAnchor* release_face_anchor();
  ::mediapipe::ARFaceAnchor* mutable_face_anchor();
  void set_allocated_face_anchor(::mediapipe::ARFaceAnchor* face_anchor);
  private:
  const ::mediapipe::ARFaceAnchor& _internal_face_anchor() const;
  ::mediapipe::ARFaceAnchor* _internal_mutable_face_anchor();
  public:
  void unsafe_arena_set_allocated_face_anchor(
      ::mediapipe::ARFaceAnchor* face_anchor);
  ::mediapipe::ARFaceAnchor* unsafe_arena_release_face_anchor();

  // optional .mediapipe.ARPointCloud raw_feature_points = 8;
  bool has_raw_feature_points() const;
  private:
  bool _internal_has_raw_feature_points() const;
  public:
  void clear_raw_feature_points();
  const ::mediapipe::ARPointCloud& raw_feature_points() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::mediapipe::ARPointCloud* release_raw_feature_points();
  ::mediapipe::ARPointCloud* mutable_raw_feature_points();
  void set_allocated_raw_feature_points(::mediapipe::ARPointCloud* raw_feature_points);
  private:
  const ::mediapipe::ARPointCloud& _internal_raw_feature_points() const;
  ::mediapipe::ARPointCloud* _internal_mutable_raw_feature_points();
  public:
  void unsafe_arena_set_allocated_raw_feature_points(
      ::mediapipe::ARPointCloud* raw_feature_points);
  ::mediapipe::ARPointCloud* unsafe_arena_release_raw_feature_points();

  // optional double timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  double timestamp() const;
  void set_timestamp(double value);
  private:
  double _internal_timestamp() const;
  void _internal_set_timestamp(double value);
  public:

  // optional double depth_data_timestamp = 3;
  bool has_depth_data_timestamp() const;
  private:
  bool _internal_has_depth_data_timestamp() const;
  public:
  void clear_depth_data_timestamp();
  double depth_data_timestamp() const;
  void set_depth_data_timestamp(double value);
  private:
  double _internal_depth_data_timestamp() const;
  void _internal_set_depth_data_timestamp(double value);
  public:

  // @@protoc_insertion_point(class_scope:mediapipe.ARFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARPlaneAnchor > plane_anchor_;
  ::mediapipe::AVDepthData* depth_data_;
  ::mediapipe::ARCamera* camera_;
  ::mediapipe::ARLightEstimate* light_estimate_;
  ::mediapipe::ARFaceAnchor* face_anchor_;
  ::mediapipe::ARPointCloud* raw_feature_points_;
  double timestamp_;
  double depth_data_timestamp_;
  friend struct ::TableStruct_mediapipe_2fmodules_2fobjectron_2fcalculators_2fa_5fr_5fcapture_5fmetadata_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AVCameraCalibrationData

// repeated float intrinsic_matrix = 1 [packed = true];
inline int AVCameraCalibrationData::_internal_intrinsic_matrix_size() const {
  return intrinsic_matrix_.size();
}
inline int AVCameraCalibrationData::intrinsic_matrix_size() const {
  return _internal_intrinsic_matrix_size();
}
inline void AVCameraCalibrationData::clear_intrinsic_matrix() {
  intrinsic_matrix_.Clear();
}
inline float AVCameraCalibrationData::_internal_intrinsic_matrix(int index) const {
  return intrinsic_matrix_.Get(index);
}
inline float AVCameraCalibrationData::intrinsic_matrix(int index) const {
  // @@protoc_insertion_point(field_get:mediapipe.AVCameraCalibrationData.intrinsic_matrix)
  return _internal_intrinsic_matrix(index);
}
inline void AVCameraCalibrationData::set_intrinsic_matrix(int index, float value) {
  intrinsic_matrix_.Set(index, value);
  // @@protoc_insertion_point(field_set:mediapipe.AVCameraCalibrationData.intrinsic_matrix)
}
inline void AVCameraCalibrationData::_internal_add_intrinsic_matrix(float value) {
  intrinsic_matrix_.Add(value);
}
inline void AVCameraCalibrationData::add_intrinsic_matrix(float value) {
  _internal_add_intrinsic_matrix(value);
  // @@protoc_insertion_point(field_add:mediapipe.AVCameraCalibrationData.intrinsic_matrix)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
AVCameraCalibrationData::_internal_intrinsic_matrix() const {
  return intrinsic_matrix_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
AVCameraCalibrationData::intrinsic_matrix() const {
  // @@protoc_insertion_point(field_list:mediapipe.AVCameraCalibrationData.intrinsic_matrix)
  return _internal_intrinsic_matrix();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
AVCameraCalibrationData::_internal_mutable_intrinsic_matrix() {
  return &intrinsic_matrix_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
AVCameraCalibrationData::mutable_intrinsic_matrix() {
  // @@protoc_insertion_point(field_mutable_list:mediapipe.AVCameraCalibrationData.intrinsic_matrix)
  return _internal_mutable_intrinsic_matrix();
}

// optional float intrinsic_matrix_reference_dimension_width = 2;
inline bool AVCameraCalibrationData::_internal_has_intrinsic_matrix_reference_dimension_width() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AVCameraCalibrationData::has_intrinsic_matrix_reference_dimension_width() const {
  return _internal_has_intrinsic_matrix_reference_dimension_width();
}
inline void AVCameraCalibrationData::clear_intrinsic_matrix_reference_dimension_width() {
  intrinsic_matrix_reference_dimension_width_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float AVCameraCalibrationData::_internal_intrinsic_matrix_reference_dimension_width() const {
  return intrinsic_matrix_reference_dimension_width_;
}
inline float AVCameraCalibrationData::intrinsic_matrix_reference_dimension_width() const {
  // @@protoc_insertion_point(field_get:mediapipe.AVCameraCalibrationData.intrinsic_matrix_reference_dimension_width)
  return _internal_intrinsic_matrix_reference_dimension_width();
}
inline void AVCameraCalibrationData::_internal_set_intrinsic_matrix_reference_dimension_width(float value) {
  _has_bits_[0] |= 0x00000001u;
  intrinsic_matrix_reference_dimension_width_ = value;
}
inline void AVCameraCalibrationData::set_intrinsic_matrix_reference_dimension_width(float value) {
  _internal_set_intrinsic_matrix_reference_dimension_width(value);
  // @@protoc_insertion_point(field_set:mediapipe.AVCameraCalibrationData.intrinsic_matrix_reference_dimension_width)
}

// optional float intrinsic_matrix_reference_dimension_height = 3;
inline bool AVCameraCalibrationData::_internal_has_intrinsic_matrix_reference_dimension_height() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AVCameraCalibrationData::has_intrinsic_matrix_reference_dimension_height() const {
  return _internal_has_intrinsic_matrix_reference_dimension_height();
}
inline void AVCameraCalibrationData::clear_intrinsic_matrix_reference_dimension_height() {
  intrinsic_matrix_reference_dimension_height_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float AVCameraCalibrationData::_internal_intrinsic_matrix_reference_dimension_height() const {
  return intrinsic_matrix_reference_dimension_height_;
}
inline float AVCameraCalibrationData::intrinsic_matrix_reference_dimension_height() const {
  // @@protoc_insertion_point(field_get:mediapipe.AVCameraCalibrationData.intrinsic_matrix_reference_dimension_height)
  return _internal_intrinsic_matrix_reference_dimension_height();
}
inline void AVCameraCalibrationData::_internal_set_intrinsic_matrix_reference_dimension_height(float value) {
  _has_bits_[0] |= 0x00000002u;
  intrinsic_matrix_reference_dimension_height_ = value;
}
inline void AVCameraCalibrationData::set_intrinsic_matrix_reference_dimension_height(float value) {
  _internal_set_intrinsic_matrix_reference_dimension_height(value);
  // @@protoc_insertion_point(field_set:mediapipe.AVCameraCalibrationData.intrinsic_matrix_reference_dimension_height)
}

// repeated float extrinsic_matrix = 4 [packed = true];
inline int AVCameraCalibrationData::_internal_extrinsic_matrix_size() const {
  return extrinsic_matrix_.size();
}
inline int AVCameraCalibrationData::extrinsic_matrix_size() const {
  return _internal_extrinsic_matrix_size();
}
inline void AVCameraCalibrationData::clear_extrinsic_matrix() {
  extrinsic_matrix_.Clear();
}
inline float AVCameraCalibrationData::_internal_extrinsic_matrix(int index) const {
  return extrinsic_matrix_.Get(index);
}
inline float AVCameraCalibrationData::extrinsic_matrix(int index) const {
  // @@protoc_insertion_point(field_get:mediapipe.AVCameraCalibrationData.extrinsic_matrix)
  return _internal_extrinsic_matrix(index);
}
inline void AVCameraCalibrationData::set_extrinsic_matrix(int index, float value) {
  extrinsic_matrix_.Set(index, value);
  // @@protoc_insertion_point(field_set:mediapipe.AVCameraCalibrationData.extrinsic_matrix)
}
inline void AVCameraCalibrationData::_internal_add_extrinsic_matrix(float value) {
  extrinsic_matrix_.Add(value);
}
inline void AVCameraCalibrationData::add_extrinsic_matrix(float value) {
  _internal_add_extrinsic_matrix(value);
  // @@protoc_insertion_point(field_add:mediapipe.AVCameraCalibrationData.extrinsic_matrix)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
AVCameraCalibrationData::_internal_extrinsic_matrix() const {
  return extrinsic_matrix_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
AVCameraCalibrationData::extrinsic_matrix() const {
  // @@protoc_insertion_point(field_list:mediapipe.AVCameraCalibrationData.extrinsic_matrix)
  return _internal_extrinsic_matrix();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
AVCameraCalibrationData::_internal_mutable_extrinsic_matrix() {
  return &extrinsic_matrix_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
AVCameraCalibrationData::mutable_extrinsic_matrix() {
  // @@protoc_insertion_point(field_mutable_list:mediapipe.AVCameraCalibrationData.extrinsic_matrix)
  return _internal_mutable_extrinsic_matrix();
}

// optional float pixel_size = 5;
inline bool AVCameraCalibrationData::_internal_has_pixel_size() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AVCameraCalibrationData::has_pixel_size() const {
  return _internal_has_pixel_size();
}
inline void AVCameraCalibrationData::clear_pixel_size() {
  pixel_size_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float AVCameraCalibrationData::_internal_pixel_size() const {
  return pixel_size_;
}
inline float AVCameraCalibrationData::pixel_size() const {
  // @@protoc_insertion_point(field_get:mediapipe.AVCameraCalibrationData.pixel_size)
  return _internal_pixel_size();
}
inline void AVCameraCalibrationData::_internal_set_pixel_size(float value) {
  _has_bits_[0] |= 0x00000004u;
  pixel_size_ = value;
}
inline void AVCameraCalibrationData::set_pixel_size(float value) {
  _internal_set_pixel_size(value);
  // @@protoc_insertion_point(field_set:mediapipe.AVCameraCalibrationData.pixel_size)
}

// repeated float lens_distortion_lookup_values = 6 [packed = true];
inline int AVCameraCalibrationData::_internal_lens_distortion_lookup_values_size() const {
  return lens_distortion_lookup_values_.size();
}
inline int AVCameraCalibrationData::lens_distortion_lookup_values_size() const {
  return _internal_lens_distortion_lookup_values_size();
}
inline void AVCameraCalibrationData::clear_lens_distortion_lookup_values() {
  lens_distortion_lookup_values_.Clear();
}
inline float AVCameraCalibrationData::_internal_lens_distortion_lookup_values(int index) const {
  return lens_distortion_lookup_values_.Get(index);
}
inline float AVCameraCalibrationData::lens_distortion_lookup_values(int index) const {
  // @@protoc_insertion_point(field_get:mediapipe.AVCameraCalibrationData.lens_distortion_lookup_values)
  return _internal_lens_distortion_lookup_values(index);
}
inline void AVCameraCalibrationData::set_lens_distortion_lookup_values(int index, float value) {
  lens_distortion_lookup_values_.Set(index, value);
  // @@protoc_insertion_point(field_set:mediapipe.AVCameraCalibrationData.lens_distortion_lookup_values)
}
inline void AVCameraCalibrationData::_internal_add_lens_distortion_lookup_values(float value) {
  lens_distortion_lookup_values_.Add(value);
}
inline void AVCameraCalibrationData::add_lens_distortion_lookup_values(float value) {
  _internal_add_lens_distortion_lookup_values(value);
  // @@protoc_insertion_point(field_add:mediapipe.AVCameraCalibrationData.lens_distortion_lookup_values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
AVCameraCalibrationData::_internal_lens_distortion_lookup_values() const {
  return lens_distortion_lookup_values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
AVCameraCalibrationData::lens_distortion_lookup_values() const {
  // @@protoc_insertion_point(field_list:mediapipe.AVCameraCalibrationData.lens_distortion_lookup_values)
  return _internal_lens_distortion_lookup_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
AVCameraCalibrationData::_internal_mutable_lens_distortion_lookup_values() {
  return &lens_distortion_lookup_values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
AVCameraCalibrationData::mutable_lens_distortion_lookup_values() {
  // @@protoc_insertion_point(field_mutable_list:mediapipe.AVCameraCalibrationData.lens_distortion_lookup_values)
  return _internal_mutable_lens_distortion_lookup_values();
}

// repeated float inverse_lens_distortion_lookup_values = 7 [packed = true];
inline int AVCameraCalibrationData::_internal_inverse_lens_distortion_lookup_values_size() const {
  return inverse_lens_distortion_lookup_values_.size();
}
inline int AVCameraCalibrationData::inverse_lens_distortion_lookup_values_size() const {
  return _internal_inverse_lens_distortion_lookup_values_size();
}
inline void AVCameraCalibrationData::clear_inverse_lens_distortion_lookup_values() {
  inverse_lens_distortion_lookup_values_.Clear();
}
inline float AVCameraCalibrationData::_internal_inverse_lens_distortion_lookup_values(int index) const {
  return inverse_lens_distortion_lookup_values_.Get(index);
}
inline float AVCameraCalibrationData::inverse_lens_distortion_lookup_values(int index) const {
  // @@protoc_insertion_point(field_get:mediapipe.AVCameraCalibrationData.inverse_lens_distortion_lookup_values)
  return _internal_inverse_lens_distortion_lookup_values(index);
}
inline void AVCameraCalibrationData::set_inverse_lens_distortion_lookup_values(int index, float value) {
  inverse_lens_distortion_lookup_values_.Set(index, value);
  // @@protoc_insertion_point(field_set:mediapipe.AVCameraCalibrationData.inverse_lens_distortion_lookup_values)
}
inline void AVCameraCalibrationData::_internal_add_inverse_lens_distortion_lookup_values(float value) {
  inverse_lens_distortion_lookup_values_.Add(value);
}
inline void AVCameraCalibrationData::add_inverse_lens_distortion_lookup_values(float value) {
  _internal_add_inverse_lens_distortion_lookup_values(value);
  // @@protoc_insertion_point(field_add:mediapipe.AVCameraCalibrationData.inverse_lens_distortion_lookup_values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
AVCameraCalibrationData::_internal_inverse_lens_distortion_lookup_values() const {
  return inverse_lens_distortion_lookup_values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
AVCameraCalibrationData::inverse_lens_distortion_lookup_values() const {
  // @@protoc_insertion_point(field_list:mediapipe.AVCameraCalibrationData.inverse_lens_distortion_lookup_values)
  return _internal_inverse_lens_distortion_lookup_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
AVCameraCalibrationData::_internal_mutable_inverse_lens_distortion_lookup_values() {
  return &inverse_lens_distortion_lookup_values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
AVCameraCalibrationData::mutable_inverse_lens_distortion_lookup_values() {
  // @@protoc_insertion_point(field_mutable_list:mediapipe.AVCameraCalibrationData.inverse_lens_distortion_lookup_values)
  return _internal_mutable_inverse_lens_distortion_lookup_values();
}

// optional float lens_distortion_center_x = 8;
inline bool AVCameraCalibrationData::_internal_has_lens_distortion_center_x() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AVCameraCalibrationData::has_lens_distortion_center_x() const {
  return _internal_has_lens_distortion_center_x();
}
inline void AVCameraCalibrationData::clear_lens_distortion_center_x() {
  lens_distortion_center_x_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float AVCameraCalibrationData::_internal_lens_distortion_center_x() const {
  return lens_distortion_center_x_;
}
inline float AVCameraCalibrationData::lens_distortion_center_x() const {
  // @@protoc_insertion_point(field_get:mediapipe.AVCameraCalibrationData.lens_distortion_center_x)
  return _internal_lens_distortion_center_x();
}
inline void AVCameraCalibrationData::_internal_set_lens_distortion_center_x(float value) {
  _has_bits_[0] |= 0x00000008u;
  lens_distortion_center_x_ = value;
}
inline void AVCameraCalibrationData::set_lens_distortion_center_x(float value) {
  _internal_set_lens_distortion_center_x(value);
  // @@protoc_insertion_point(field_set:mediapipe.AVCameraCalibrationData.lens_distortion_center_x)
}

// optional float lens_distortion_center_y = 9;
inline bool AVCameraCalibrationData::_internal_has_lens_distortion_center_y() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AVCameraCalibrationData::has_lens_distortion_center_y() const {
  return _internal_has_lens_distortion_center_y();
}
inline void AVCameraCalibrationData::clear_lens_distortion_center_y() {
  lens_distortion_center_y_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float AVCameraCalibrationData::_internal_lens_distortion_center_y() const {
  return lens_distortion_center_y_;
}
inline float AVCameraCalibrationData::lens_distortion_center_y() const {
  // @@protoc_insertion_point(field_get:mediapipe.AVCameraCalibrationData.lens_distortion_center_y)
  return _internal_lens_distortion_center_y();
}
inline void AVCameraCalibrationData::_internal_set_lens_distortion_center_y(float value) {
  _has_bits_[0] |= 0x00000010u;
  lens_distortion_center_y_ = value;
}
inline void AVCameraCalibrationData::set_lens_distortion_center_y(float value) {
  _internal_set_lens_distortion_center_y(value);
  // @@protoc_insertion_point(field_set:mediapipe.AVCameraCalibrationData.lens_distortion_center_y)
}

// -------------------------------------------------------------------

// AVDepthData

// optional bytes depth_data_map = 1;
inline bool AVDepthData::_internal_has_depth_data_map() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AVDepthData::has_depth_data_map() const {
  return _internal_has_depth_data_map();
}
inline void AVDepthData::clear_depth_data_map() {
  depth_data_map_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AVDepthData::depth_data_map() const {
  // @@protoc_insertion_point(field_get:mediapipe.AVDepthData.depth_data_map)
  return _internal_depth_data_map();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void AVDepthData::set_depth_data_map(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 depth_data_map_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:mediapipe.AVDepthData.depth_data_map)
}
inline std::string* AVDepthData::mutable_depth_data_map() {
  // @@protoc_insertion_point(field_mutable:mediapipe.AVDepthData.depth_data_map)
  return _internal_mutable_depth_data_map();
}
inline const std::string& AVDepthData::_internal_depth_data_map() const {
  return depth_data_map_.Get();
}
inline void AVDepthData::_internal_set_depth_data_map(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  depth_data_map_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* AVDepthData::_internal_mutable_depth_data_map() {
  _has_bits_[0] |= 0x00000001u;
  return depth_data_map_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* AVDepthData::release_depth_data_map() {
  // @@protoc_insertion_point(field_release:mediapipe.AVDepthData.depth_data_map)
  if (!_internal_has_depth_data_map()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return depth_data_map_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AVDepthData::set_allocated_depth_data_map(std::string* depth_data_map) {
  if (depth_data_map != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  depth_data_map_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), depth_data_map,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mediapipe.AVDepthData.depth_data_map)
}

// optional string depth_data_type = 2;
inline bool AVDepthData::_internal_has_depth_data_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AVDepthData::has_depth_data_type() const {
  return _internal_has_depth_data_type();
}
inline void AVDepthData::clear_depth_data_type() {
  depth_data_type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AVDepthData::depth_data_type() const {
  // @@protoc_insertion_point(field_get:mediapipe.AVDepthData.depth_data_type)
  return _internal_depth_data_type();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void AVDepthData::set_depth_data_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 depth_data_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:mediapipe.AVDepthData.depth_data_type)
}
inline std::string* AVDepthData::mutable_depth_data_type() {
  // @@protoc_insertion_point(field_mutable:mediapipe.AVDepthData.depth_data_type)
  return _internal_mutable_depth_data_type();
}
inline const std::string& AVDepthData::_internal_depth_data_type() const {
  return depth_data_type_.Get();
}
inline void AVDepthData::_internal_set_depth_data_type(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  depth_data_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* AVDepthData::_internal_mutable_depth_data_type() {
  _has_bits_[0] |= 0x00000002u;
  return depth_data_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* AVDepthData::release_depth_data_type() {
  // @@protoc_insertion_point(field_release:mediapipe.AVDepthData.depth_data_type)
  if (!_internal_has_depth_data_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return depth_data_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AVDepthData::set_allocated_depth_data_type(std::string* depth_data_type) {
  if (depth_data_type != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  depth_data_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), depth_data_type,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mediapipe.AVDepthData.depth_data_type)
}

// optional .mediapipe.AVDepthData.Accuracy depth_data_accuracy = 3 [default = RELATIVE];
inline bool AVDepthData::_internal_has_depth_data_accuracy() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool AVDepthData::has_depth_data_accuracy() const {
  return _internal_has_depth_data_accuracy();
}
inline void AVDepthData::clear_depth_data_accuracy() {
  depth_data_accuracy_ = 1;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::mediapipe::AVDepthData_Accuracy AVDepthData::_internal_depth_data_accuracy() const {
  return static_cast< ::mediapipe::AVDepthData_Accuracy >(depth_data_accuracy_);
}
inline ::mediapipe::AVDepthData_Accuracy AVDepthData::depth_data_accuracy() const {
  // @@protoc_insertion_point(field_get:mediapipe.AVDepthData.depth_data_accuracy)
  return _internal_depth_data_accuracy();
}
inline void AVDepthData::_internal_set_depth_data_accuracy(::mediapipe::AVDepthData_Accuracy value) {
  assert(::mediapipe::AVDepthData_Accuracy_IsValid(value));
  _has_bits_[0] |= 0x00000400u;
  depth_data_accuracy_ = value;
}
inline void AVDepthData::set_depth_data_accuracy(::mediapipe::AVDepthData_Accuracy value) {
  _internal_set_depth_data_accuracy(value);
  // @@protoc_insertion_point(field_set:mediapipe.AVDepthData.depth_data_accuracy)
}

// optional bool depth_data_filtered = 4;
inline bool AVDepthData::_internal_has_depth_data_filtered() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AVDepthData::has_depth_data_filtered() const {
  return _internal_has_depth_data_filtered();
}
inline void AVDepthData::clear_depth_data_filtered() {
  depth_data_filtered_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool AVDepthData::_internal_depth_data_filtered() const {
  return depth_data_filtered_;
}
inline bool AVDepthData::depth_data_filtered() const {
  // @@protoc_insertion_point(field_get:mediapipe.AVDepthData.depth_data_filtered)
  return _internal_depth_data_filtered();
}
inline void AVDepthData::_internal_set_depth_data_filtered(bool value) {
  _has_bits_[0] |= 0x00000010u;
  depth_data_filtered_ = value;
}
inline void AVDepthData::set_depth_data_filtered(bool value) {
  _internal_set_depth_data_filtered(value);
  // @@protoc_insertion_point(field_set:mediapipe.AVDepthData.depth_data_filtered)
}

// optional .mediapipe.AVDepthData.Quality depth_data_quality = 5;
inline bool AVDepthData::_internal_has_depth_data_quality() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool AVDepthData::has_depth_data_quality() const {
  return _internal_has_depth_data_quality();
}
inline void AVDepthData::clear_depth_data_quality() {
  depth_data_quality_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::mediapipe::AVDepthData_Quality AVDepthData::_internal_depth_data_quality() const {
  return static_cast< ::mediapipe::AVDepthData_Quality >(depth_data_quality_);
}
inline ::mediapipe::AVDepthData_Quality AVDepthData::depth_data_quality() const {
  // @@protoc_insertion_point(field_get:mediapipe.AVDepthData.depth_data_quality)
  return _internal_depth_data_quality();
}
inline void AVDepthData::_internal_set_depth_data_quality(::mediapipe::AVDepthData_Quality value) {
  assert(::mediapipe::AVDepthData_Quality_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  depth_data_quality_ = value;
}
inline void AVDepthData::set_depth_data_quality(::mediapipe::AVDepthData_Quality value) {
  _internal_set_depth_data_quality(value);
  // @@protoc_insertion_point(field_set:mediapipe.AVDepthData.depth_data_quality)
}

// optional .mediapipe.AVCameraCalibrationData camera_calibration_data = 6;
inline bool AVDepthData::_internal_has_camera_calibration_data() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || camera_calibration_data_ != nullptr);
  return value;
}
inline bool AVDepthData::has_camera_calibration_data() const {
  return _internal_has_camera_calibration_data();
}
inline void AVDepthData::clear_camera_calibration_data() {
  if (camera_calibration_data_ != nullptr) camera_calibration_data_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::mediapipe::AVCameraCalibrationData& AVDepthData::_internal_camera_calibration_data() const {
  const ::mediapipe::AVCameraCalibrationData* p = camera_calibration_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::mediapipe::AVCameraCalibrationData&>(
      ::mediapipe::_AVCameraCalibrationData_default_instance_);
}
inline const ::mediapipe::AVCameraCalibrationData& AVDepthData::camera_calibration_data() const {
  // @@protoc_insertion_point(field_get:mediapipe.AVDepthData.camera_calibration_data)
  return _internal_camera_calibration_data();
}
inline void AVDepthData::unsafe_arena_set_allocated_camera_calibration_data(
    ::mediapipe::AVCameraCalibrationData* camera_calibration_data) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(camera_calibration_data_);
  }
  camera_calibration_data_ = camera_calibration_data;
  if (camera_calibration_data) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mediapipe.AVDepthData.camera_calibration_data)
}
inline ::mediapipe::AVCameraCalibrationData* AVDepthData::release_camera_calibration_data() {
  _has_bits_[0] &= ~0x00000008u;
  ::mediapipe::AVCameraCalibrationData* temp = camera_calibration_data_;
  camera_calibration_data_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mediapipe::AVCameraCalibrationData* AVDepthData::unsafe_arena_release_camera_calibration_data() {
  // @@protoc_insertion_point(field_release:mediapipe.AVDepthData.camera_calibration_data)
  _has_bits_[0] &= ~0x00000008u;
  ::mediapipe::AVCameraCalibrationData* temp = camera_calibration_data_;
  camera_calibration_data_ = nullptr;
  return temp;
}
inline ::mediapipe::AVCameraCalibrationData* AVDepthData::_internal_mutable_camera_calibration_data() {
  _has_bits_[0] |= 0x00000008u;
  if (camera_calibration_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::mediapipe::AVCameraCalibrationData>(GetArena());
    camera_calibration_data_ = p;
  }
  return camera_calibration_data_;
}
inline ::mediapipe::AVCameraCalibrationData* AVDepthData::mutable_camera_calibration_data() {
  // @@protoc_insertion_point(field_mutable:mediapipe.AVDepthData.camera_calibration_data)
  return _internal_mutable_camera_calibration_data();
}
inline void AVDepthData::set_allocated_camera_calibration_data(::mediapipe::AVCameraCalibrationData* camera_calibration_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete camera_calibration_data_;
  }
  if (camera_calibration_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(camera_calibration_data);
    if (message_arena != submessage_arena) {
      camera_calibration_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_calibration_data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  camera_calibration_data_ = camera_calibration_data;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.AVDepthData.camera_calibration_data)
}

// optional float depth_data_map_original_minimum_value = 7;
inline bool AVDepthData::_internal_has_depth_data_map_original_minimum_value() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool AVDepthData::has_depth_data_map_original_minimum_value() const {
  return _internal_has_depth_data_map_original_minimum_value();
}
inline void AVDepthData::clear_depth_data_map_original_minimum_value() {
  depth_data_map_original_minimum_value_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float AVDepthData::_internal_depth_data_map_original_minimum_value() const {
  return depth_data_map_original_minimum_value_;
}
inline float AVDepthData::depth_data_map_original_minimum_value() const {
  // @@protoc_insertion_point(field_get:mediapipe.AVDepthData.depth_data_map_original_minimum_value)
  return _internal_depth_data_map_original_minimum_value();
}
inline void AVDepthData::_internal_set_depth_data_map_original_minimum_value(float value) {
  _has_bits_[0] |= 0x00000040u;
  depth_data_map_original_minimum_value_ = value;
}
inline void AVDepthData::set_depth_data_map_original_minimum_value(float value) {
  _internal_set_depth_data_map_original_minimum_value(value);
  // @@protoc_insertion_point(field_set:mediapipe.AVDepthData.depth_data_map_original_minimum_value)
}

// optional float depth_data_map_original_maximum_value = 8;
inline bool AVDepthData::_internal_has_depth_data_map_original_maximum_value() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool AVDepthData::has_depth_data_map_original_maximum_value() const {
  return _internal_has_depth_data_map_original_maximum_value();
}
inline void AVDepthData::clear_depth_data_map_original_maximum_value() {
  depth_data_map_original_maximum_value_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float AVDepthData::_internal_depth_data_map_original_maximum_value() const {
  return depth_data_map_original_maximum_value_;
}
inline float AVDepthData::depth_data_map_original_maximum_value() const {
  // @@protoc_insertion_point(field_get:mediapipe.AVDepthData.depth_data_map_original_maximum_value)
  return _internal_depth_data_map_original_maximum_value();
}
inline void AVDepthData::_internal_set_depth_data_map_original_maximum_value(float value) {
  _has_bits_[0] |= 0x00000080u;
  depth_data_map_original_maximum_value_ = value;
}
inline void AVDepthData::set_depth_data_map_original_maximum_value(float value) {
  _internal_set_depth_data_map_original_maximum_value(value);
  // @@protoc_insertion_point(field_set:mediapipe.AVDepthData.depth_data_map_original_maximum_value)
}

// optional int32 depth_data_map_width = 9;
inline bool AVDepthData::_internal_has_depth_data_map_width() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool AVDepthData::has_depth_data_map_width() const {
  return _internal_has_depth_data_map_width();
}
inline void AVDepthData::clear_depth_data_map_width() {
  depth_data_map_width_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AVDepthData::_internal_depth_data_map_width() const {
  return depth_data_map_width_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AVDepthData::depth_data_map_width() const {
  // @@protoc_insertion_point(field_get:mediapipe.AVDepthData.depth_data_map_width)
  return _internal_depth_data_map_width();
}
inline void AVDepthData::_internal_set_depth_data_map_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000100u;
  depth_data_map_width_ = value;
}
inline void AVDepthData::set_depth_data_map_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_depth_data_map_width(value);
  // @@protoc_insertion_point(field_set:mediapipe.AVDepthData.depth_data_map_width)
}

// optional int32 depth_data_map_height = 10;
inline bool AVDepthData::_internal_has_depth_data_map_height() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool AVDepthData::has_depth_data_map_height() const {
  return _internal_has_depth_data_map_height();
}
inline void AVDepthData::clear_depth_data_map_height() {
  depth_data_map_height_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AVDepthData::_internal_depth_data_map_height() const {
  return depth_data_map_height_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AVDepthData::depth_data_map_height() const {
  // @@protoc_insertion_point(field_get:mediapipe.AVDepthData.depth_data_map_height)
  return _internal_depth_data_map_height();
}
inline void AVDepthData::_internal_set_depth_data_map_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000200u;
  depth_data_map_height_ = value;
}
inline void AVDepthData::set_depth_data_map_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_depth_data_map_height(value);
  // @@protoc_insertion_point(field_set:mediapipe.AVDepthData.depth_data_map_height)
}

// optional bytes depth_data_map_raw_values = 11;
inline bool AVDepthData::_internal_has_depth_data_map_raw_values() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AVDepthData::has_depth_data_map_raw_values() const {
  return _internal_has_depth_data_map_raw_values();
}
inline void AVDepthData::clear_depth_data_map_raw_values() {
  depth_data_map_raw_values_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AVDepthData::depth_data_map_raw_values() const {
  // @@protoc_insertion_point(field_get:mediapipe.AVDepthData.depth_data_map_raw_values)
  return _internal_depth_data_map_raw_values();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void AVDepthData::set_depth_data_map_raw_values(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 depth_data_map_raw_values_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:mediapipe.AVDepthData.depth_data_map_raw_values)
}
inline std::string* AVDepthData::mutable_depth_data_map_raw_values() {
  // @@protoc_insertion_point(field_mutable:mediapipe.AVDepthData.depth_data_map_raw_values)
  return _internal_mutable_depth_data_map_raw_values();
}
inline const std::string& AVDepthData::_internal_depth_data_map_raw_values() const {
  return depth_data_map_raw_values_.Get();
}
inline void AVDepthData::_internal_set_depth_data_map_raw_values(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  depth_data_map_raw_values_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* AVDepthData::_internal_mutable_depth_data_map_raw_values() {
  _has_bits_[0] |= 0x00000004u;
  return depth_data_map_raw_values_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* AVDepthData::release_depth_data_map_raw_values() {
  // @@protoc_insertion_point(field_release:mediapipe.AVDepthData.depth_data_map_raw_values)
  if (!_internal_has_depth_data_map_raw_values()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return depth_data_map_raw_values_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AVDepthData::set_allocated_depth_data_map_raw_values(std::string* depth_data_map_raw_values) {
  if (depth_data_map_raw_values != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  depth_data_map_raw_values_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), depth_data_map_raw_values,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mediapipe.AVDepthData.depth_data_map_raw_values)
}

// -------------------------------------------------------------------

// ARLightEstimate_DirectionVector

// optional float x = 1;
inline bool ARLightEstimate_DirectionVector::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ARLightEstimate_DirectionVector::has_x() const {
  return _internal_has_x();
}
inline void ARLightEstimate_DirectionVector::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float ARLightEstimate_DirectionVector::_internal_x() const {
  return x_;
}
inline float ARLightEstimate_DirectionVector::x() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARLightEstimate.DirectionVector.x)
  return _internal_x();
}
inline void ARLightEstimate_DirectionVector::_internal_set_x(float value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void ARLightEstimate_DirectionVector::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARLightEstimate.DirectionVector.x)
}

// optional float y = 2;
inline bool ARLightEstimate_DirectionVector::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ARLightEstimate_DirectionVector::has_y() const {
  return _internal_has_y();
}
inline void ARLightEstimate_DirectionVector::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float ARLightEstimate_DirectionVector::_internal_y() const {
  return y_;
}
inline float ARLightEstimate_DirectionVector::y() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARLightEstimate.DirectionVector.y)
  return _internal_y();
}
inline void ARLightEstimate_DirectionVector::_internal_set_y(float value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void ARLightEstimate_DirectionVector::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARLightEstimate.DirectionVector.y)
}

// optional float z = 3;
inline bool ARLightEstimate_DirectionVector::_internal_has_z() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ARLightEstimate_DirectionVector::has_z() const {
  return _internal_has_z();
}
inline void ARLightEstimate_DirectionVector::clear_z() {
  z_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float ARLightEstimate_DirectionVector::_internal_z() const {
  return z_;
}
inline float ARLightEstimate_DirectionVector::z() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARLightEstimate.DirectionVector.z)
  return _internal_z();
}
inline void ARLightEstimate_DirectionVector::_internal_set_z(float value) {
  _has_bits_[0] |= 0x00000004u;
  z_ = value;
}
inline void ARLightEstimate_DirectionVector::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARLightEstimate.DirectionVector.z)
}

// -------------------------------------------------------------------

// ARLightEstimate

// optional double ambient_intensity = 1;
inline bool ARLightEstimate::_internal_has_ambient_intensity() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ARLightEstimate::has_ambient_intensity() const {
  return _internal_has_ambient_intensity();
}
inline void ARLightEstimate::clear_ambient_intensity() {
  ambient_intensity_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double ARLightEstimate::_internal_ambient_intensity() const {
  return ambient_intensity_;
}
inline double ARLightEstimate::ambient_intensity() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARLightEstimate.ambient_intensity)
  return _internal_ambient_intensity();
}
inline void ARLightEstimate::_internal_set_ambient_intensity(double value) {
  _has_bits_[0] |= 0x00000002u;
  ambient_intensity_ = value;
}
inline void ARLightEstimate::set_ambient_intensity(double value) {
  _internal_set_ambient_intensity(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARLightEstimate.ambient_intensity)
}

// optional double ambient_color_temperature = 2;
inline bool ARLightEstimate::_internal_has_ambient_color_temperature() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ARLightEstimate::has_ambient_color_temperature() const {
  return _internal_has_ambient_color_temperature();
}
inline void ARLightEstimate::clear_ambient_color_temperature() {
  ambient_color_temperature_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double ARLightEstimate::_internal_ambient_color_temperature() const {
  return ambient_color_temperature_;
}
inline double ARLightEstimate::ambient_color_temperature() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARLightEstimate.ambient_color_temperature)
  return _internal_ambient_color_temperature();
}
inline void ARLightEstimate::_internal_set_ambient_color_temperature(double value) {
  _has_bits_[0] |= 0x00000004u;
  ambient_color_temperature_ = value;
}
inline void ARLightEstimate::set_ambient_color_temperature(double value) {
  _internal_set_ambient_color_temperature(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARLightEstimate.ambient_color_temperature)
}

// repeated float spherical_harmonics_coefficients = 3 [packed = true];
inline int ARLightEstimate::_internal_spherical_harmonics_coefficients_size() const {
  return spherical_harmonics_coefficients_.size();
}
inline int ARLightEstimate::spherical_harmonics_coefficients_size() const {
  return _internal_spherical_harmonics_coefficients_size();
}
inline void ARLightEstimate::clear_spherical_harmonics_coefficients() {
  spherical_harmonics_coefficients_.Clear();
}
inline float ARLightEstimate::_internal_spherical_harmonics_coefficients(int index) const {
  return spherical_harmonics_coefficients_.Get(index);
}
inline float ARLightEstimate::spherical_harmonics_coefficients(int index) const {
  // @@protoc_insertion_point(field_get:mediapipe.ARLightEstimate.spherical_harmonics_coefficients)
  return _internal_spherical_harmonics_coefficients(index);
}
inline void ARLightEstimate::set_spherical_harmonics_coefficients(int index, float value) {
  spherical_harmonics_coefficients_.Set(index, value);
  // @@protoc_insertion_point(field_set:mediapipe.ARLightEstimate.spherical_harmonics_coefficients)
}
inline void ARLightEstimate::_internal_add_spherical_harmonics_coefficients(float value) {
  spherical_harmonics_coefficients_.Add(value);
}
inline void ARLightEstimate::add_spherical_harmonics_coefficients(float value) {
  _internal_add_spherical_harmonics_coefficients(value);
  // @@protoc_insertion_point(field_add:mediapipe.ARLightEstimate.spherical_harmonics_coefficients)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ARLightEstimate::_internal_spherical_harmonics_coefficients() const {
  return spherical_harmonics_coefficients_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ARLightEstimate::spherical_harmonics_coefficients() const {
  // @@protoc_insertion_point(field_list:mediapipe.ARLightEstimate.spherical_harmonics_coefficients)
  return _internal_spherical_harmonics_coefficients();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ARLightEstimate::_internal_mutable_spherical_harmonics_coefficients() {
  return &spherical_harmonics_coefficients_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ARLightEstimate::mutable_spherical_harmonics_coefficients() {
  // @@protoc_insertion_point(field_mutable_list:mediapipe.ARLightEstimate.spherical_harmonics_coefficients)
  return _internal_mutable_spherical_harmonics_coefficients();
}

// optional .mediapipe.ARLightEstimate.DirectionVector primary_light_direction = 4;
inline bool ARLightEstimate::_internal_has_primary_light_direction() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || primary_light_direction_ != nullptr);
  return value;
}
inline bool ARLightEstimate::has_primary_light_direction() const {
  return _internal_has_primary_light_direction();
}
inline void ARLightEstimate::clear_primary_light_direction() {
  if (primary_light_direction_ != nullptr) primary_light_direction_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mediapipe::ARLightEstimate_DirectionVector& ARLightEstimate::_internal_primary_light_direction() const {
  const ::mediapipe::ARLightEstimate_DirectionVector* p = primary_light_direction_;
  return p != nullptr ? *p : reinterpret_cast<const ::mediapipe::ARLightEstimate_DirectionVector&>(
      ::mediapipe::_ARLightEstimate_DirectionVector_default_instance_);
}
inline const ::mediapipe::ARLightEstimate_DirectionVector& ARLightEstimate::primary_light_direction() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARLightEstimate.primary_light_direction)
  return _internal_primary_light_direction();
}
inline void ARLightEstimate::unsafe_arena_set_allocated_primary_light_direction(
    ::mediapipe::ARLightEstimate_DirectionVector* primary_light_direction) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(primary_light_direction_);
  }
  primary_light_direction_ = primary_light_direction;
  if (primary_light_direction) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mediapipe.ARLightEstimate.primary_light_direction)
}
inline ::mediapipe::ARLightEstimate_DirectionVector* ARLightEstimate::release_primary_light_direction() {
  _has_bits_[0] &= ~0x00000001u;
  ::mediapipe::ARLightEstimate_DirectionVector* temp = primary_light_direction_;
  primary_light_direction_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mediapipe::ARLightEstimate_DirectionVector* ARLightEstimate::unsafe_arena_release_primary_light_direction() {
  // @@protoc_insertion_point(field_release:mediapipe.ARLightEstimate.primary_light_direction)
  _has_bits_[0] &= ~0x00000001u;
  ::mediapipe::ARLightEstimate_DirectionVector* temp = primary_light_direction_;
  primary_light_direction_ = nullptr;
  return temp;
}
inline ::mediapipe::ARLightEstimate_DirectionVector* ARLightEstimate::_internal_mutable_primary_light_direction() {
  _has_bits_[0] |= 0x00000001u;
  if (primary_light_direction_ == nullptr) {
    auto* p = CreateMaybeMessage<::mediapipe::ARLightEstimate_DirectionVector>(GetArena());
    primary_light_direction_ = p;
  }
  return primary_light_direction_;
}
inline ::mediapipe::ARLightEstimate_DirectionVector* ARLightEstimate::mutable_primary_light_direction() {
  // @@protoc_insertion_point(field_mutable:mediapipe.ARLightEstimate.primary_light_direction)
  return _internal_mutable_primary_light_direction();
}
inline void ARLightEstimate::set_allocated_primary_light_direction(::mediapipe::ARLightEstimate_DirectionVector* primary_light_direction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete primary_light_direction_;
  }
  if (primary_light_direction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(primary_light_direction);
    if (message_arena != submessage_arena) {
      primary_light_direction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, primary_light_direction, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  primary_light_direction_ = primary_light_direction;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.ARLightEstimate.primary_light_direction)
}

// optional float primary_light_intensity = 5;
inline bool ARLightEstimate::_internal_has_primary_light_intensity() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ARLightEstimate::has_primary_light_intensity() const {
  return _internal_has_primary_light_intensity();
}
inline void ARLightEstimate::clear_primary_light_intensity() {
  primary_light_intensity_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float ARLightEstimate::_internal_primary_light_intensity() const {
  return primary_light_intensity_;
}
inline float ARLightEstimate::primary_light_intensity() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARLightEstimate.primary_light_intensity)
  return _internal_primary_light_intensity();
}
inline void ARLightEstimate::_internal_set_primary_light_intensity(float value) {
  _has_bits_[0] |= 0x00000008u;
  primary_light_intensity_ = value;
}
inline void ARLightEstimate::set_primary_light_intensity(float value) {
  _internal_set_primary_light_intensity(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARLightEstimate.primary_light_intensity)
}

// -------------------------------------------------------------------

// ARCamera_EulerAngles

// optional float roll = 1;
inline bool ARCamera_EulerAngles::_internal_has_roll() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ARCamera_EulerAngles::has_roll() const {
  return _internal_has_roll();
}
inline void ARCamera_EulerAngles::clear_roll() {
  roll_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float ARCamera_EulerAngles::_internal_roll() const {
  return roll_;
}
inline float ARCamera_EulerAngles::roll() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARCamera.EulerAngles.roll)
  return _internal_roll();
}
inline void ARCamera_EulerAngles::_internal_set_roll(float value) {
  _has_bits_[0] |= 0x00000001u;
  roll_ = value;
}
inline void ARCamera_EulerAngles::set_roll(float value) {
  _internal_set_roll(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARCamera.EulerAngles.roll)
}

// optional float pitch = 2;
inline bool ARCamera_EulerAngles::_internal_has_pitch() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ARCamera_EulerAngles::has_pitch() const {
  return _internal_has_pitch();
}
inline void ARCamera_EulerAngles::clear_pitch() {
  pitch_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float ARCamera_EulerAngles::_internal_pitch() const {
  return pitch_;
}
inline float ARCamera_EulerAngles::pitch() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARCamera.EulerAngles.pitch)
  return _internal_pitch();
}
inline void ARCamera_EulerAngles::_internal_set_pitch(float value) {
  _has_bits_[0] |= 0x00000002u;
  pitch_ = value;
}
inline void ARCamera_EulerAngles::set_pitch(float value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARCamera.EulerAngles.pitch)
}

// optional float yaw = 3;
inline bool ARCamera_EulerAngles::_internal_has_yaw() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ARCamera_EulerAngles::has_yaw() const {
  return _internal_has_yaw();
}
inline void ARCamera_EulerAngles::clear_yaw() {
  yaw_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float ARCamera_EulerAngles::_internal_yaw() const {
  return yaw_;
}
inline float ARCamera_EulerAngles::yaw() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARCamera.EulerAngles.yaw)
  return _internal_yaw();
}
inline void ARCamera_EulerAngles::_internal_set_yaw(float value) {
  _has_bits_[0] |= 0x00000004u;
  yaw_ = value;
}
inline void ARCamera_EulerAngles::set_yaw(float value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARCamera.EulerAngles.yaw)
}

// -------------------------------------------------------------------

// ARCamera

// optional .mediapipe.ARCamera.TrackingState tracking_state = 1 [default = UNAVAILABLE];
inline bool ARCamera::_internal_has_tracking_state() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ARCamera::has_tracking_state() const {
  return _internal_has_tracking_state();
}
inline void ARCamera::clear_tracking_state() {
  tracking_state_ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::mediapipe::ARCamera_TrackingState ARCamera::_internal_tracking_state() const {
  return static_cast< ::mediapipe::ARCamera_TrackingState >(tracking_state_);
}
inline ::mediapipe::ARCamera_TrackingState ARCamera::tracking_state() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARCamera.tracking_state)
  return _internal_tracking_state();
}
inline void ARCamera::_internal_set_tracking_state(::mediapipe::ARCamera_TrackingState value) {
  assert(::mediapipe::ARCamera_TrackingState_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  tracking_state_ = value;
}
inline void ARCamera::set_tracking_state(::mediapipe::ARCamera_TrackingState value) {
  _internal_set_tracking_state(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARCamera.tracking_state)
}

// optional .mediapipe.ARCamera.TrackingStateReason tracking_state_reason = 2 [default = NONE];
inline bool ARCamera::_internal_has_tracking_state_reason() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ARCamera::has_tracking_state_reason() const {
  return _internal_has_tracking_state_reason();
}
inline void ARCamera::clear_tracking_state_reason() {
  tracking_state_reason_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::mediapipe::ARCamera_TrackingStateReason ARCamera::_internal_tracking_state_reason() const {
  return static_cast< ::mediapipe::ARCamera_TrackingStateReason >(tracking_state_reason_);
}
inline ::mediapipe::ARCamera_TrackingStateReason ARCamera::tracking_state_reason() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARCamera.tracking_state_reason)
  return _internal_tracking_state_reason();
}
inline void ARCamera::_internal_set_tracking_state_reason(::mediapipe::ARCamera_TrackingStateReason value) {
  assert(::mediapipe::ARCamera_TrackingStateReason_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  tracking_state_reason_ = value;
}
inline void ARCamera::set_tracking_state_reason(::mediapipe::ARCamera_TrackingStateReason value) {
  _internal_set_tracking_state_reason(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARCamera.tracking_state_reason)
}

// repeated float transform = 3 [packed = true];
inline int ARCamera::_internal_transform_size() const {
  return transform_.size();
}
inline int ARCamera::transform_size() const {
  return _internal_transform_size();
}
inline void ARCamera::clear_transform() {
  transform_.Clear();
}
inline float ARCamera::_internal_transform(int index) const {
  return transform_.Get(index);
}
inline float ARCamera::transform(int index) const {
  // @@protoc_insertion_point(field_get:mediapipe.ARCamera.transform)
  return _internal_transform(index);
}
inline void ARCamera::set_transform(int index, float value) {
  transform_.Set(index, value);
  // @@protoc_insertion_point(field_set:mediapipe.ARCamera.transform)
}
inline void ARCamera::_internal_add_transform(float value) {
  transform_.Add(value);
}
inline void ARCamera::add_transform(float value) {
  _internal_add_transform(value);
  // @@protoc_insertion_point(field_add:mediapipe.ARCamera.transform)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ARCamera::_internal_transform() const {
  return transform_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ARCamera::transform() const {
  // @@protoc_insertion_point(field_list:mediapipe.ARCamera.transform)
  return _internal_transform();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ARCamera::_internal_mutable_transform() {
  return &transform_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ARCamera::mutable_transform() {
  // @@protoc_insertion_point(field_mutable_list:mediapipe.ARCamera.transform)
  return _internal_mutable_transform();
}

// optional .mediapipe.ARCamera.EulerAngles euler_angles = 4;
inline bool ARCamera::_internal_has_euler_angles() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || euler_angles_ != nullptr);
  return value;
}
inline bool ARCamera::has_euler_angles() const {
  return _internal_has_euler_angles();
}
inline void ARCamera::clear_euler_angles() {
  if (euler_angles_ != nullptr) euler_angles_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mediapipe::ARCamera_EulerAngles& ARCamera::_internal_euler_angles() const {
  const ::mediapipe::ARCamera_EulerAngles* p = euler_angles_;
  return p != nullptr ? *p : reinterpret_cast<const ::mediapipe::ARCamera_EulerAngles&>(
      ::mediapipe::_ARCamera_EulerAngles_default_instance_);
}
inline const ::mediapipe::ARCamera_EulerAngles& ARCamera::euler_angles() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARCamera.euler_angles)
  return _internal_euler_angles();
}
inline void ARCamera::unsafe_arena_set_allocated_euler_angles(
    ::mediapipe::ARCamera_EulerAngles* euler_angles) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(euler_angles_);
  }
  euler_angles_ = euler_angles;
  if (euler_angles) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mediapipe.ARCamera.euler_angles)
}
inline ::mediapipe::ARCamera_EulerAngles* ARCamera::release_euler_angles() {
  _has_bits_[0] &= ~0x00000001u;
  ::mediapipe::ARCamera_EulerAngles* temp = euler_angles_;
  euler_angles_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mediapipe::ARCamera_EulerAngles* ARCamera::unsafe_arena_release_euler_angles() {
  // @@protoc_insertion_point(field_release:mediapipe.ARCamera.euler_angles)
  _has_bits_[0] &= ~0x00000001u;
  ::mediapipe::ARCamera_EulerAngles* temp = euler_angles_;
  euler_angles_ = nullptr;
  return temp;
}
inline ::mediapipe::ARCamera_EulerAngles* ARCamera::_internal_mutable_euler_angles() {
  _has_bits_[0] |= 0x00000001u;
  if (euler_angles_ == nullptr) {
    auto* p = CreateMaybeMessage<::mediapipe::ARCamera_EulerAngles>(GetArena());
    euler_angles_ = p;
  }
  return euler_angles_;
}
inline ::mediapipe::ARCamera_EulerAngles* ARCamera::mutable_euler_angles() {
  // @@protoc_insertion_point(field_mutable:mediapipe.ARCamera.euler_angles)
  return _internal_mutable_euler_angles();
}
inline void ARCamera::set_allocated_euler_angles(::mediapipe::ARCamera_EulerAngles* euler_angles) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete euler_angles_;
  }
  if (euler_angles) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(euler_angles);
    if (message_arena != submessage_arena) {
      euler_angles = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, euler_angles, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  euler_angles_ = euler_angles;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.ARCamera.euler_angles)
}

// optional int32 image_resolution_width = 5;
inline bool ARCamera::_internal_has_image_resolution_width() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ARCamera::has_image_resolution_width() const {
  return _internal_has_image_resolution_width();
}
inline void ARCamera::clear_image_resolution_width() {
  image_resolution_width_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ARCamera::_internal_image_resolution_width() const {
  return image_resolution_width_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ARCamera::image_resolution_width() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARCamera.image_resolution_width)
  return _internal_image_resolution_width();
}
inline void ARCamera::_internal_set_image_resolution_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  image_resolution_width_ = value;
}
inline void ARCamera::set_image_resolution_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_image_resolution_width(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARCamera.image_resolution_width)
}

// optional int32 image_resolution_height = 6;
inline bool ARCamera::_internal_has_image_resolution_height() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ARCamera::has_image_resolution_height() const {
  return _internal_has_image_resolution_height();
}
inline void ARCamera::clear_image_resolution_height() {
  image_resolution_height_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ARCamera::_internal_image_resolution_height() const {
  return image_resolution_height_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ARCamera::image_resolution_height() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARCamera.image_resolution_height)
  return _internal_image_resolution_height();
}
inline void ARCamera::_internal_set_image_resolution_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  image_resolution_height_ = value;
}
inline void ARCamera::set_image_resolution_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_image_resolution_height(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARCamera.image_resolution_height)
}

// repeated float intrinsics = 7 [packed = true];
inline int ARCamera::_internal_intrinsics_size() const {
  return intrinsics_.size();
}
inline int ARCamera::intrinsics_size() const {
  return _internal_intrinsics_size();
}
inline void ARCamera::clear_intrinsics() {
  intrinsics_.Clear();
}
inline float ARCamera::_internal_intrinsics(int index) const {
  return intrinsics_.Get(index);
}
inline float ARCamera::intrinsics(int index) const {
  // @@protoc_insertion_point(field_get:mediapipe.ARCamera.intrinsics)
  return _internal_intrinsics(index);
}
inline void ARCamera::set_intrinsics(int index, float value) {
  intrinsics_.Set(index, value);
  // @@protoc_insertion_point(field_set:mediapipe.ARCamera.intrinsics)
}
inline void ARCamera::_internal_add_intrinsics(float value) {
  intrinsics_.Add(value);
}
inline void ARCamera::add_intrinsics(float value) {
  _internal_add_intrinsics(value);
  // @@protoc_insertion_point(field_add:mediapipe.ARCamera.intrinsics)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ARCamera::_internal_intrinsics() const {
  return intrinsics_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ARCamera::intrinsics() const {
  // @@protoc_insertion_point(field_list:mediapipe.ARCamera.intrinsics)
  return _internal_intrinsics();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ARCamera::_internal_mutable_intrinsics() {
  return &intrinsics_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ARCamera::mutable_intrinsics() {
  // @@protoc_insertion_point(field_mutable_list:mediapipe.ARCamera.intrinsics)
  return _internal_mutable_intrinsics();
}

// repeated float projection_matrix = 8 [packed = true];
inline int ARCamera::_internal_projection_matrix_size() const {
  return projection_matrix_.size();
}
inline int ARCamera::projection_matrix_size() const {
  return _internal_projection_matrix_size();
}
inline void ARCamera::clear_projection_matrix() {
  projection_matrix_.Clear();
}
inline float ARCamera::_internal_projection_matrix(int index) const {
  return projection_matrix_.Get(index);
}
inline float ARCamera::projection_matrix(int index) const {
  // @@protoc_insertion_point(field_get:mediapipe.ARCamera.projection_matrix)
  return _internal_projection_matrix(index);
}
inline void ARCamera::set_projection_matrix(int index, float value) {
  projection_matrix_.Set(index, value);
  // @@protoc_insertion_point(field_set:mediapipe.ARCamera.projection_matrix)
}
inline void ARCamera::_internal_add_projection_matrix(float value) {
  projection_matrix_.Add(value);
}
inline void ARCamera::add_projection_matrix(float value) {
  _internal_add_projection_matrix(value);
  // @@protoc_insertion_point(field_add:mediapipe.ARCamera.projection_matrix)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ARCamera::_internal_projection_matrix() const {
  return projection_matrix_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ARCamera::projection_matrix() const {
  // @@protoc_insertion_point(field_list:mediapipe.ARCamera.projection_matrix)
  return _internal_projection_matrix();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ARCamera::_internal_mutable_projection_matrix() {
  return &projection_matrix_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ARCamera::mutable_projection_matrix() {
  // @@protoc_insertion_point(field_mutable_list:mediapipe.ARCamera.projection_matrix)
  return _internal_mutable_projection_matrix();
}

// repeated float view_matrix = 9 [packed = true];
inline int ARCamera::_internal_view_matrix_size() const {
  return view_matrix_.size();
}
inline int ARCamera::view_matrix_size() const {
  return _internal_view_matrix_size();
}
inline void ARCamera::clear_view_matrix() {
  view_matrix_.Clear();
}
inline float ARCamera::_internal_view_matrix(int index) const {
  return view_matrix_.Get(index);
}
inline float ARCamera::view_matrix(int index) const {
  // @@protoc_insertion_point(field_get:mediapipe.ARCamera.view_matrix)
  return _internal_view_matrix(index);
}
inline void ARCamera::set_view_matrix(int index, float value) {
  view_matrix_.Set(index, value);
  // @@protoc_insertion_point(field_set:mediapipe.ARCamera.view_matrix)
}
inline void ARCamera::_internal_add_view_matrix(float value) {
  view_matrix_.Add(value);
}
inline void ARCamera::add_view_matrix(float value) {
  _internal_add_view_matrix(value);
  // @@protoc_insertion_point(field_add:mediapipe.ARCamera.view_matrix)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ARCamera::_internal_view_matrix() const {
  return view_matrix_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ARCamera::view_matrix() const {
  // @@protoc_insertion_point(field_list:mediapipe.ARCamera.view_matrix)
  return _internal_view_matrix();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ARCamera::_internal_mutable_view_matrix() {
  return &view_matrix_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ARCamera::mutable_view_matrix() {
  // @@protoc_insertion_point(field_mutable_list:mediapipe.ARCamera.view_matrix)
  return _internal_mutable_view_matrix();
}

// -------------------------------------------------------------------

// ARFaceGeometry_Vertex

// optional float x = 1;
inline bool ARFaceGeometry_Vertex::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ARFaceGeometry_Vertex::has_x() const {
  return _internal_has_x();
}
inline void ARFaceGeometry_Vertex::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float ARFaceGeometry_Vertex::_internal_x() const {
  return x_;
}
inline float ARFaceGeometry_Vertex::x() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARFaceGeometry.Vertex.x)
  return _internal_x();
}
inline void ARFaceGeometry_Vertex::_internal_set_x(float value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void ARFaceGeometry_Vertex::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARFaceGeometry.Vertex.x)
}

// optional float y = 2;
inline bool ARFaceGeometry_Vertex::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ARFaceGeometry_Vertex::has_y() const {
  return _internal_has_y();
}
inline void ARFaceGeometry_Vertex::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float ARFaceGeometry_Vertex::_internal_y() const {
  return y_;
}
inline float ARFaceGeometry_Vertex::y() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARFaceGeometry.Vertex.y)
  return _internal_y();
}
inline void ARFaceGeometry_Vertex::_internal_set_y(float value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void ARFaceGeometry_Vertex::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARFaceGeometry.Vertex.y)
}

// optional float z = 3;
inline bool ARFaceGeometry_Vertex::_internal_has_z() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ARFaceGeometry_Vertex::has_z() const {
  return _internal_has_z();
}
inline void ARFaceGeometry_Vertex::clear_z() {
  z_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float ARFaceGeometry_Vertex::_internal_z() const {
  return z_;
}
inline float ARFaceGeometry_Vertex::z() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARFaceGeometry.Vertex.z)
  return _internal_z();
}
inline void ARFaceGeometry_Vertex::_internal_set_z(float value) {
  _has_bits_[0] |= 0x00000004u;
  z_ = value;
}
inline void ARFaceGeometry_Vertex::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARFaceGeometry.Vertex.z)
}

// -------------------------------------------------------------------

// ARFaceGeometry_TextureCoordinate

// optional float u = 1;
inline bool ARFaceGeometry_TextureCoordinate::_internal_has_u() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ARFaceGeometry_TextureCoordinate::has_u() const {
  return _internal_has_u();
}
inline void ARFaceGeometry_TextureCoordinate::clear_u() {
  u_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float ARFaceGeometry_TextureCoordinate::_internal_u() const {
  return u_;
}
inline float ARFaceGeometry_TextureCoordinate::u() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARFaceGeometry.TextureCoordinate.u)
  return _internal_u();
}
inline void ARFaceGeometry_TextureCoordinate::_internal_set_u(float value) {
  _has_bits_[0] |= 0x00000001u;
  u_ = value;
}
inline void ARFaceGeometry_TextureCoordinate::set_u(float value) {
  _internal_set_u(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARFaceGeometry.TextureCoordinate.u)
}

// optional float v = 2;
inline bool ARFaceGeometry_TextureCoordinate::_internal_has_v() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ARFaceGeometry_TextureCoordinate::has_v() const {
  return _internal_has_v();
}
inline void ARFaceGeometry_TextureCoordinate::clear_v() {
  v_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float ARFaceGeometry_TextureCoordinate::_internal_v() const {
  return v_;
}
inline float ARFaceGeometry_TextureCoordinate::v() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARFaceGeometry.TextureCoordinate.v)
  return _internal_v();
}
inline void ARFaceGeometry_TextureCoordinate::_internal_set_v(float value) {
  _has_bits_[0] |= 0x00000002u;
  v_ = value;
}
inline void ARFaceGeometry_TextureCoordinate::set_v(float value) {
  _internal_set_v(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARFaceGeometry.TextureCoordinate.v)
}

// -------------------------------------------------------------------

// ARFaceGeometry

// repeated .mediapipe.ARFaceGeometry.Vertex vertices = 1;
inline int ARFaceGeometry::_internal_vertices_size() const {
  return vertices_.size();
}
inline int ARFaceGeometry::vertices_size() const {
  return _internal_vertices_size();
}
inline void ARFaceGeometry::clear_vertices() {
  vertices_.Clear();
}
inline ::mediapipe::ARFaceGeometry_Vertex* ARFaceGeometry::mutable_vertices(int index) {
  // @@protoc_insertion_point(field_mutable:mediapipe.ARFaceGeometry.vertices)
  return vertices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARFaceGeometry_Vertex >*
ARFaceGeometry::mutable_vertices() {
  // @@protoc_insertion_point(field_mutable_list:mediapipe.ARFaceGeometry.vertices)
  return &vertices_;
}
inline const ::mediapipe::ARFaceGeometry_Vertex& ARFaceGeometry::_internal_vertices(int index) const {
  return vertices_.Get(index);
}
inline const ::mediapipe::ARFaceGeometry_Vertex& ARFaceGeometry::vertices(int index) const {
  // @@protoc_insertion_point(field_get:mediapipe.ARFaceGeometry.vertices)
  return _internal_vertices(index);
}
inline ::mediapipe::ARFaceGeometry_Vertex* ARFaceGeometry::_internal_add_vertices() {
  return vertices_.Add();
}
inline ::mediapipe::ARFaceGeometry_Vertex* ARFaceGeometry::add_vertices() {
  // @@protoc_insertion_point(field_add:mediapipe.ARFaceGeometry.vertices)
  return _internal_add_vertices();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARFaceGeometry_Vertex >&
ARFaceGeometry::vertices() const {
  // @@protoc_insertion_point(field_list:mediapipe.ARFaceGeometry.vertices)
  return vertices_;
}

// optional int32 vertex_count = 2;
inline bool ARFaceGeometry::_internal_has_vertex_count() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ARFaceGeometry::has_vertex_count() const {
  return _internal_has_vertex_count();
}
inline void ARFaceGeometry::clear_vertex_count() {
  vertex_count_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ARFaceGeometry::_internal_vertex_count() const {
  return vertex_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ARFaceGeometry::vertex_count() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARFaceGeometry.vertex_count)
  return _internal_vertex_count();
}
inline void ARFaceGeometry::_internal_set_vertex_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  vertex_count_ = value;
}
inline void ARFaceGeometry::set_vertex_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_vertex_count(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARFaceGeometry.vertex_count)
}

// repeated .mediapipe.ARFaceGeometry.TextureCoordinate texture_coordinates = 3;
inline int ARFaceGeometry::_internal_texture_coordinates_size() const {
  return texture_coordinates_.size();
}
inline int ARFaceGeometry::texture_coordinates_size() const {
  return _internal_texture_coordinates_size();
}
inline void ARFaceGeometry::clear_texture_coordinates() {
  texture_coordinates_.Clear();
}
inline ::mediapipe::ARFaceGeometry_TextureCoordinate* ARFaceGeometry::mutable_texture_coordinates(int index) {
  // @@protoc_insertion_point(field_mutable:mediapipe.ARFaceGeometry.texture_coordinates)
  return texture_coordinates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARFaceGeometry_TextureCoordinate >*
ARFaceGeometry::mutable_texture_coordinates() {
  // @@protoc_insertion_point(field_mutable_list:mediapipe.ARFaceGeometry.texture_coordinates)
  return &texture_coordinates_;
}
inline const ::mediapipe::ARFaceGeometry_TextureCoordinate& ARFaceGeometry::_internal_texture_coordinates(int index) const {
  return texture_coordinates_.Get(index);
}
inline const ::mediapipe::ARFaceGeometry_TextureCoordinate& ARFaceGeometry::texture_coordinates(int index) const {
  // @@protoc_insertion_point(field_get:mediapipe.ARFaceGeometry.texture_coordinates)
  return _internal_texture_coordinates(index);
}
inline ::mediapipe::ARFaceGeometry_TextureCoordinate* ARFaceGeometry::_internal_add_texture_coordinates() {
  return texture_coordinates_.Add();
}
inline ::mediapipe::ARFaceGeometry_TextureCoordinate* ARFaceGeometry::add_texture_coordinates() {
  // @@protoc_insertion_point(field_add:mediapipe.ARFaceGeometry.texture_coordinates)
  return _internal_add_texture_coordinates();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARFaceGeometry_TextureCoordinate >&
ARFaceGeometry::texture_coordinates() const {
  // @@protoc_insertion_point(field_list:mediapipe.ARFaceGeometry.texture_coordinates)
  return texture_coordinates_;
}

// optional int32 texture_coordinate_count = 4;
inline bool ARFaceGeometry::_internal_has_texture_coordinate_count() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ARFaceGeometry::has_texture_coordinate_count() const {
  return _internal_has_texture_coordinate_count();
}
inline void ARFaceGeometry::clear_texture_coordinate_count() {
  texture_coordinate_count_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ARFaceGeometry::_internal_texture_coordinate_count() const {
  return texture_coordinate_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ARFaceGeometry::texture_coordinate_count() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARFaceGeometry.texture_coordinate_count)
  return _internal_texture_coordinate_count();
}
inline void ARFaceGeometry::_internal_set_texture_coordinate_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  texture_coordinate_count_ = value;
}
inline void ARFaceGeometry::set_texture_coordinate_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_texture_coordinate_count(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARFaceGeometry.texture_coordinate_count)
}

// repeated int32 triangle_indices = 5 [packed = true];
inline int ARFaceGeometry::_internal_triangle_indices_size() const {
  return triangle_indices_.size();
}
inline int ARFaceGeometry::triangle_indices_size() const {
  return _internal_triangle_indices_size();
}
inline void ARFaceGeometry::clear_triangle_indices() {
  triangle_indices_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ARFaceGeometry::_internal_triangle_indices(int index) const {
  return triangle_indices_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ARFaceGeometry::triangle_indices(int index) const {
  // @@protoc_insertion_point(field_get:mediapipe.ARFaceGeometry.triangle_indices)
  return _internal_triangle_indices(index);
}
inline void ARFaceGeometry::set_triangle_indices(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  triangle_indices_.Set(index, value);
  // @@protoc_insertion_point(field_set:mediapipe.ARFaceGeometry.triangle_indices)
}
inline void ARFaceGeometry::_internal_add_triangle_indices(::PROTOBUF_NAMESPACE_ID::int32 value) {
  triangle_indices_.Add(value);
}
inline void ARFaceGeometry::add_triangle_indices(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_triangle_indices(value);
  // @@protoc_insertion_point(field_add:mediapipe.ARFaceGeometry.triangle_indices)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
ARFaceGeometry::_internal_triangle_indices() const {
  return triangle_indices_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
ARFaceGeometry::triangle_indices() const {
  // @@protoc_insertion_point(field_list:mediapipe.ARFaceGeometry.triangle_indices)
  return _internal_triangle_indices();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
ARFaceGeometry::_internal_mutable_triangle_indices() {
  return &triangle_indices_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
ARFaceGeometry::mutable_triangle_indices() {
  // @@protoc_insertion_point(field_mutable_list:mediapipe.ARFaceGeometry.triangle_indices)
  return _internal_mutable_triangle_indices();
}

// optional int32 triangle_count = 6;
inline bool ARFaceGeometry::_internal_has_triangle_count() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ARFaceGeometry::has_triangle_count() const {
  return _internal_has_triangle_count();
}
inline void ARFaceGeometry::clear_triangle_count() {
  triangle_count_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ARFaceGeometry::_internal_triangle_count() const {
  return triangle_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ARFaceGeometry::triangle_count() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARFaceGeometry.triangle_count)
  return _internal_triangle_count();
}
inline void ARFaceGeometry::_internal_set_triangle_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  triangle_count_ = value;
}
inline void ARFaceGeometry::set_triangle_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_triangle_count(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARFaceGeometry.triangle_count)
}

// -------------------------------------------------------------------

// ARBlendShapeMap_MapEntry

// optional string blend_shape_location = 1;
inline bool ARBlendShapeMap_MapEntry::_internal_has_blend_shape_location() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ARBlendShapeMap_MapEntry::has_blend_shape_location() const {
  return _internal_has_blend_shape_location();
}
inline void ARBlendShapeMap_MapEntry::clear_blend_shape_location() {
  blend_shape_location_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ARBlendShapeMap_MapEntry::blend_shape_location() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARBlendShapeMap.MapEntry.blend_shape_location)
  return _internal_blend_shape_location();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void ARBlendShapeMap_MapEntry::set_blend_shape_location(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 blend_shape_location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:mediapipe.ARBlendShapeMap.MapEntry.blend_shape_location)
}
inline std::string* ARBlendShapeMap_MapEntry::mutable_blend_shape_location() {
  // @@protoc_insertion_point(field_mutable:mediapipe.ARBlendShapeMap.MapEntry.blend_shape_location)
  return _internal_mutable_blend_shape_location();
}
inline const std::string& ARBlendShapeMap_MapEntry::_internal_blend_shape_location() const {
  return blend_shape_location_.Get();
}
inline void ARBlendShapeMap_MapEntry::_internal_set_blend_shape_location(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  blend_shape_location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* ARBlendShapeMap_MapEntry::_internal_mutable_blend_shape_location() {
  _has_bits_[0] |= 0x00000001u;
  return blend_shape_location_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ARBlendShapeMap_MapEntry::release_blend_shape_location() {
  // @@protoc_insertion_point(field_release:mediapipe.ARBlendShapeMap.MapEntry.blend_shape_location)
  if (!_internal_has_blend_shape_location()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return blend_shape_location_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ARBlendShapeMap_MapEntry::set_allocated_blend_shape_location(std::string* blend_shape_location) {
  if (blend_shape_location != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  blend_shape_location_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), blend_shape_location,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mediapipe.ARBlendShapeMap.MapEntry.blend_shape_location)
}

// optional float blend_shape_coefficient = 2;
inline bool ARBlendShapeMap_MapEntry::_internal_has_blend_shape_coefficient() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ARBlendShapeMap_MapEntry::has_blend_shape_coefficient() const {
  return _internal_has_blend_shape_coefficient();
}
inline void ARBlendShapeMap_MapEntry::clear_blend_shape_coefficient() {
  blend_shape_coefficient_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float ARBlendShapeMap_MapEntry::_internal_blend_shape_coefficient() const {
  return blend_shape_coefficient_;
}
inline float ARBlendShapeMap_MapEntry::blend_shape_coefficient() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARBlendShapeMap.MapEntry.blend_shape_coefficient)
  return _internal_blend_shape_coefficient();
}
inline void ARBlendShapeMap_MapEntry::_internal_set_blend_shape_coefficient(float value) {
  _has_bits_[0] |= 0x00000002u;
  blend_shape_coefficient_ = value;
}
inline void ARBlendShapeMap_MapEntry::set_blend_shape_coefficient(float value) {
  _internal_set_blend_shape_coefficient(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARBlendShapeMap.MapEntry.blend_shape_coefficient)
}

// -------------------------------------------------------------------

// ARBlendShapeMap

// repeated .mediapipe.ARBlendShapeMap.MapEntry entries = 1;
inline int ARBlendShapeMap::_internal_entries_size() const {
  return entries_.size();
}
inline int ARBlendShapeMap::entries_size() const {
  return _internal_entries_size();
}
inline void ARBlendShapeMap::clear_entries() {
  entries_.Clear();
}
inline ::mediapipe::ARBlendShapeMap_MapEntry* ARBlendShapeMap::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:mediapipe.ARBlendShapeMap.entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARBlendShapeMap_MapEntry >*
ARBlendShapeMap::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:mediapipe.ARBlendShapeMap.entries)
  return &entries_;
}
inline const ::mediapipe::ARBlendShapeMap_MapEntry& ARBlendShapeMap::_internal_entries(int index) const {
  return entries_.Get(index);
}
inline const ::mediapipe::ARBlendShapeMap_MapEntry& ARBlendShapeMap::entries(int index) const {
  // @@protoc_insertion_point(field_get:mediapipe.ARBlendShapeMap.entries)
  return _internal_entries(index);
}
inline ::mediapipe::ARBlendShapeMap_MapEntry* ARBlendShapeMap::_internal_add_entries() {
  return entries_.Add();
}
inline ::mediapipe::ARBlendShapeMap_MapEntry* ARBlendShapeMap::add_entries() {
  // @@protoc_insertion_point(field_add:mediapipe.ARBlendShapeMap.entries)
  return _internal_add_entries();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARBlendShapeMap_MapEntry >&
ARBlendShapeMap::entries() const {
  // @@protoc_insertion_point(field_list:mediapipe.ARBlendShapeMap.entries)
  return entries_;
}

// -------------------------------------------------------------------

// ARFaceAnchor

// optional .mediapipe.ARFaceGeometry geometry = 1;
inline bool ARFaceAnchor::_internal_has_geometry() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || geometry_ != nullptr);
  return value;
}
inline bool ARFaceAnchor::has_geometry() const {
  return _internal_has_geometry();
}
inline void ARFaceAnchor::clear_geometry() {
  if (geometry_ != nullptr) geometry_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mediapipe::ARFaceGeometry& ARFaceAnchor::_internal_geometry() const {
  const ::mediapipe::ARFaceGeometry* p = geometry_;
  return p != nullptr ? *p : reinterpret_cast<const ::mediapipe::ARFaceGeometry&>(
      ::mediapipe::_ARFaceGeometry_default_instance_);
}
inline const ::mediapipe::ARFaceGeometry& ARFaceAnchor::geometry() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARFaceAnchor.geometry)
  return _internal_geometry();
}
inline void ARFaceAnchor::unsafe_arena_set_allocated_geometry(
    ::mediapipe::ARFaceGeometry* geometry) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(geometry_);
  }
  geometry_ = geometry;
  if (geometry) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mediapipe.ARFaceAnchor.geometry)
}
inline ::mediapipe::ARFaceGeometry* ARFaceAnchor::release_geometry() {
  _has_bits_[0] &= ~0x00000001u;
  ::mediapipe::ARFaceGeometry* temp = geometry_;
  geometry_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mediapipe::ARFaceGeometry* ARFaceAnchor::unsafe_arena_release_geometry() {
  // @@protoc_insertion_point(field_release:mediapipe.ARFaceAnchor.geometry)
  _has_bits_[0] &= ~0x00000001u;
  ::mediapipe::ARFaceGeometry* temp = geometry_;
  geometry_ = nullptr;
  return temp;
}
inline ::mediapipe::ARFaceGeometry* ARFaceAnchor::_internal_mutable_geometry() {
  _has_bits_[0] |= 0x00000001u;
  if (geometry_ == nullptr) {
    auto* p = CreateMaybeMessage<::mediapipe::ARFaceGeometry>(GetArena());
    geometry_ = p;
  }
  return geometry_;
}
inline ::mediapipe::ARFaceGeometry* ARFaceAnchor::mutable_geometry() {
  // @@protoc_insertion_point(field_mutable:mediapipe.ARFaceAnchor.geometry)
  return _internal_mutable_geometry();
}
inline void ARFaceAnchor::set_allocated_geometry(::mediapipe::ARFaceGeometry* geometry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete geometry_;
  }
  if (geometry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(geometry);
    if (message_arena != submessage_arena) {
      geometry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geometry, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  geometry_ = geometry;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.ARFaceAnchor.geometry)
}

// optional .mediapipe.ARBlendShapeMap blend_shapes = 2;
inline bool ARFaceAnchor::_internal_has_blend_shapes() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || blend_shapes_ != nullptr);
  return value;
}
inline bool ARFaceAnchor::has_blend_shapes() const {
  return _internal_has_blend_shapes();
}
inline void ARFaceAnchor::clear_blend_shapes() {
  if (blend_shapes_ != nullptr) blend_shapes_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mediapipe::ARBlendShapeMap& ARFaceAnchor::_internal_blend_shapes() const {
  const ::mediapipe::ARBlendShapeMap* p = blend_shapes_;
  return p != nullptr ? *p : reinterpret_cast<const ::mediapipe::ARBlendShapeMap&>(
      ::mediapipe::_ARBlendShapeMap_default_instance_);
}
inline const ::mediapipe::ARBlendShapeMap& ARFaceAnchor::blend_shapes() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARFaceAnchor.blend_shapes)
  return _internal_blend_shapes();
}
inline void ARFaceAnchor::unsafe_arena_set_allocated_blend_shapes(
    ::mediapipe::ARBlendShapeMap* blend_shapes) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(blend_shapes_);
  }
  blend_shapes_ = blend_shapes;
  if (blend_shapes) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mediapipe.ARFaceAnchor.blend_shapes)
}
inline ::mediapipe::ARBlendShapeMap* ARFaceAnchor::release_blend_shapes() {
  _has_bits_[0] &= ~0x00000002u;
  ::mediapipe::ARBlendShapeMap* temp = blend_shapes_;
  blend_shapes_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mediapipe::ARBlendShapeMap* ARFaceAnchor::unsafe_arena_release_blend_shapes() {
  // @@protoc_insertion_point(field_release:mediapipe.ARFaceAnchor.blend_shapes)
  _has_bits_[0] &= ~0x00000002u;
  ::mediapipe::ARBlendShapeMap* temp = blend_shapes_;
  blend_shapes_ = nullptr;
  return temp;
}
inline ::mediapipe::ARBlendShapeMap* ARFaceAnchor::_internal_mutable_blend_shapes() {
  _has_bits_[0] |= 0x00000002u;
  if (blend_shapes_ == nullptr) {
    auto* p = CreateMaybeMessage<::mediapipe::ARBlendShapeMap>(GetArena());
    blend_shapes_ = p;
  }
  return blend_shapes_;
}
inline ::mediapipe::ARBlendShapeMap* ARFaceAnchor::mutable_blend_shapes() {
  // @@protoc_insertion_point(field_mutable:mediapipe.ARFaceAnchor.blend_shapes)
  return _internal_mutable_blend_shapes();
}
inline void ARFaceAnchor::set_allocated_blend_shapes(::mediapipe::ARBlendShapeMap* blend_shapes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete blend_shapes_;
  }
  if (blend_shapes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(blend_shapes);
    if (message_arena != submessage_arena) {
      blend_shapes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, blend_shapes, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  blend_shapes_ = blend_shapes;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.ARFaceAnchor.blend_shapes)
}

// repeated float transform = 3;
inline int ARFaceAnchor::_internal_transform_size() const {
  return transform_.size();
}
inline int ARFaceAnchor::transform_size() const {
  return _internal_transform_size();
}
inline void ARFaceAnchor::clear_transform() {
  transform_.Clear();
}
inline float ARFaceAnchor::_internal_transform(int index) const {
  return transform_.Get(index);
}
inline float ARFaceAnchor::transform(int index) const {
  // @@protoc_insertion_point(field_get:mediapipe.ARFaceAnchor.transform)
  return _internal_transform(index);
}
inline void ARFaceAnchor::set_transform(int index, float value) {
  transform_.Set(index, value);
  // @@protoc_insertion_point(field_set:mediapipe.ARFaceAnchor.transform)
}
inline void ARFaceAnchor::_internal_add_transform(float value) {
  transform_.Add(value);
}
inline void ARFaceAnchor::add_transform(float value) {
  _internal_add_transform(value);
  // @@protoc_insertion_point(field_add:mediapipe.ARFaceAnchor.transform)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ARFaceAnchor::_internal_transform() const {
  return transform_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ARFaceAnchor::transform() const {
  // @@protoc_insertion_point(field_list:mediapipe.ARFaceAnchor.transform)
  return _internal_transform();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ARFaceAnchor::_internal_mutable_transform() {
  return &transform_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ARFaceAnchor::mutable_transform() {
  // @@protoc_insertion_point(field_mutable_list:mediapipe.ARFaceAnchor.transform)
  return _internal_mutable_transform();
}

// optional bool is_tracked = 4;
inline bool ARFaceAnchor::_internal_has_is_tracked() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ARFaceAnchor::has_is_tracked() const {
  return _internal_has_is_tracked();
}
inline void ARFaceAnchor::clear_is_tracked() {
  is_tracked_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ARFaceAnchor::_internal_is_tracked() const {
  return is_tracked_;
}
inline bool ARFaceAnchor::is_tracked() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARFaceAnchor.is_tracked)
  return _internal_is_tracked();
}
inline void ARFaceAnchor::_internal_set_is_tracked(bool value) {
  _has_bits_[0] |= 0x00000004u;
  is_tracked_ = value;
}
inline void ARFaceAnchor::set_is_tracked(bool value) {
  _internal_set_is_tracked(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARFaceAnchor.is_tracked)
}

// -------------------------------------------------------------------

// ARPlaneGeometry_Vertex

// optional float x = 1;
inline bool ARPlaneGeometry_Vertex::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ARPlaneGeometry_Vertex::has_x() const {
  return _internal_has_x();
}
inline void ARPlaneGeometry_Vertex::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float ARPlaneGeometry_Vertex::_internal_x() const {
  return x_;
}
inline float ARPlaneGeometry_Vertex::x() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARPlaneGeometry.Vertex.x)
  return _internal_x();
}
inline void ARPlaneGeometry_Vertex::_internal_set_x(float value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void ARPlaneGeometry_Vertex::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARPlaneGeometry.Vertex.x)
}

// optional float y = 2;
inline bool ARPlaneGeometry_Vertex::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ARPlaneGeometry_Vertex::has_y() const {
  return _internal_has_y();
}
inline void ARPlaneGeometry_Vertex::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float ARPlaneGeometry_Vertex::_internal_y() const {
  return y_;
}
inline float ARPlaneGeometry_Vertex::y() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARPlaneGeometry.Vertex.y)
  return _internal_y();
}
inline void ARPlaneGeometry_Vertex::_internal_set_y(float value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void ARPlaneGeometry_Vertex::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARPlaneGeometry.Vertex.y)
}

// optional float z = 3;
inline bool ARPlaneGeometry_Vertex::_internal_has_z() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ARPlaneGeometry_Vertex::has_z() const {
  return _internal_has_z();
}
inline void ARPlaneGeometry_Vertex::clear_z() {
  z_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float ARPlaneGeometry_Vertex::_internal_z() const {
  return z_;
}
inline float ARPlaneGeometry_Vertex::z() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARPlaneGeometry.Vertex.z)
  return _internal_z();
}
inline void ARPlaneGeometry_Vertex::_internal_set_z(float value) {
  _has_bits_[0] |= 0x00000004u;
  z_ = value;
}
inline void ARPlaneGeometry_Vertex::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARPlaneGeometry.Vertex.z)
}

// -------------------------------------------------------------------

// ARPlaneGeometry_TextureCoordinate

// optional float u = 1;
inline bool ARPlaneGeometry_TextureCoordinate::_internal_has_u() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ARPlaneGeometry_TextureCoordinate::has_u() const {
  return _internal_has_u();
}
inline void ARPlaneGeometry_TextureCoordinate::clear_u() {
  u_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float ARPlaneGeometry_TextureCoordinate::_internal_u() const {
  return u_;
}
inline float ARPlaneGeometry_TextureCoordinate::u() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARPlaneGeometry.TextureCoordinate.u)
  return _internal_u();
}
inline void ARPlaneGeometry_TextureCoordinate::_internal_set_u(float value) {
  _has_bits_[0] |= 0x00000001u;
  u_ = value;
}
inline void ARPlaneGeometry_TextureCoordinate::set_u(float value) {
  _internal_set_u(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARPlaneGeometry.TextureCoordinate.u)
}

// optional float v = 2;
inline bool ARPlaneGeometry_TextureCoordinate::_internal_has_v() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ARPlaneGeometry_TextureCoordinate::has_v() const {
  return _internal_has_v();
}
inline void ARPlaneGeometry_TextureCoordinate::clear_v() {
  v_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float ARPlaneGeometry_TextureCoordinate::_internal_v() const {
  return v_;
}
inline float ARPlaneGeometry_TextureCoordinate::v() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARPlaneGeometry.TextureCoordinate.v)
  return _internal_v();
}
inline void ARPlaneGeometry_TextureCoordinate::_internal_set_v(float value) {
  _has_bits_[0] |= 0x00000002u;
  v_ = value;
}
inline void ARPlaneGeometry_TextureCoordinate::set_v(float value) {
  _internal_set_v(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARPlaneGeometry.TextureCoordinate.v)
}

// -------------------------------------------------------------------

// ARPlaneGeometry

// repeated .mediapipe.ARPlaneGeometry.Vertex vertices = 1;
inline int ARPlaneGeometry::_internal_vertices_size() const {
  return vertices_.size();
}
inline int ARPlaneGeometry::vertices_size() const {
  return _internal_vertices_size();
}
inline void ARPlaneGeometry::clear_vertices() {
  vertices_.Clear();
}
inline ::mediapipe::ARPlaneGeometry_Vertex* ARPlaneGeometry::mutable_vertices(int index) {
  // @@protoc_insertion_point(field_mutable:mediapipe.ARPlaneGeometry.vertices)
  return vertices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARPlaneGeometry_Vertex >*
ARPlaneGeometry::mutable_vertices() {
  // @@protoc_insertion_point(field_mutable_list:mediapipe.ARPlaneGeometry.vertices)
  return &vertices_;
}
inline const ::mediapipe::ARPlaneGeometry_Vertex& ARPlaneGeometry::_internal_vertices(int index) const {
  return vertices_.Get(index);
}
inline const ::mediapipe::ARPlaneGeometry_Vertex& ARPlaneGeometry::vertices(int index) const {
  // @@protoc_insertion_point(field_get:mediapipe.ARPlaneGeometry.vertices)
  return _internal_vertices(index);
}
inline ::mediapipe::ARPlaneGeometry_Vertex* ARPlaneGeometry::_internal_add_vertices() {
  return vertices_.Add();
}
inline ::mediapipe::ARPlaneGeometry_Vertex* ARPlaneGeometry::add_vertices() {
  // @@protoc_insertion_point(field_add:mediapipe.ARPlaneGeometry.vertices)
  return _internal_add_vertices();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARPlaneGeometry_Vertex >&
ARPlaneGeometry::vertices() const {
  // @@protoc_insertion_point(field_list:mediapipe.ARPlaneGeometry.vertices)
  return vertices_;
}

// optional int32 vertex_count = 2;
inline bool ARPlaneGeometry::_internal_has_vertex_count() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ARPlaneGeometry::has_vertex_count() const {
  return _internal_has_vertex_count();
}
inline void ARPlaneGeometry::clear_vertex_count() {
  vertex_count_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ARPlaneGeometry::_internal_vertex_count() const {
  return vertex_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ARPlaneGeometry::vertex_count() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARPlaneGeometry.vertex_count)
  return _internal_vertex_count();
}
inline void ARPlaneGeometry::_internal_set_vertex_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  vertex_count_ = value;
}
inline void ARPlaneGeometry::set_vertex_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_vertex_count(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARPlaneGeometry.vertex_count)
}

// repeated .mediapipe.ARPlaneGeometry.TextureCoordinate texture_coordinates = 3;
inline int ARPlaneGeometry::_internal_texture_coordinates_size() const {
  return texture_coordinates_.size();
}
inline int ARPlaneGeometry::texture_coordinates_size() const {
  return _internal_texture_coordinates_size();
}
inline void ARPlaneGeometry::clear_texture_coordinates() {
  texture_coordinates_.Clear();
}
inline ::mediapipe::ARPlaneGeometry_TextureCoordinate* ARPlaneGeometry::mutable_texture_coordinates(int index) {
  // @@protoc_insertion_point(field_mutable:mediapipe.ARPlaneGeometry.texture_coordinates)
  return texture_coordinates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARPlaneGeometry_TextureCoordinate >*
ARPlaneGeometry::mutable_texture_coordinates() {
  // @@protoc_insertion_point(field_mutable_list:mediapipe.ARPlaneGeometry.texture_coordinates)
  return &texture_coordinates_;
}
inline const ::mediapipe::ARPlaneGeometry_TextureCoordinate& ARPlaneGeometry::_internal_texture_coordinates(int index) const {
  return texture_coordinates_.Get(index);
}
inline const ::mediapipe::ARPlaneGeometry_TextureCoordinate& ARPlaneGeometry::texture_coordinates(int index) const {
  // @@protoc_insertion_point(field_get:mediapipe.ARPlaneGeometry.texture_coordinates)
  return _internal_texture_coordinates(index);
}
inline ::mediapipe::ARPlaneGeometry_TextureCoordinate* ARPlaneGeometry::_internal_add_texture_coordinates() {
  return texture_coordinates_.Add();
}
inline ::mediapipe::ARPlaneGeometry_TextureCoordinate* ARPlaneGeometry::add_texture_coordinates() {
  // @@protoc_insertion_point(field_add:mediapipe.ARPlaneGeometry.texture_coordinates)
  return _internal_add_texture_coordinates();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARPlaneGeometry_TextureCoordinate >&
ARPlaneGeometry::texture_coordinates() const {
  // @@protoc_insertion_point(field_list:mediapipe.ARPlaneGeometry.texture_coordinates)
  return texture_coordinates_;
}

// optional int32 texture_coordinate_count = 4;
inline bool ARPlaneGeometry::_internal_has_texture_coordinate_count() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ARPlaneGeometry::has_texture_coordinate_count() const {
  return _internal_has_texture_coordinate_count();
}
inline void ARPlaneGeometry::clear_texture_coordinate_count() {
  texture_coordinate_count_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ARPlaneGeometry::_internal_texture_coordinate_count() const {
  return texture_coordinate_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ARPlaneGeometry::texture_coordinate_count() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARPlaneGeometry.texture_coordinate_count)
  return _internal_texture_coordinate_count();
}
inline void ARPlaneGeometry::_internal_set_texture_coordinate_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  texture_coordinate_count_ = value;
}
inline void ARPlaneGeometry::set_texture_coordinate_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_texture_coordinate_count(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARPlaneGeometry.texture_coordinate_count)
}

// repeated int32 triangle_indices = 5 [packed = true];
inline int ARPlaneGeometry::_internal_triangle_indices_size() const {
  return triangle_indices_.size();
}
inline int ARPlaneGeometry::triangle_indices_size() const {
  return _internal_triangle_indices_size();
}
inline void ARPlaneGeometry::clear_triangle_indices() {
  triangle_indices_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ARPlaneGeometry::_internal_triangle_indices(int index) const {
  return triangle_indices_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ARPlaneGeometry::triangle_indices(int index) const {
  // @@protoc_insertion_point(field_get:mediapipe.ARPlaneGeometry.triangle_indices)
  return _internal_triangle_indices(index);
}
inline void ARPlaneGeometry::set_triangle_indices(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  triangle_indices_.Set(index, value);
  // @@protoc_insertion_point(field_set:mediapipe.ARPlaneGeometry.triangle_indices)
}
inline void ARPlaneGeometry::_internal_add_triangle_indices(::PROTOBUF_NAMESPACE_ID::int32 value) {
  triangle_indices_.Add(value);
}
inline void ARPlaneGeometry::add_triangle_indices(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_triangle_indices(value);
  // @@protoc_insertion_point(field_add:mediapipe.ARPlaneGeometry.triangle_indices)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
ARPlaneGeometry::_internal_triangle_indices() const {
  return triangle_indices_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
ARPlaneGeometry::triangle_indices() const {
  // @@protoc_insertion_point(field_list:mediapipe.ARPlaneGeometry.triangle_indices)
  return _internal_triangle_indices();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
ARPlaneGeometry::_internal_mutable_triangle_indices() {
  return &triangle_indices_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
ARPlaneGeometry::mutable_triangle_indices() {
  // @@protoc_insertion_point(field_mutable_list:mediapipe.ARPlaneGeometry.triangle_indices)
  return _internal_mutable_triangle_indices();
}

// optional int32 triangle_count = 6;
inline bool ARPlaneGeometry::_internal_has_triangle_count() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ARPlaneGeometry::has_triangle_count() const {
  return _internal_has_triangle_count();
}
inline void ARPlaneGeometry::clear_triangle_count() {
  triangle_count_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ARPlaneGeometry::_internal_triangle_count() const {
  return triangle_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ARPlaneGeometry::triangle_count() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARPlaneGeometry.triangle_count)
  return _internal_triangle_count();
}
inline void ARPlaneGeometry::_internal_set_triangle_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  triangle_count_ = value;
}
inline void ARPlaneGeometry::set_triangle_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_triangle_count(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARPlaneGeometry.triangle_count)
}

// repeated .mediapipe.ARPlaneGeometry.Vertex boundary_vertices = 7;
inline int ARPlaneGeometry::_internal_boundary_vertices_size() const {
  return boundary_vertices_.size();
}
inline int ARPlaneGeometry::boundary_vertices_size() const {
  return _internal_boundary_vertices_size();
}
inline void ARPlaneGeometry::clear_boundary_vertices() {
  boundary_vertices_.Clear();
}
inline ::mediapipe::ARPlaneGeometry_Vertex* ARPlaneGeometry::mutable_boundary_vertices(int index) {
  // @@protoc_insertion_point(field_mutable:mediapipe.ARPlaneGeometry.boundary_vertices)
  return boundary_vertices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARPlaneGeometry_Vertex >*
ARPlaneGeometry::mutable_boundary_vertices() {
  // @@protoc_insertion_point(field_mutable_list:mediapipe.ARPlaneGeometry.boundary_vertices)
  return &boundary_vertices_;
}
inline const ::mediapipe::ARPlaneGeometry_Vertex& ARPlaneGeometry::_internal_boundary_vertices(int index) const {
  return boundary_vertices_.Get(index);
}
inline const ::mediapipe::ARPlaneGeometry_Vertex& ARPlaneGeometry::boundary_vertices(int index) const {
  // @@protoc_insertion_point(field_get:mediapipe.ARPlaneGeometry.boundary_vertices)
  return _internal_boundary_vertices(index);
}
inline ::mediapipe::ARPlaneGeometry_Vertex* ARPlaneGeometry::_internal_add_boundary_vertices() {
  return boundary_vertices_.Add();
}
inline ::mediapipe::ARPlaneGeometry_Vertex* ARPlaneGeometry::add_boundary_vertices() {
  // @@protoc_insertion_point(field_add:mediapipe.ARPlaneGeometry.boundary_vertices)
  return _internal_add_boundary_vertices();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARPlaneGeometry_Vertex >&
ARPlaneGeometry::boundary_vertices() const {
  // @@protoc_insertion_point(field_list:mediapipe.ARPlaneGeometry.boundary_vertices)
  return boundary_vertices_;
}

// optional int32 boundary_vertex_count = 8;
inline bool ARPlaneGeometry::_internal_has_boundary_vertex_count() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ARPlaneGeometry::has_boundary_vertex_count() const {
  return _internal_has_boundary_vertex_count();
}
inline void ARPlaneGeometry::clear_boundary_vertex_count() {
  boundary_vertex_count_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ARPlaneGeometry::_internal_boundary_vertex_count() const {
  return boundary_vertex_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ARPlaneGeometry::boundary_vertex_count() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARPlaneGeometry.boundary_vertex_count)
  return _internal_boundary_vertex_count();
}
inline void ARPlaneGeometry::_internal_set_boundary_vertex_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  boundary_vertex_count_ = value;
}
inline void ARPlaneGeometry::set_boundary_vertex_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_boundary_vertex_count(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARPlaneGeometry.boundary_vertex_count)
}

// -------------------------------------------------------------------

// ARPlaneAnchor_PlaneVector

// optional float x = 1;
inline bool ARPlaneAnchor_PlaneVector::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ARPlaneAnchor_PlaneVector::has_x() const {
  return _internal_has_x();
}
inline void ARPlaneAnchor_PlaneVector::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float ARPlaneAnchor_PlaneVector::_internal_x() const {
  return x_;
}
inline float ARPlaneAnchor_PlaneVector::x() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARPlaneAnchor.PlaneVector.x)
  return _internal_x();
}
inline void ARPlaneAnchor_PlaneVector::_internal_set_x(float value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void ARPlaneAnchor_PlaneVector::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARPlaneAnchor.PlaneVector.x)
}

// optional float y = 2;
inline bool ARPlaneAnchor_PlaneVector::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ARPlaneAnchor_PlaneVector::has_y() const {
  return _internal_has_y();
}
inline void ARPlaneAnchor_PlaneVector::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float ARPlaneAnchor_PlaneVector::_internal_y() const {
  return y_;
}
inline float ARPlaneAnchor_PlaneVector::y() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARPlaneAnchor.PlaneVector.y)
  return _internal_y();
}
inline void ARPlaneAnchor_PlaneVector::_internal_set_y(float value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void ARPlaneAnchor_PlaneVector::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARPlaneAnchor.PlaneVector.y)
}

// optional float z = 3;
inline bool ARPlaneAnchor_PlaneVector::_internal_has_z() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ARPlaneAnchor_PlaneVector::has_z() const {
  return _internal_has_z();
}
inline void ARPlaneAnchor_PlaneVector::clear_z() {
  z_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float ARPlaneAnchor_PlaneVector::_internal_z() const {
  return z_;
}
inline float ARPlaneAnchor_PlaneVector::z() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARPlaneAnchor.PlaneVector.z)
  return _internal_z();
}
inline void ARPlaneAnchor_PlaneVector::_internal_set_z(float value) {
  _has_bits_[0] |= 0x00000004u;
  z_ = value;
}
inline void ARPlaneAnchor_PlaneVector::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARPlaneAnchor.PlaneVector.z)
}

// -------------------------------------------------------------------

// ARPlaneAnchor

// optional string identifier = 1;
inline bool ARPlaneAnchor::_internal_has_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ARPlaneAnchor::has_identifier() const {
  return _internal_has_identifier();
}
inline void ARPlaneAnchor::clear_identifier() {
  identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ARPlaneAnchor::identifier() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARPlaneAnchor.identifier)
  return _internal_identifier();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void ARPlaneAnchor::set_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:mediapipe.ARPlaneAnchor.identifier)
}
inline std::string* ARPlaneAnchor::mutable_identifier() {
  // @@protoc_insertion_point(field_mutable:mediapipe.ARPlaneAnchor.identifier)
  return _internal_mutable_identifier();
}
inline const std::string& ARPlaneAnchor::_internal_identifier() const {
  return identifier_.Get();
}
inline void ARPlaneAnchor::_internal_set_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* ARPlaneAnchor::_internal_mutable_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ARPlaneAnchor::release_identifier() {
  // @@protoc_insertion_point(field_release:mediapipe.ARPlaneAnchor.identifier)
  if (!_internal_has_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ARPlaneAnchor::set_allocated_identifier(std::string* identifier) {
  if (identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), identifier,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mediapipe.ARPlaneAnchor.identifier)
}

// repeated float transform = 2;
inline int ARPlaneAnchor::_internal_transform_size() const {
  return transform_.size();
}
inline int ARPlaneAnchor::transform_size() const {
  return _internal_transform_size();
}
inline void ARPlaneAnchor::clear_transform() {
  transform_.Clear();
}
inline float ARPlaneAnchor::_internal_transform(int index) const {
  return transform_.Get(index);
}
inline float ARPlaneAnchor::transform(int index) const {
  // @@protoc_insertion_point(field_get:mediapipe.ARPlaneAnchor.transform)
  return _internal_transform(index);
}
inline void ARPlaneAnchor::set_transform(int index, float value) {
  transform_.Set(index, value);
  // @@protoc_insertion_point(field_set:mediapipe.ARPlaneAnchor.transform)
}
inline void ARPlaneAnchor::_internal_add_transform(float value) {
  transform_.Add(value);
}
inline void ARPlaneAnchor::add_transform(float value) {
  _internal_add_transform(value);
  // @@protoc_insertion_point(field_add:mediapipe.ARPlaneAnchor.transform)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ARPlaneAnchor::_internal_transform() const {
  return transform_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
ARPlaneAnchor::transform() const {
  // @@protoc_insertion_point(field_list:mediapipe.ARPlaneAnchor.transform)
  return _internal_transform();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ARPlaneAnchor::_internal_mutable_transform() {
  return &transform_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
ARPlaneAnchor::mutable_transform() {
  // @@protoc_insertion_point(field_mutable_list:mediapipe.ARPlaneAnchor.transform)
  return _internal_mutable_transform();
}

// optional .mediapipe.ARPlaneAnchor.Alignment alignment = 3;
inline bool ARPlaneAnchor::_internal_has_alignment() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ARPlaneAnchor::has_alignment() const {
  return _internal_has_alignment();
}
inline void ARPlaneAnchor::clear_alignment() {
  alignment_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::mediapipe::ARPlaneAnchor_Alignment ARPlaneAnchor::_internal_alignment() const {
  return static_cast< ::mediapipe::ARPlaneAnchor_Alignment >(alignment_);
}
inline ::mediapipe::ARPlaneAnchor_Alignment ARPlaneAnchor::alignment() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARPlaneAnchor.alignment)
  return _internal_alignment();
}
inline void ARPlaneAnchor::_internal_set_alignment(::mediapipe::ARPlaneAnchor_Alignment value) {
  assert(::mediapipe::ARPlaneAnchor_Alignment_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  alignment_ = value;
}
inline void ARPlaneAnchor::set_alignment(::mediapipe::ARPlaneAnchor_Alignment value) {
  _internal_set_alignment(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARPlaneAnchor.alignment)
}

// optional .mediapipe.ARPlaneGeometry geometry = 4;
inline bool ARPlaneAnchor::_internal_has_geometry() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || geometry_ != nullptr);
  return value;
}
inline bool ARPlaneAnchor::has_geometry() const {
  return _internal_has_geometry();
}
inline void ARPlaneAnchor::clear_geometry() {
  if (geometry_ != nullptr) geometry_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mediapipe::ARPlaneGeometry& ARPlaneAnchor::_internal_geometry() const {
  const ::mediapipe::ARPlaneGeometry* p = geometry_;
  return p != nullptr ? *p : reinterpret_cast<const ::mediapipe::ARPlaneGeometry&>(
      ::mediapipe::_ARPlaneGeometry_default_instance_);
}
inline const ::mediapipe::ARPlaneGeometry& ARPlaneAnchor::geometry() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARPlaneAnchor.geometry)
  return _internal_geometry();
}
inline void ARPlaneAnchor::unsafe_arena_set_allocated_geometry(
    ::mediapipe::ARPlaneGeometry* geometry) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(geometry_);
  }
  geometry_ = geometry;
  if (geometry) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mediapipe.ARPlaneAnchor.geometry)
}
inline ::mediapipe::ARPlaneGeometry* ARPlaneAnchor::release_geometry() {
  _has_bits_[0] &= ~0x00000002u;
  ::mediapipe::ARPlaneGeometry* temp = geometry_;
  geometry_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mediapipe::ARPlaneGeometry* ARPlaneAnchor::unsafe_arena_release_geometry() {
  // @@protoc_insertion_point(field_release:mediapipe.ARPlaneAnchor.geometry)
  _has_bits_[0] &= ~0x00000002u;
  ::mediapipe::ARPlaneGeometry* temp = geometry_;
  geometry_ = nullptr;
  return temp;
}
inline ::mediapipe::ARPlaneGeometry* ARPlaneAnchor::_internal_mutable_geometry() {
  _has_bits_[0] |= 0x00000002u;
  if (geometry_ == nullptr) {
    auto* p = CreateMaybeMessage<::mediapipe::ARPlaneGeometry>(GetArena());
    geometry_ = p;
  }
  return geometry_;
}
inline ::mediapipe::ARPlaneGeometry* ARPlaneAnchor::mutable_geometry() {
  // @@protoc_insertion_point(field_mutable:mediapipe.ARPlaneAnchor.geometry)
  return _internal_mutable_geometry();
}
inline void ARPlaneAnchor::set_allocated_geometry(::mediapipe::ARPlaneGeometry* geometry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete geometry_;
  }
  if (geometry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(geometry);
    if (message_arena != submessage_arena) {
      geometry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geometry, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  geometry_ = geometry;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.ARPlaneAnchor.geometry)
}

// optional .mediapipe.ARPlaneAnchor.PlaneVector center = 5;
inline bool ARPlaneAnchor::_internal_has_center() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || center_ != nullptr);
  return value;
}
inline bool ARPlaneAnchor::has_center() const {
  return _internal_has_center();
}
inline void ARPlaneAnchor::clear_center() {
  if (center_ != nullptr) center_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::mediapipe::ARPlaneAnchor_PlaneVector& ARPlaneAnchor::_internal_center() const {
  const ::mediapipe::ARPlaneAnchor_PlaneVector* p = center_;
  return p != nullptr ? *p : reinterpret_cast<const ::mediapipe::ARPlaneAnchor_PlaneVector&>(
      ::mediapipe::_ARPlaneAnchor_PlaneVector_default_instance_);
}
inline const ::mediapipe::ARPlaneAnchor_PlaneVector& ARPlaneAnchor::center() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARPlaneAnchor.center)
  return _internal_center();
}
inline void ARPlaneAnchor::unsafe_arena_set_allocated_center(
    ::mediapipe::ARPlaneAnchor_PlaneVector* center) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(center_);
  }
  center_ = center;
  if (center) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mediapipe.ARPlaneAnchor.center)
}
inline ::mediapipe::ARPlaneAnchor_PlaneVector* ARPlaneAnchor::release_center() {
  _has_bits_[0] &= ~0x00000004u;
  ::mediapipe::ARPlaneAnchor_PlaneVector* temp = center_;
  center_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mediapipe::ARPlaneAnchor_PlaneVector* ARPlaneAnchor::unsafe_arena_release_center() {
  // @@protoc_insertion_point(field_release:mediapipe.ARPlaneAnchor.center)
  _has_bits_[0] &= ~0x00000004u;
  ::mediapipe::ARPlaneAnchor_PlaneVector* temp = center_;
  center_ = nullptr;
  return temp;
}
inline ::mediapipe::ARPlaneAnchor_PlaneVector* ARPlaneAnchor::_internal_mutable_center() {
  _has_bits_[0] |= 0x00000004u;
  if (center_ == nullptr) {
    auto* p = CreateMaybeMessage<::mediapipe::ARPlaneAnchor_PlaneVector>(GetArena());
    center_ = p;
  }
  return center_;
}
inline ::mediapipe::ARPlaneAnchor_PlaneVector* ARPlaneAnchor::mutable_center() {
  // @@protoc_insertion_point(field_mutable:mediapipe.ARPlaneAnchor.center)
  return _internal_mutable_center();
}
inline void ARPlaneAnchor::set_allocated_center(::mediapipe::ARPlaneAnchor_PlaneVector* center) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete center_;
  }
  if (center) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(center);
    if (message_arena != submessage_arena) {
      center = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, center, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  center_ = center;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.ARPlaneAnchor.center)
}

// optional .mediapipe.ARPlaneAnchor.PlaneVector extent = 6;
inline bool ARPlaneAnchor::_internal_has_extent() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || extent_ != nullptr);
  return value;
}
inline bool ARPlaneAnchor::has_extent() const {
  return _internal_has_extent();
}
inline void ARPlaneAnchor::clear_extent() {
  if (extent_ != nullptr) extent_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::mediapipe::ARPlaneAnchor_PlaneVector& ARPlaneAnchor::_internal_extent() const {
  const ::mediapipe::ARPlaneAnchor_PlaneVector* p = extent_;
  return p != nullptr ? *p : reinterpret_cast<const ::mediapipe::ARPlaneAnchor_PlaneVector&>(
      ::mediapipe::_ARPlaneAnchor_PlaneVector_default_instance_);
}
inline const ::mediapipe::ARPlaneAnchor_PlaneVector& ARPlaneAnchor::extent() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARPlaneAnchor.extent)
  return _internal_extent();
}
inline void ARPlaneAnchor::unsafe_arena_set_allocated_extent(
    ::mediapipe::ARPlaneAnchor_PlaneVector* extent) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extent_);
  }
  extent_ = extent;
  if (extent) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mediapipe.ARPlaneAnchor.extent)
}
inline ::mediapipe::ARPlaneAnchor_PlaneVector* ARPlaneAnchor::release_extent() {
  _has_bits_[0] &= ~0x00000008u;
  ::mediapipe::ARPlaneAnchor_PlaneVector* temp = extent_;
  extent_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mediapipe::ARPlaneAnchor_PlaneVector* ARPlaneAnchor::unsafe_arena_release_extent() {
  // @@protoc_insertion_point(field_release:mediapipe.ARPlaneAnchor.extent)
  _has_bits_[0] &= ~0x00000008u;
  ::mediapipe::ARPlaneAnchor_PlaneVector* temp = extent_;
  extent_ = nullptr;
  return temp;
}
inline ::mediapipe::ARPlaneAnchor_PlaneVector* ARPlaneAnchor::_internal_mutable_extent() {
  _has_bits_[0] |= 0x00000008u;
  if (extent_ == nullptr) {
    auto* p = CreateMaybeMessage<::mediapipe::ARPlaneAnchor_PlaneVector>(GetArena());
    extent_ = p;
  }
  return extent_;
}
inline ::mediapipe::ARPlaneAnchor_PlaneVector* ARPlaneAnchor::mutable_extent() {
  // @@protoc_insertion_point(field_mutable:mediapipe.ARPlaneAnchor.extent)
  return _internal_mutable_extent();
}
inline void ARPlaneAnchor::set_allocated_extent(::mediapipe::ARPlaneAnchor_PlaneVector* extent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete extent_;
  }
  if (extent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(extent);
    if (message_arena != submessage_arena) {
      extent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extent, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  extent_ = extent;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.ARPlaneAnchor.extent)
}

// optional bool classification_supported = 7;
inline bool ARPlaneAnchor::_internal_has_classification_supported() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ARPlaneAnchor::has_classification_supported() const {
  return _internal_has_classification_supported();
}
inline void ARPlaneAnchor::clear_classification_supported() {
  classification_supported_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool ARPlaneAnchor::_internal_classification_supported() const {
  return classification_supported_;
}
inline bool ARPlaneAnchor::classification_supported() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARPlaneAnchor.classification_supported)
  return _internal_classification_supported();
}
inline void ARPlaneAnchor::_internal_set_classification_supported(bool value) {
  _has_bits_[0] |= 0x00000020u;
  classification_supported_ = value;
}
inline void ARPlaneAnchor::set_classification_supported(bool value) {
  _internal_set_classification_supported(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARPlaneAnchor.classification_supported)
}

// optional .mediapipe.ARPlaneAnchor.PlaneClassification classification = 8;
inline bool ARPlaneAnchor::_internal_has_classification() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ARPlaneAnchor::has_classification() const {
  return _internal_has_classification();
}
inline void ARPlaneAnchor::clear_classification() {
  classification_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::mediapipe::ARPlaneAnchor_PlaneClassification ARPlaneAnchor::_internal_classification() const {
  return static_cast< ::mediapipe::ARPlaneAnchor_PlaneClassification >(classification_);
}
inline ::mediapipe::ARPlaneAnchor_PlaneClassification ARPlaneAnchor::classification() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARPlaneAnchor.classification)
  return _internal_classification();
}
inline void ARPlaneAnchor::_internal_set_classification(::mediapipe::ARPlaneAnchor_PlaneClassification value) {
  assert(::mediapipe::ARPlaneAnchor_PlaneClassification_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  classification_ = value;
}
inline void ARPlaneAnchor::set_classification(::mediapipe::ARPlaneAnchor_PlaneClassification value) {
  _internal_set_classification(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARPlaneAnchor.classification)
}

// optional .mediapipe.ARPlaneAnchor.PlaneClassificationStatus classification_status = 9;
inline bool ARPlaneAnchor::_internal_has_classification_status() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ARPlaneAnchor::has_classification_status() const {
  return _internal_has_classification_status();
}
inline void ARPlaneAnchor::clear_classification_status() {
  classification_status_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::mediapipe::ARPlaneAnchor_PlaneClassificationStatus ARPlaneAnchor::_internal_classification_status() const {
  return static_cast< ::mediapipe::ARPlaneAnchor_PlaneClassificationStatus >(classification_status_);
}
inline ::mediapipe::ARPlaneAnchor_PlaneClassificationStatus ARPlaneAnchor::classification_status() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARPlaneAnchor.classification_status)
  return _internal_classification_status();
}
inline void ARPlaneAnchor::_internal_set_classification_status(::mediapipe::ARPlaneAnchor_PlaneClassificationStatus value) {
  assert(::mediapipe::ARPlaneAnchor_PlaneClassificationStatus_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  classification_status_ = value;
}
inline void ARPlaneAnchor::set_classification_status(::mediapipe::ARPlaneAnchor_PlaneClassificationStatus value) {
  _internal_set_classification_status(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARPlaneAnchor.classification_status)
}

// -------------------------------------------------------------------

// ARPointCloud_Point

// optional float x = 1;
inline bool ARPointCloud_Point::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ARPointCloud_Point::has_x() const {
  return _internal_has_x();
}
inline void ARPointCloud_Point::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float ARPointCloud_Point::_internal_x() const {
  return x_;
}
inline float ARPointCloud_Point::x() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARPointCloud.Point.x)
  return _internal_x();
}
inline void ARPointCloud_Point::_internal_set_x(float value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void ARPointCloud_Point::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARPointCloud.Point.x)
}

// optional float y = 2;
inline bool ARPointCloud_Point::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ARPointCloud_Point::has_y() const {
  return _internal_has_y();
}
inline void ARPointCloud_Point::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float ARPointCloud_Point::_internal_y() const {
  return y_;
}
inline float ARPointCloud_Point::y() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARPointCloud.Point.y)
  return _internal_y();
}
inline void ARPointCloud_Point::_internal_set_y(float value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void ARPointCloud_Point::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARPointCloud.Point.y)
}

// optional float z = 3;
inline bool ARPointCloud_Point::_internal_has_z() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ARPointCloud_Point::has_z() const {
  return _internal_has_z();
}
inline void ARPointCloud_Point::clear_z() {
  z_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float ARPointCloud_Point::_internal_z() const {
  return z_;
}
inline float ARPointCloud_Point::z() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARPointCloud.Point.z)
  return _internal_z();
}
inline void ARPointCloud_Point::_internal_set_z(float value) {
  _has_bits_[0] |= 0x00000004u;
  z_ = value;
}
inline void ARPointCloud_Point::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARPointCloud.Point.z)
}

// -------------------------------------------------------------------

// ARPointCloud

// optional int32 count = 1;
inline bool ARPointCloud::_internal_has_count() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ARPointCloud::has_count() const {
  return _internal_has_count();
}
inline void ARPointCloud::clear_count() {
  count_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ARPointCloud::_internal_count() const {
  return count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ARPointCloud::count() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARPointCloud.count)
  return _internal_count();
}
inline void ARPointCloud::_internal_set_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  count_ = value;
}
inline void ARPointCloud::set_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARPointCloud.count)
}

// repeated .mediapipe.ARPointCloud.Point point = 2;
inline int ARPointCloud::_internal_point_size() const {
  return point_.size();
}
inline int ARPointCloud::point_size() const {
  return _internal_point_size();
}
inline void ARPointCloud::clear_point() {
  point_.Clear();
}
inline ::mediapipe::ARPointCloud_Point* ARPointCloud::mutable_point(int index) {
  // @@protoc_insertion_point(field_mutable:mediapipe.ARPointCloud.point)
  return point_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARPointCloud_Point >*
ARPointCloud::mutable_point() {
  // @@protoc_insertion_point(field_mutable_list:mediapipe.ARPointCloud.point)
  return &point_;
}
inline const ::mediapipe::ARPointCloud_Point& ARPointCloud::_internal_point(int index) const {
  return point_.Get(index);
}
inline const ::mediapipe::ARPointCloud_Point& ARPointCloud::point(int index) const {
  // @@protoc_insertion_point(field_get:mediapipe.ARPointCloud.point)
  return _internal_point(index);
}
inline ::mediapipe::ARPointCloud_Point* ARPointCloud::_internal_add_point() {
  return point_.Add();
}
inline ::mediapipe::ARPointCloud_Point* ARPointCloud::add_point() {
  // @@protoc_insertion_point(field_add:mediapipe.ARPointCloud.point)
  return _internal_add_point();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARPointCloud_Point >&
ARPointCloud::point() const {
  // @@protoc_insertion_point(field_list:mediapipe.ARPointCloud.point)
  return point_;
}

// repeated int64 identifier = 3 [packed = true];
inline int ARPointCloud::_internal_identifier_size() const {
  return identifier_.size();
}
inline int ARPointCloud::identifier_size() const {
  return _internal_identifier_size();
}
inline void ARPointCloud::clear_identifier() {
  identifier_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ARPointCloud::_internal_identifier(int index) const {
  return identifier_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ARPointCloud::identifier(int index) const {
  // @@protoc_insertion_point(field_get:mediapipe.ARPointCloud.identifier)
  return _internal_identifier(index);
}
inline void ARPointCloud::set_identifier(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  identifier_.Set(index, value);
  // @@protoc_insertion_point(field_set:mediapipe.ARPointCloud.identifier)
}
inline void ARPointCloud::_internal_add_identifier(::PROTOBUF_NAMESPACE_ID::int64 value) {
  identifier_.Add(value);
}
inline void ARPointCloud::add_identifier(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_identifier(value);
  // @@protoc_insertion_point(field_add:mediapipe.ARPointCloud.identifier)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
ARPointCloud::_internal_identifier() const {
  return identifier_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
ARPointCloud::identifier() const {
  // @@protoc_insertion_point(field_list:mediapipe.ARPointCloud.identifier)
  return _internal_identifier();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
ARPointCloud::_internal_mutable_identifier() {
  return &identifier_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
ARPointCloud::mutable_identifier() {
  // @@protoc_insertion_point(field_mutable_list:mediapipe.ARPointCloud.identifier)
  return _internal_mutable_identifier();
}

// -------------------------------------------------------------------

// ARFrame

// optional double timestamp = 1;
inline bool ARFrame::_internal_has_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ARFrame::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void ARFrame::clear_timestamp() {
  timestamp_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double ARFrame::_internal_timestamp() const {
  return timestamp_;
}
inline double ARFrame::timestamp() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARFrame.timestamp)
  return _internal_timestamp();
}
inline void ARFrame::_internal_set_timestamp(double value) {
  _has_bits_[0] |= 0x00000020u;
  timestamp_ = value;
}
inline void ARFrame::set_timestamp(double value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARFrame.timestamp)
}

// optional .mediapipe.AVDepthData depth_data = 2;
inline bool ARFrame::_internal_has_depth_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || depth_data_ != nullptr);
  return value;
}
inline bool ARFrame::has_depth_data() const {
  return _internal_has_depth_data();
}
inline void ARFrame::clear_depth_data() {
  if (depth_data_ != nullptr) depth_data_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mediapipe::AVDepthData& ARFrame::_internal_depth_data() const {
  const ::mediapipe::AVDepthData* p = depth_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::mediapipe::AVDepthData&>(
      ::mediapipe::_AVDepthData_default_instance_);
}
inline const ::mediapipe::AVDepthData& ARFrame::depth_data() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARFrame.depth_data)
  return _internal_depth_data();
}
inline void ARFrame::unsafe_arena_set_allocated_depth_data(
    ::mediapipe::AVDepthData* depth_data) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(depth_data_);
  }
  depth_data_ = depth_data;
  if (depth_data) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mediapipe.ARFrame.depth_data)
}
inline ::mediapipe::AVDepthData* ARFrame::release_depth_data() {
  _has_bits_[0] &= ~0x00000001u;
  ::mediapipe::AVDepthData* temp = depth_data_;
  depth_data_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mediapipe::AVDepthData* ARFrame::unsafe_arena_release_depth_data() {
  // @@protoc_insertion_point(field_release:mediapipe.ARFrame.depth_data)
  _has_bits_[0] &= ~0x00000001u;
  ::mediapipe::AVDepthData* temp = depth_data_;
  depth_data_ = nullptr;
  return temp;
}
inline ::mediapipe::AVDepthData* ARFrame::_internal_mutable_depth_data() {
  _has_bits_[0] |= 0x00000001u;
  if (depth_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::mediapipe::AVDepthData>(GetArena());
    depth_data_ = p;
  }
  return depth_data_;
}
inline ::mediapipe::AVDepthData* ARFrame::mutable_depth_data() {
  // @@protoc_insertion_point(field_mutable:mediapipe.ARFrame.depth_data)
  return _internal_mutable_depth_data();
}
inline void ARFrame::set_allocated_depth_data(::mediapipe::AVDepthData* depth_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete depth_data_;
  }
  if (depth_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(depth_data);
    if (message_arena != submessage_arena) {
      depth_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, depth_data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  depth_data_ = depth_data;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.ARFrame.depth_data)
}

// optional double depth_data_timestamp = 3;
inline bool ARFrame::_internal_has_depth_data_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ARFrame::has_depth_data_timestamp() const {
  return _internal_has_depth_data_timestamp();
}
inline void ARFrame::clear_depth_data_timestamp() {
  depth_data_timestamp_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline double ARFrame::_internal_depth_data_timestamp() const {
  return depth_data_timestamp_;
}
inline double ARFrame::depth_data_timestamp() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARFrame.depth_data_timestamp)
  return _internal_depth_data_timestamp();
}
inline void ARFrame::_internal_set_depth_data_timestamp(double value) {
  _has_bits_[0] |= 0x00000040u;
  depth_data_timestamp_ = value;
}
inline void ARFrame::set_depth_data_timestamp(double value) {
  _internal_set_depth_data_timestamp(value);
  // @@protoc_insertion_point(field_set:mediapipe.ARFrame.depth_data_timestamp)
}

// optional .mediapipe.ARCamera camera = 4;
inline bool ARFrame::_internal_has_camera() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || camera_ != nullptr);
  return value;
}
inline bool ARFrame::has_camera() const {
  return _internal_has_camera();
}
inline void ARFrame::clear_camera() {
  if (camera_ != nullptr) camera_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mediapipe::ARCamera& ARFrame::_internal_camera() const {
  const ::mediapipe::ARCamera* p = camera_;
  return p != nullptr ? *p : reinterpret_cast<const ::mediapipe::ARCamera&>(
      ::mediapipe::_ARCamera_default_instance_);
}
inline const ::mediapipe::ARCamera& ARFrame::camera() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARFrame.camera)
  return _internal_camera();
}
inline void ARFrame::unsafe_arena_set_allocated_camera(
    ::mediapipe::ARCamera* camera) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(camera_);
  }
  camera_ = camera;
  if (camera) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mediapipe.ARFrame.camera)
}
inline ::mediapipe::ARCamera* ARFrame::release_camera() {
  _has_bits_[0] &= ~0x00000002u;
  ::mediapipe::ARCamera* temp = camera_;
  camera_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mediapipe::ARCamera* ARFrame::unsafe_arena_release_camera() {
  // @@protoc_insertion_point(field_release:mediapipe.ARFrame.camera)
  _has_bits_[0] &= ~0x00000002u;
  ::mediapipe::ARCamera* temp = camera_;
  camera_ = nullptr;
  return temp;
}
inline ::mediapipe::ARCamera* ARFrame::_internal_mutable_camera() {
  _has_bits_[0] |= 0x00000002u;
  if (camera_ == nullptr) {
    auto* p = CreateMaybeMessage<::mediapipe::ARCamera>(GetArena());
    camera_ = p;
  }
  return camera_;
}
inline ::mediapipe::ARCamera* ARFrame::mutable_camera() {
  // @@protoc_insertion_point(field_mutable:mediapipe.ARFrame.camera)
  return _internal_mutable_camera();
}
inline void ARFrame::set_allocated_camera(::mediapipe::ARCamera* camera) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete camera_;
  }
  if (camera) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(camera);
    if (message_arena != submessage_arena) {
      camera = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  camera_ = camera;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.ARFrame.camera)
}

// optional .mediapipe.ARLightEstimate light_estimate = 5;
inline bool ARFrame::_internal_has_light_estimate() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || light_estimate_ != nullptr);
  return value;
}
inline bool ARFrame::has_light_estimate() const {
  return _internal_has_light_estimate();
}
inline void ARFrame::clear_light_estimate() {
  if (light_estimate_ != nullptr) light_estimate_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::mediapipe::ARLightEstimate& ARFrame::_internal_light_estimate() const {
  const ::mediapipe::ARLightEstimate* p = light_estimate_;
  return p != nullptr ? *p : reinterpret_cast<const ::mediapipe::ARLightEstimate&>(
      ::mediapipe::_ARLightEstimate_default_instance_);
}
inline const ::mediapipe::ARLightEstimate& ARFrame::light_estimate() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARFrame.light_estimate)
  return _internal_light_estimate();
}
inline void ARFrame::unsafe_arena_set_allocated_light_estimate(
    ::mediapipe::ARLightEstimate* light_estimate) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(light_estimate_);
  }
  light_estimate_ = light_estimate;
  if (light_estimate) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mediapipe.ARFrame.light_estimate)
}
inline ::mediapipe::ARLightEstimate* ARFrame::release_light_estimate() {
  _has_bits_[0] &= ~0x00000004u;
  ::mediapipe::ARLightEstimate* temp = light_estimate_;
  light_estimate_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mediapipe::ARLightEstimate* ARFrame::unsafe_arena_release_light_estimate() {
  // @@protoc_insertion_point(field_release:mediapipe.ARFrame.light_estimate)
  _has_bits_[0] &= ~0x00000004u;
  ::mediapipe::ARLightEstimate* temp = light_estimate_;
  light_estimate_ = nullptr;
  return temp;
}
inline ::mediapipe::ARLightEstimate* ARFrame::_internal_mutable_light_estimate() {
  _has_bits_[0] |= 0x00000004u;
  if (light_estimate_ == nullptr) {
    auto* p = CreateMaybeMessage<::mediapipe::ARLightEstimate>(GetArena());
    light_estimate_ = p;
  }
  return light_estimate_;
}
inline ::mediapipe::ARLightEstimate* ARFrame::mutable_light_estimate() {
  // @@protoc_insertion_point(field_mutable:mediapipe.ARFrame.light_estimate)
  return _internal_mutable_light_estimate();
}
inline void ARFrame::set_allocated_light_estimate(::mediapipe::ARLightEstimate* light_estimate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete light_estimate_;
  }
  if (light_estimate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(light_estimate);
    if (message_arena != submessage_arena) {
      light_estimate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, light_estimate, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  light_estimate_ = light_estimate;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.ARFrame.light_estimate)
}

// optional .mediapipe.ARFaceAnchor face_anchor = 6;
inline bool ARFrame::_internal_has_face_anchor() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || face_anchor_ != nullptr);
  return value;
}
inline bool ARFrame::has_face_anchor() const {
  return _internal_has_face_anchor();
}
inline void ARFrame::clear_face_anchor() {
  if (face_anchor_ != nullptr) face_anchor_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::mediapipe::ARFaceAnchor& ARFrame::_internal_face_anchor() const {
  const ::mediapipe::ARFaceAnchor* p = face_anchor_;
  return p != nullptr ? *p : reinterpret_cast<const ::mediapipe::ARFaceAnchor&>(
      ::mediapipe::_ARFaceAnchor_default_instance_);
}
inline const ::mediapipe::ARFaceAnchor& ARFrame::face_anchor() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARFrame.face_anchor)
  return _internal_face_anchor();
}
inline void ARFrame::unsafe_arena_set_allocated_face_anchor(
    ::mediapipe::ARFaceAnchor* face_anchor) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(face_anchor_);
  }
  face_anchor_ = face_anchor;
  if (face_anchor) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mediapipe.ARFrame.face_anchor)
}
inline ::mediapipe::ARFaceAnchor* ARFrame::release_face_anchor() {
  _has_bits_[0] &= ~0x00000008u;
  ::mediapipe::ARFaceAnchor* temp = face_anchor_;
  face_anchor_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mediapipe::ARFaceAnchor* ARFrame::unsafe_arena_release_face_anchor() {
  // @@protoc_insertion_point(field_release:mediapipe.ARFrame.face_anchor)
  _has_bits_[0] &= ~0x00000008u;
  ::mediapipe::ARFaceAnchor* temp = face_anchor_;
  face_anchor_ = nullptr;
  return temp;
}
inline ::mediapipe::ARFaceAnchor* ARFrame::_internal_mutable_face_anchor() {
  _has_bits_[0] |= 0x00000008u;
  if (face_anchor_ == nullptr) {
    auto* p = CreateMaybeMessage<::mediapipe::ARFaceAnchor>(GetArena());
    face_anchor_ = p;
  }
  return face_anchor_;
}
inline ::mediapipe::ARFaceAnchor* ARFrame::mutable_face_anchor() {
  // @@protoc_insertion_point(field_mutable:mediapipe.ARFrame.face_anchor)
  return _internal_mutable_face_anchor();
}
inline void ARFrame::set_allocated_face_anchor(::mediapipe::ARFaceAnchor* face_anchor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete face_anchor_;
  }
  if (face_anchor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(face_anchor);
    if (message_arena != submessage_arena) {
      face_anchor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, face_anchor, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  face_anchor_ = face_anchor;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.ARFrame.face_anchor)
}

// repeated .mediapipe.ARPlaneAnchor plane_anchor = 7;
inline int ARFrame::_internal_plane_anchor_size() const {
  return plane_anchor_.size();
}
inline int ARFrame::plane_anchor_size() const {
  return _internal_plane_anchor_size();
}
inline void ARFrame::clear_plane_anchor() {
  plane_anchor_.Clear();
}
inline ::mediapipe::ARPlaneAnchor* ARFrame::mutable_plane_anchor(int index) {
  // @@protoc_insertion_point(field_mutable:mediapipe.ARFrame.plane_anchor)
  return plane_anchor_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARPlaneAnchor >*
ARFrame::mutable_plane_anchor() {
  // @@protoc_insertion_point(field_mutable_list:mediapipe.ARFrame.plane_anchor)
  return &plane_anchor_;
}
inline const ::mediapipe::ARPlaneAnchor& ARFrame::_internal_plane_anchor(int index) const {
  return plane_anchor_.Get(index);
}
inline const ::mediapipe::ARPlaneAnchor& ARFrame::plane_anchor(int index) const {
  // @@protoc_insertion_point(field_get:mediapipe.ARFrame.plane_anchor)
  return _internal_plane_anchor(index);
}
inline ::mediapipe::ARPlaneAnchor* ARFrame::_internal_add_plane_anchor() {
  return plane_anchor_.Add();
}
inline ::mediapipe::ARPlaneAnchor* ARFrame::add_plane_anchor() {
  // @@protoc_insertion_point(field_add:mediapipe.ARFrame.plane_anchor)
  return _internal_add_plane_anchor();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::ARPlaneAnchor >&
ARFrame::plane_anchor() const {
  // @@protoc_insertion_point(field_list:mediapipe.ARFrame.plane_anchor)
  return plane_anchor_;
}

// optional .mediapipe.ARPointCloud raw_feature_points = 8;
inline bool ARFrame::_internal_has_raw_feature_points() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || raw_feature_points_ != nullptr);
  return value;
}
inline bool ARFrame::has_raw_feature_points() const {
  return _internal_has_raw_feature_points();
}
inline void ARFrame::clear_raw_feature_points() {
  if (raw_feature_points_ != nullptr) raw_feature_points_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::mediapipe::ARPointCloud& ARFrame::_internal_raw_feature_points() const {
  const ::mediapipe::ARPointCloud* p = raw_feature_points_;
  return p != nullptr ? *p : reinterpret_cast<const ::mediapipe::ARPointCloud&>(
      ::mediapipe::_ARPointCloud_default_instance_);
}
inline const ::mediapipe::ARPointCloud& ARFrame::raw_feature_points() const {
  // @@protoc_insertion_point(field_get:mediapipe.ARFrame.raw_feature_points)
  return _internal_raw_feature_points();
}
inline void ARFrame::unsafe_arena_set_allocated_raw_feature_points(
    ::mediapipe::ARPointCloud* raw_feature_points) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(raw_feature_points_);
  }
  raw_feature_points_ = raw_feature_points;
  if (raw_feature_points) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mediapipe.ARFrame.raw_feature_points)
}
inline ::mediapipe::ARPointCloud* ARFrame::release_raw_feature_points() {
  _has_bits_[0] &= ~0x00000010u;
  ::mediapipe::ARPointCloud* temp = raw_feature_points_;
  raw_feature_points_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mediapipe::ARPointCloud* ARFrame::unsafe_arena_release_raw_feature_points() {
  // @@protoc_insertion_point(field_release:mediapipe.ARFrame.raw_feature_points)
  _has_bits_[0] &= ~0x00000010u;
  ::mediapipe::ARPointCloud* temp = raw_feature_points_;
  raw_feature_points_ = nullptr;
  return temp;
}
inline ::mediapipe::ARPointCloud* ARFrame::_internal_mutable_raw_feature_points() {
  _has_bits_[0] |= 0x00000010u;
  if (raw_feature_points_ == nullptr) {
    auto* p = CreateMaybeMessage<::mediapipe::ARPointCloud>(GetArena());
    raw_feature_points_ = p;
  }
  return raw_feature_points_;
}
inline ::mediapipe::ARPointCloud* ARFrame::mutable_raw_feature_points() {
  // @@protoc_insertion_point(field_mutable:mediapipe.ARFrame.raw_feature_points)
  return _internal_mutable_raw_feature_points();
}
inline void ARFrame::set_allocated_raw_feature_points(::mediapipe::ARPointCloud* raw_feature_points) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete raw_feature_points_;
  }
  if (raw_feature_points) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(raw_feature_points);
    if (message_arena != submessage_arena) {
      raw_feature_points = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, raw_feature_points, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  raw_feature_points_ = raw_feature_points;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.ARFrame.raw_feature_points)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mediapipe

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::mediapipe::AVDepthData_Accuracy> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mediapipe::AVDepthData_Accuracy>() {
  return ::mediapipe::AVDepthData_Accuracy_descriptor();
}
template <> struct is_proto_enum< ::mediapipe::AVDepthData_Quality> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mediapipe::AVDepthData_Quality>() {
  return ::mediapipe::AVDepthData_Quality_descriptor();
}
template <> struct is_proto_enum< ::mediapipe::ARCamera_TrackingState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mediapipe::ARCamera_TrackingState>() {
  return ::mediapipe::ARCamera_TrackingState_descriptor();
}
template <> struct is_proto_enum< ::mediapipe::ARCamera_TrackingStateReason> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mediapipe::ARCamera_TrackingStateReason>() {
  return ::mediapipe::ARCamera_TrackingStateReason_descriptor();
}
template <> struct is_proto_enum< ::mediapipe::ARPlaneAnchor_Alignment> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mediapipe::ARPlaneAnchor_Alignment>() {
  return ::mediapipe::ARPlaneAnchor_Alignment_descriptor();
}
template <> struct is_proto_enum< ::mediapipe::ARPlaneAnchor_PlaneClassification> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mediapipe::ARPlaneAnchor_PlaneClassification>() {
  return ::mediapipe::ARPlaneAnchor_PlaneClassification_descriptor();
}
template <> struct is_proto_enum< ::mediapipe::ARPlaneAnchor_PlaneClassificationStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mediapipe::ARPlaneAnchor_PlaneClassificationStatus>() {
  return ::mediapipe::ARPlaneAnchor_PlaneClassificationStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_mediapipe_2fmodules_2fobjectron_2fcalculators_2fa_5fr_5fcapture_5fmetadata_2eproto
