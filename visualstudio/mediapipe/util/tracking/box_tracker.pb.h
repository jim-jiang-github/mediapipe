// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mediapipe/util/tracking/box_tracker.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_mediapipe_2futil_2ftracking_2fbox_5ftracker_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_mediapipe_2futil_2ftracking_2fbox_5ftracker_2eproto

#include <limits>
#include <string>

#include <x/google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3015000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3015008 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <x/google/protobuf/port_undef.inc>
#include <x/google/protobuf/io/coded_stream.h>
#include <x/google/protobuf/arena.h>
#include <x/google/protobuf/arenastring.h>
#include <x/google/protobuf/generated_message_table_driven.h>
#include <x/google/protobuf/generated_message_util.h>
#include <x/google/protobuf/metadata_lite.h>
#include <x/google/protobuf/generated_message_reflection.h>
#include <x/google/protobuf/message.h>
#include <x/google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <x/google/protobuf/extension_set.h>  // IWYU pragma: export
#include <x/google/protobuf/unknown_field_set.h>
#include "mediapipe/util/tracking/tracking.pb.h"
// @@protoc_insertion_point(includes)
#include <x/google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_mediapipe_2futil_2ftracking_2fbox_5ftracker_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_mediapipe_2futil_2ftracking_2fbox_5ftracker_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[3]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_mediapipe_2futil_2ftracking_2fbox_5ftracker_2eproto;
namespace mediapipe {
class BoxTrackerOptions;
struct BoxTrackerOptionsDefaultTypeInternal;
extern BoxTrackerOptionsDefaultTypeInternal _BoxTrackerOptions_default_instance_;
class TimedBoxProto;
struct TimedBoxProtoDefaultTypeInternal;
extern TimedBoxProtoDefaultTypeInternal _TimedBoxProto_default_instance_;
class TimedBoxProtoList;
struct TimedBoxProtoListDefaultTypeInternal;
extern TimedBoxProtoListDefaultTypeInternal _TimedBoxProtoList_default_instance_;
}  // namespace mediapipe
PROTOBUF_NAMESPACE_OPEN
template<> ::mediapipe::BoxTrackerOptions* Arena::CreateMaybeMessage<::mediapipe::BoxTrackerOptions>(Arena*);
template<> ::mediapipe::TimedBoxProto* Arena::CreateMaybeMessage<::mediapipe::TimedBoxProto>(Arena*);
template<> ::mediapipe::TimedBoxProtoList* Arena::CreateMaybeMessage<::mediapipe::TimedBoxProtoList>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mediapipe {

// ===================================================================

class BoxTrackerOptions PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.BoxTrackerOptions) */ {
 public:
  inline BoxTrackerOptions() : BoxTrackerOptions(nullptr) {}
  ~BoxTrackerOptions() override;
  explicit constexpr BoxTrackerOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BoxTrackerOptions(const BoxTrackerOptions& from);
  BoxTrackerOptions(BoxTrackerOptions&& from) noexcept
    : BoxTrackerOptions() {
    *this = ::std::move(from);
  }

  inline BoxTrackerOptions& operator=(const BoxTrackerOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoxTrackerOptions& operator=(BoxTrackerOptions&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoxTrackerOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoxTrackerOptions* internal_default_instance() {
    return reinterpret_cast<const BoxTrackerOptions*>(
               &_BoxTrackerOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(BoxTrackerOptions& a, BoxTrackerOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(BoxTrackerOptions* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoxTrackerOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BoxTrackerOptions* New() const final {
    return CreateMaybeMessage<BoxTrackerOptions>(nullptr);
  }

  BoxTrackerOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BoxTrackerOptions>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BoxTrackerOptions& from);
  void MergeFrom(const BoxTrackerOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoxTrackerOptions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.BoxTrackerOptions";
  }
  protected:
  explicit BoxTrackerOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCacheFileFormatFieldNumber = 2,
    kTrackStepOptionsFieldNumber = 6,
    kRecordPathStatesFieldNumber = 5,
    kReadChunkTimeoutMsecFieldNumber = 4,
    kCachingChunkSizeMsecFieldNumber = 1,
    kNumTrackingWorkersFieldNumber = 3,
  };
  // optional string cache_file_format = 2 [default = "chunk_%04d"];
  bool has_cache_file_format() const;
  private:
  bool _internal_has_cache_file_format() const;
  public:
  void clear_cache_file_format();
  const std::string& cache_file_format() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cache_file_format(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cache_file_format();
  std::string* release_cache_file_format();
  void set_allocated_cache_file_format(std::string* cache_file_format);
  private:
  const std::string& _internal_cache_file_format() const;
  void _internal_set_cache_file_format(const std::string& value);
  std::string* _internal_mutable_cache_file_format();
  public:

  // optional .mediapipe.TrackStepOptions track_step_options = 6;
  bool has_track_step_options() const;
  private:
  bool _internal_has_track_step_options() const;
  public:
  void clear_track_step_options();
  const ::mediapipe::TrackStepOptions& track_step_options() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::mediapipe::TrackStepOptions* release_track_step_options();
  ::mediapipe::TrackStepOptions* mutable_track_step_options();
  void set_allocated_track_step_options(::mediapipe::TrackStepOptions* track_step_options);
  private:
  const ::mediapipe::TrackStepOptions& _internal_track_step_options() const;
  ::mediapipe::TrackStepOptions* _internal_mutable_track_step_options();
  public:
  void unsafe_arena_set_allocated_track_step_options(
      ::mediapipe::TrackStepOptions* track_step_options);
  ::mediapipe::TrackStepOptions* unsafe_arena_release_track_step_options();

  // optional bool record_path_states = 5 [default = false];
  bool has_record_path_states() const;
  private:
  bool _internal_has_record_path_states() const;
  public:
  void clear_record_path_states();
  bool record_path_states() const;
  void set_record_path_states(bool value);
  private:
  bool _internal_record_path_states() const;
  void _internal_set_record_path_states(bool value);
  public:

  // optional int32 read_chunk_timeout_msec = 4 [default = 60000];
  bool has_read_chunk_timeout_msec() const;
  private:
  bool _internal_has_read_chunk_timeout_msec() const;
  public:
  void clear_read_chunk_timeout_msec();
  ::PROTOBUF_NAMESPACE_ID::int32 read_chunk_timeout_msec() const;
  void set_read_chunk_timeout_msec(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_read_chunk_timeout_msec() const;
  void _internal_set_read_chunk_timeout_msec(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 caching_chunk_size_msec = 1 [default = 2500];
  bool has_caching_chunk_size_msec() const;
  private:
  bool _internal_has_caching_chunk_size_msec() const;
  public:
  void clear_caching_chunk_size_msec();
  ::PROTOBUF_NAMESPACE_ID::int32 caching_chunk_size_msec() const;
  void set_caching_chunk_size_msec(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_caching_chunk_size_msec() const;
  void _internal_set_caching_chunk_size_msec(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 num_tracking_workers = 3 [default = 8];
  bool has_num_tracking_workers() const;
  private:
  bool _internal_has_num_tracking_workers() const;
  public:
  void clear_num_tracking_workers();
  ::PROTOBUF_NAMESPACE_ID::int32 num_tracking_workers() const;
  void set_num_tracking_workers(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_tracking_workers() const;
  void _internal_set_num_tracking_workers(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:mediapipe.BoxTrackerOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_cache_file_format_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cache_file_format_;
  ::mediapipe::TrackStepOptions* track_step_options_;
  bool record_path_states_;
  ::PROTOBUF_NAMESPACE_ID::int32 read_chunk_timeout_msec_;
  ::PROTOBUF_NAMESPACE_ID::int32 caching_chunk_size_msec_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_tracking_workers_;
  friend struct ::TableStruct_mediapipe_2futil_2ftracking_2fbox_5ftracker_2eproto;
};
// -------------------------------------------------------------------

class TimedBoxProto PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.TimedBoxProto) */ {
 public:
  inline TimedBoxProto() : TimedBoxProto(nullptr) {}
  ~TimedBoxProto() override;
  explicit constexpr TimedBoxProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimedBoxProto(const TimedBoxProto& from);
  TimedBoxProto(TimedBoxProto&& from) noexcept
    : TimedBoxProto() {
    *this = ::std::move(from);
  }

  inline TimedBoxProto& operator=(const TimedBoxProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimedBoxProto& operator=(TimedBoxProto&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimedBoxProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimedBoxProto* internal_default_instance() {
    return reinterpret_cast<const TimedBoxProto*>(
               &_TimedBoxProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TimedBoxProto& a, TimedBoxProto& b) {
    a.Swap(&b);
  }
  inline void Swap(TimedBoxProto* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimedBoxProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TimedBoxProto* New() const final {
    return CreateMaybeMessage<TimedBoxProto>(nullptr);
  }

  TimedBoxProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TimedBoxProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TimedBoxProto& from);
  void MergeFrom(const TimedBoxProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimedBoxProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.TimedBoxProto";
  }
  protected:
  explicit TimedBoxProto(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLabelFieldNumber = 13,
    kQuadFieldNumber = 9,
    kTopFieldNumber = 1,
    kLeftFieldNumber = 2,
    kBottomFieldNumber = 3,
    kRightFieldNumber = 4,
    kTimeMsecFieldNumber = 5,
    kRotationFieldNumber = 7,
    kConfidenceFieldNumber = 8,
    kAspectRatioFieldNumber = 10,
    kReacquisitionFieldNumber = 11,
    kRequestGroupingFieldNumber = 12,
    kIdFieldNumber = 6,
  };
  // optional string label = 13;
  bool has_label() const;
  private:
  bool _internal_has_label() const;
  public:
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // optional .mediapipe.MotionBoxState.Quad quad = 9;
  bool has_quad() const;
  private:
  bool _internal_has_quad() const;
  public:
  void clear_quad();
  const ::mediapipe::MotionBoxState_Quad& quad() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::mediapipe::MotionBoxState_Quad* release_quad();
  ::mediapipe::MotionBoxState_Quad* mutable_quad();
  void set_allocated_quad(::mediapipe::MotionBoxState_Quad* quad);
  private:
  const ::mediapipe::MotionBoxState_Quad& _internal_quad() const;
  ::mediapipe::MotionBoxState_Quad* _internal_mutable_quad();
  public:
  void unsafe_arena_set_allocated_quad(
      ::mediapipe::MotionBoxState_Quad* quad);
  ::mediapipe::MotionBoxState_Quad* unsafe_arena_release_quad();

  // optional float top = 1;
  bool has_top() const;
  private:
  bool _internal_has_top() const;
  public:
  void clear_top();
  float top() const;
  void set_top(float value);
  private:
  float _internal_top() const;
  void _internal_set_top(float value);
  public:

  // optional float left = 2;
  bool has_left() const;
  private:
  bool _internal_has_left() const;
  public:
  void clear_left();
  float left() const;
  void set_left(float value);
  private:
  float _internal_left() const;
  void _internal_set_left(float value);
  public:

  // optional float bottom = 3;
  bool has_bottom() const;
  private:
  bool _internal_has_bottom() const;
  public:
  void clear_bottom();
  float bottom() const;
  void set_bottom(float value);
  private:
  float _internal_bottom() const;
  void _internal_set_bottom(float value);
  public:

  // optional float right = 4;
  bool has_right() const;
  private:
  bool _internal_has_right() const;
  public:
  void clear_right();
  float right() const;
  void set_right(float value);
  private:
  float _internal_right() const;
  void _internal_set_right(float value);
  public:

  // optional int64 time_msec = 5 [default = 0];
  bool has_time_msec() const;
  private:
  bool _internal_has_time_msec() const;
  public:
  void clear_time_msec();
  ::PROTOBUF_NAMESPACE_ID::int64 time_msec() const;
  void set_time_msec(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_time_msec() const;
  void _internal_set_time_msec(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional float rotation = 7;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  float rotation() const;
  void set_rotation(float value);
  private:
  float _internal_rotation() const;
  void _internal_set_rotation(float value);
  public:

  // optional float confidence = 8;
  bool has_confidence() const;
  private:
  bool _internal_has_confidence() const;
  public:
  void clear_confidence();
  float confidence() const;
  void set_confidence(float value);
  private:
  float _internal_confidence() const;
  void _internal_set_confidence(float value);
  public:

  // optional float aspect_ratio = 10;
  bool has_aspect_ratio() const;
  private:
  bool _internal_has_aspect_ratio() const;
  public:
  void clear_aspect_ratio();
  float aspect_ratio() const;
  void set_aspect_ratio(float value);
  private:
  float _internal_aspect_ratio() const;
  void _internal_set_aspect_ratio(float value);
  public:

  // optional bool reacquisition = 11 [default = false];
  bool has_reacquisition() const;
  private:
  bool _internal_has_reacquisition() const;
  public:
  void clear_reacquisition();
  bool reacquisition() const;
  void set_reacquisition(bool value);
  private:
  bool _internal_reacquisition() const;
  void _internal_set_reacquisition(bool value);
  public:

  // optional bool request_grouping = 12 [default = false];
  bool has_request_grouping() const;
  private:
  bool _internal_has_request_grouping() const;
  public:
  void clear_request_grouping();
  bool request_grouping() const;
  void set_request_grouping(bool value);
  private:
  bool _internal_request_grouping() const;
  void _internal_set_request_grouping(bool value);
  public:

  // optional int32 id = 6 [default = -1];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:mediapipe.TimedBoxProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
  ::mediapipe::MotionBoxState_Quad* quad_;
  float top_;
  float left_;
  float bottom_;
  float right_;
  ::PROTOBUF_NAMESPACE_ID::int64 time_msec_;
  float rotation_;
  float confidence_;
  float aspect_ratio_;
  bool reacquisition_;
  bool request_grouping_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  friend struct ::TableStruct_mediapipe_2futil_2ftracking_2fbox_5ftracker_2eproto;
};
// -------------------------------------------------------------------

class TimedBoxProtoList PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.TimedBoxProtoList) */ {
 public:
  inline TimedBoxProtoList() : TimedBoxProtoList(nullptr) {}
  ~TimedBoxProtoList() override;
  explicit constexpr TimedBoxProtoList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimedBoxProtoList(const TimedBoxProtoList& from);
  TimedBoxProtoList(TimedBoxProtoList&& from) noexcept
    : TimedBoxProtoList() {
    *this = ::std::move(from);
  }

  inline TimedBoxProtoList& operator=(const TimedBoxProtoList& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimedBoxProtoList& operator=(TimedBoxProtoList&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimedBoxProtoList& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimedBoxProtoList* internal_default_instance() {
    return reinterpret_cast<const TimedBoxProtoList*>(
               &_TimedBoxProtoList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TimedBoxProtoList& a, TimedBoxProtoList& b) {
    a.Swap(&b);
  }
  inline void Swap(TimedBoxProtoList* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimedBoxProtoList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TimedBoxProtoList* New() const final {
    return CreateMaybeMessage<TimedBoxProtoList>(nullptr);
  }

  TimedBoxProtoList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TimedBoxProtoList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TimedBoxProtoList& from);
  void MergeFrom(const TimedBoxProtoList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimedBoxProtoList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.TimedBoxProtoList";
  }
  protected:
  explicit TimedBoxProtoList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoxFieldNumber = 1,
  };
  // repeated .mediapipe.TimedBoxProto box = 1;
  int box_size() const;
  private:
  int _internal_box_size() const;
  public:
  void clear_box();
  ::mediapipe::TimedBoxProto* mutable_box(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::TimedBoxProto >*
      mutable_box();
  private:
  const ::mediapipe::TimedBoxProto& _internal_box(int index) const;
  ::mediapipe::TimedBoxProto* _internal_add_box();
  public:
  const ::mediapipe::TimedBoxProto& box(int index) const;
  ::mediapipe::TimedBoxProto* add_box();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::TimedBoxProto >&
      box() const;

  // @@protoc_insertion_point(class_scope:mediapipe.TimedBoxProtoList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::TimedBoxProto > box_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mediapipe_2futil_2ftracking_2fbox_5ftracker_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BoxTrackerOptions

// optional int32 caching_chunk_size_msec = 1 [default = 2500];
inline bool BoxTrackerOptions::_internal_has_caching_chunk_size_msec() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BoxTrackerOptions::has_caching_chunk_size_msec() const {
  return _internal_has_caching_chunk_size_msec();
}
inline void BoxTrackerOptions::clear_caching_chunk_size_msec() {
  caching_chunk_size_msec_ = 2500;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BoxTrackerOptions::_internal_caching_chunk_size_msec() const {
  return caching_chunk_size_msec_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BoxTrackerOptions::caching_chunk_size_msec() const {
  // @@protoc_insertion_point(field_get:mediapipe.BoxTrackerOptions.caching_chunk_size_msec)
  return _internal_caching_chunk_size_msec();
}
inline void BoxTrackerOptions::_internal_set_caching_chunk_size_msec(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  caching_chunk_size_msec_ = value;
}
inline void BoxTrackerOptions::set_caching_chunk_size_msec(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_caching_chunk_size_msec(value);
  // @@protoc_insertion_point(field_set:mediapipe.BoxTrackerOptions.caching_chunk_size_msec)
}

// optional string cache_file_format = 2 [default = "chunk_%04d"];
inline bool BoxTrackerOptions::_internal_has_cache_file_format() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BoxTrackerOptions::has_cache_file_format() const {
  return _internal_has_cache_file_format();
}
inline void BoxTrackerOptions::clear_cache_file_format() {
  cache_file_format_.ClearToDefault(::mediapipe::BoxTrackerOptions::_i_give_permission_to_break_this_code_default_cache_file_format_, GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BoxTrackerOptions::cache_file_format() const {
  // @@protoc_insertion_point(field_get:mediapipe.BoxTrackerOptions.cache_file_format)
  if (cache_file_format_.IsDefault(nullptr)) return _i_give_permission_to_break_this_code_default_cache_file_format_.get();
  return _internal_cache_file_format();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void BoxTrackerOptions::set_cache_file_format(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 cache_file_format_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:mediapipe.BoxTrackerOptions.cache_file_format)
}
inline std::string* BoxTrackerOptions::mutable_cache_file_format() {
  // @@protoc_insertion_point(field_mutable:mediapipe.BoxTrackerOptions.cache_file_format)
  return _internal_mutable_cache_file_format();
}
inline const std::string& BoxTrackerOptions::_internal_cache_file_format() const {
  return cache_file_format_.Get();
}
inline void BoxTrackerOptions::_internal_set_cache_file_format(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  cache_file_format_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, value, GetArena());
}
inline std::string* BoxTrackerOptions::_internal_mutable_cache_file_format() {
  _has_bits_[0] |= 0x00000001u;
  return cache_file_format_.Mutable(::mediapipe::BoxTrackerOptions::_i_give_permission_to_break_this_code_default_cache_file_format_, GetArena());
}
inline std::string* BoxTrackerOptions::release_cache_file_format() {
  // @@protoc_insertion_point(field_release:mediapipe.BoxTrackerOptions.cache_file_format)
  if (!_internal_has_cache_file_format()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return cache_file_format_.ReleaseNonDefault(nullptr, GetArena());
}
inline void BoxTrackerOptions::set_allocated_cache_file_format(std::string* cache_file_format) {
  if (cache_file_format != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  cache_file_format_.SetAllocated(nullptr, cache_file_format,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mediapipe.BoxTrackerOptions.cache_file_format)
}

// optional int32 num_tracking_workers = 3 [default = 8];
inline bool BoxTrackerOptions::_internal_has_num_tracking_workers() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool BoxTrackerOptions::has_num_tracking_workers() const {
  return _internal_has_num_tracking_workers();
}
inline void BoxTrackerOptions::clear_num_tracking_workers() {
  num_tracking_workers_ = 8;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BoxTrackerOptions::_internal_num_tracking_workers() const {
  return num_tracking_workers_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BoxTrackerOptions::num_tracking_workers() const {
  // @@protoc_insertion_point(field_get:mediapipe.BoxTrackerOptions.num_tracking_workers)
  return _internal_num_tracking_workers();
}
inline void BoxTrackerOptions::_internal_set_num_tracking_workers(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  num_tracking_workers_ = value;
}
inline void BoxTrackerOptions::set_num_tracking_workers(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_tracking_workers(value);
  // @@protoc_insertion_point(field_set:mediapipe.BoxTrackerOptions.num_tracking_workers)
}

// optional int32 read_chunk_timeout_msec = 4 [default = 60000];
inline bool BoxTrackerOptions::_internal_has_read_chunk_timeout_msec() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BoxTrackerOptions::has_read_chunk_timeout_msec() const {
  return _internal_has_read_chunk_timeout_msec();
}
inline void BoxTrackerOptions::clear_read_chunk_timeout_msec() {
  read_chunk_timeout_msec_ = 60000;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BoxTrackerOptions::_internal_read_chunk_timeout_msec() const {
  return read_chunk_timeout_msec_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BoxTrackerOptions::read_chunk_timeout_msec() const {
  // @@protoc_insertion_point(field_get:mediapipe.BoxTrackerOptions.read_chunk_timeout_msec)
  return _internal_read_chunk_timeout_msec();
}
inline void BoxTrackerOptions::_internal_set_read_chunk_timeout_msec(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  read_chunk_timeout_msec_ = value;
}
inline void BoxTrackerOptions::set_read_chunk_timeout_msec(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_read_chunk_timeout_msec(value);
  // @@protoc_insertion_point(field_set:mediapipe.BoxTrackerOptions.read_chunk_timeout_msec)
}

// optional bool record_path_states = 5 [default = false];
inline bool BoxTrackerOptions::_internal_has_record_path_states() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BoxTrackerOptions::has_record_path_states() const {
  return _internal_has_record_path_states();
}
inline void BoxTrackerOptions::clear_record_path_states() {
  record_path_states_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool BoxTrackerOptions::_internal_record_path_states() const {
  return record_path_states_;
}
inline bool BoxTrackerOptions::record_path_states() const {
  // @@protoc_insertion_point(field_get:mediapipe.BoxTrackerOptions.record_path_states)
  return _internal_record_path_states();
}
inline void BoxTrackerOptions::_internal_set_record_path_states(bool value) {
  _has_bits_[0] |= 0x00000004u;
  record_path_states_ = value;
}
inline void BoxTrackerOptions::set_record_path_states(bool value) {
  _internal_set_record_path_states(value);
  // @@protoc_insertion_point(field_set:mediapipe.BoxTrackerOptions.record_path_states)
}

// optional .mediapipe.TrackStepOptions track_step_options = 6;
inline bool BoxTrackerOptions::_internal_has_track_step_options() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || track_step_options_ != nullptr);
  return value;
}
inline bool BoxTrackerOptions::has_track_step_options() const {
  return _internal_has_track_step_options();
}
inline const ::mediapipe::TrackStepOptions& BoxTrackerOptions::_internal_track_step_options() const {
  const ::mediapipe::TrackStepOptions* p = track_step_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::mediapipe::TrackStepOptions&>(
      ::mediapipe::_TrackStepOptions_default_instance_);
}
inline const ::mediapipe::TrackStepOptions& BoxTrackerOptions::track_step_options() const {
  // @@protoc_insertion_point(field_get:mediapipe.BoxTrackerOptions.track_step_options)
  return _internal_track_step_options();
}
inline void BoxTrackerOptions::unsafe_arena_set_allocated_track_step_options(
    ::mediapipe::TrackStepOptions* track_step_options) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(track_step_options_);
  }
  track_step_options_ = track_step_options;
  if (track_step_options) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mediapipe.BoxTrackerOptions.track_step_options)
}
inline ::mediapipe::TrackStepOptions* BoxTrackerOptions::release_track_step_options() {
  _has_bits_[0] &= ~0x00000002u;
  ::mediapipe::TrackStepOptions* temp = track_step_options_;
  track_step_options_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mediapipe::TrackStepOptions* BoxTrackerOptions::unsafe_arena_release_track_step_options() {
  // @@protoc_insertion_point(field_release:mediapipe.BoxTrackerOptions.track_step_options)
  _has_bits_[0] &= ~0x00000002u;
  ::mediapipe::TrackStepOptions* temp = track_step_options_;
  track_step_options_ = nullptr;
  return temp;
}
inline ::mediapipe::TrackStepOptions* BoxTrackerOptions::_internal_mutable_track_step_options() {
  _has_bits_[0] |= 0x00000002u;
  if (track_step_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::mediapipe::TrackStepOptions>(GetArena());
    track_step_options_ = p;
  }
  return track_step_options_;
}
inline ::mediapipe::TrackStepOptions* BoxTrackerOptions::mutable_track_step_options() {
  // @@protoc_insertion_point(field_mutable:mediapipe.BoxTrackerOptions.track_step_options)
  return _internal_mutable_track_step_options();
}
inline void BoxTrackerOptions::set_allocated_track_step_options(::mediapipe::TrackStepOptions* track_step_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(track_step_options_);
  }
  if (track_step_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(track_step_options)->GetArena();
    if (message_arena != submessage_arena) {
      track_step_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, track_step_options, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  track_step_options_ = track_step_options;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.BoxTrackerOptions.track_step_options)
}

// -------------------------------------------------------------------

// TimedBoxProto

// optional float top = 1;
inline bool TimedBoxProto::_internal_has_top() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TimedBoxProto::has_top() const {
  return _internal_has_top();
}
inline void TimedBoxProto::clear_top() {
  top_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float TimedBoxProto::_internal_top() const {
  return top_;
}
inline float TimedBoxProto::top() const {
  // @@protoc_insertion_point(field_get:mediapipe.TimedBoxProto.top)
  return _internal_top();
}
inline void TimedBoxProto::_internal_set_top(float value) {
  _has_bits_[0] |= 0x00000004u;
  top_ = value;
}
inline void TimedBoxProto::set_top(float value) {
  _internal_set_top(value);
  // @@protoc_insertion_point(field_set:mediapipe.TimedBoxProto.top)
}

// optional float left = 2;
inline bool TimedBoxProto::_internal_has_left() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TimedBoxProto::has_left() const {
  return _internal_has_left();
}
inline void TimedBoxProto::clear_left() {
  left_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float TimedBoxProto::_internal_left() const {
  return left_;
}
inline float TimedBoxProto::left() const {
  // @@protoc_insertion_point(field_get:mediapipe.TimedBoxProto.left)
  return _internal_left();
}
inline void TimedBoxProto::_internal_set_left(float value) {
  _has_bits_[0] |= 0x00000008u;
  left_ = value;
}
inline void TimedBoxProto::set_left(float value) {
  _internal_set_left(value);
  // @@protoc_insertion_point(field_set:mediapipe.TimedBoxProto.left)
}

// optional float bottom = 3;
inline bool TimedBoxProto::_internal_has_bottom() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TimedBoxProto::has_bottom() const {
  return _internal_has_bottom();
}
inline void TimedBoxProto::clear_bottom() {
  bottom_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float TimedBoxProto::_internal_bottom() const {
  return bottom_;
}
inline float TimedBoxProto::bottom() const {
  // @@protoc_insertion_point(field_get:mediapipe.TimedBoxProto.bottom)
  return _internal_bottom();
}
inline void TimedBoxProto::_internal_set_bottom(float value) {
  _has_bits_[0] |= 0x00000010u;
  bottom_ = value;
}
inline void TimedBoxProto::set_bottom(float value) {
  _internal_set_bottom(value);
  // @@protoc_insertion_point(field_set:mediapipe.TimedBoxProto.bottom)
}

// optional float right = 4;
inline bool TimedBoxProto::_internal_has_right() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TimedBoxProto::has_right() const {
  return _internal_has_right();
}
inline void TimedBoxProto::clear_right() {
  right_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float TimedBoxProto::_internal_right() const {
  return right_;
}
inline float TimedBoxProto::right() const {
  // @@protoc_insertion_point(field_get:mediapipe.TimedBoxProto.right)
  return _internal_right();
}
inline void TimedBoxProto::_internal_set_right(float value) {
  _has_bits_[0] |= 0x00000020u;
  right_ = value;
}
inline void TimedBoxProto::set_right(float value) {
  _internal_set_right(value);
  // @@protoc_insertion_point(field_set:mediapipe.TimedBoxProto.right)
}

// optional float rotation = 7;
inline bool TimedBoxProto::_internal_has_rotation() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TimedBoxProto::has_rotation() const {
  return _internal_has_rotation();
}
inline void TimedBoxProto::clear_rotation() {
  rotation_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float TimedBoxProto::_internal_rotation() const {
  return rotation_;
}
inline float TimedBoxProto::rotation() const {
  // @@protoc_insertion_point(field_get:mediapipe.TimedBoxProto.rotation)
  return _internal_rotation();
}
inline void TimedBoxProto::_internal_set_rotation(float value) {
  _has_bits_[0] |= 0x00000080u;
  rotation_ = value;
}
inline void TimedBoxProto::set_rotation(float value) {
  _internal_set_rotation(value);
  // @@protoc_insertion_point(field_set:mediapipe.TimedBoxProto.rotation)
}

// optional .mediapipe.MotionBoxState.Quad quad = 9;
inline bool TimedBoxProto::_internal_has_quad() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || quad_ != nullptr);
  return value;
}
inline bool TimedBoxProto::has_quad() const {
  return _internal_has_quad();
}
inline const ::mediapipe::MotionBoxState_Quad& TimedBoxProto::_internal_quad() const {
  const ::mediapipe::MotionBoxState_Quad* p = quad_;
  return p != nullptr ? *p : reinterpret_cast<const ::mediapipe::MotionBoxState_Quad&>(
      ::mediapipe::_MotionBoxState_Quad_default_instance_);
}
inline const ::mediapipe::MotionBoxState_Quad& TimedBoxProto::quad() const {
  // @@protoc_insertion_point(field_get:mediapipe.TimedBoxProto.quad)
  return _internal_quad();
}
inline void TimedBoxProto::unsafe_arena_set_allocated_quad(
    ::mediapipe::MotionBoxState_Quad* quad) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(quad_);
  }
  quad_ = quad;
  if (quad) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mediapipe.TimedBoxProto.quad)
}
inline ::mediapipe::MotionBoxState_Quad* TimedBoxProto::release_quad() {
  _has_bits_[0] &= ~0x00000002u;
  ::mediapipe::MotionBoxState_Quad* temp = quad_;
  quad_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mediapipe::MotionBoxState_Quad* TimedBoxProto::unsafe_arena_release_quad() {
  // @@protoc_insertion_point(field_release:mediapipe.TimedBoxProto.quad)
  _has_bits_[0] &= ~0x00000002u;
  ::mediapipe::MotionBoxState_Quad* temp = quad_;
  quad_ = nullptr;
  return temp;
}
inline ::mediapipe::MotionBoxState_Quad* TimedBoxProto::_internal_mutable_quad() {
  _has_bits_[0] |= 0x00000002u;
  if (quad_ == nullptr) {
    auto* p = CreateMaybeMessage<::mediapipe::MotionBoxState_Quad>(GetArena());
    quad_ = p;
  }
  return quad_;
}
inline ::mediapipe::MotionBoxState_Quad* TimedBoxProto::mutable_quad() {
  // @@protoc_insertion_point(field_mutable:mediapipe.TimedBoxProto.quad)
  return _internal_mutable_quad();
}
inline void TimedBoxProto::set_allocated_quad(::mediapipe::MotionBoxState_Quad* quad) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(quad_);
  }
  if (quad) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(quad)->GetArena();
    if (message_arena != submessage_arena) {
      quad = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, quad, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  quad_ = quad;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.TimedBoxProto.quad)
}

// optional int64 time_msec = 5 [default = 0];
inline bool TimedBoxProto::_internal_has_time_msec() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TimedBoxProto::has_time_msec() const {
  return _internal_has_time_msec();
}
inline void TimedBoxProto::clear_time_msec() {
  time_msec_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TimedBoxProto::_internal_time_msec() const {
  return time_msec_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TimedBoxProto::time_msec() const {
  // @@protoc_insertion_point(field_get:mediapipe.TimedBoxProto.time_msec)
  return _internal_time_msec();
}
inline void TimedBoxProto::_internal_set_time_msec(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000040u;
  time_msec_ = value;
}
inline void TimedBoxProto::set_time_msec(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_time_msec(value);
  // @@protoc_insertion_point(field_set:mediapipe.TimedBoxProto.time_msec)
}

// optional int32 id = 6 [default = -1];
inline bool TimedBoxProto::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool TimedBoxProto::has_id() const {
  return _internal_has_id();
}
inline void TimedBoxProto::clear_id() {
  id_ = -1;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TimedBoxProto::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TimedBoxProto::id() const {
  // @@protoc_insertion_point(field_get:mediapipe.TimedBoxProto.id)
  return _internal_id();
}
inline void TimedBoxProto::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00001000u;
  id_ = value;
}
inline void TimedBoxProto::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:mediapipe.TimedBoxProto.id)
}

// optional string label = 13;
inline bool TimedBoxProto::_internal_has_label() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TimedBoxProto::has_label() const {
  return _internal_has_label();
}
inline void TimedBoxProto::clear_label() {
  label_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TimedBoxProto::label() const {
  // @@protoc_insertion_point(field_get:mediapipe.TimedBoxProto.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void TimedBoxProto::set_label(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 label_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:mediapipe.TimedBoxProto.label)
}
inline std::string* TimedBoxProto::mutable_label() {
  // @@protoc_insertion_point(field_mutable:mediapipe.TimedBoxProto.label)
  return _internal_mutable_label();
}
inline const std::string& TimedBoxProto::_internal_label() const {
  return label_.Get();
}
inline void TimedBoxProto::_internal_set_label(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  label_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* TimedBoxProto::_internal_mutable_label() {
  _has_bits_[0] |= 0x00000001u;
  return label_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* TimedBoxProto::release_label() {
  // @@protoc_insertion_point(field_release:mediapipe.TimedBoxProto.label)
  if (!_internal_has_label()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return label_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TimedBoxProto::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  label_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), label,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mediapipe.TimedBoxProto.label)
}

// optional float confidence = 8;
inline bool TimedBoxProto::_internal_has_confidence() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool TimedBoxProto::has_confidence() const {
  return _internal_has_confidence();
}
inline void TimedBoxProto::clear_confidence() {
  confidence_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float TimedBoxProto::_internal_confidence() const {
  return confidence_;
}
inline float TimedBoxProto::confidence() const {
  // @@protoc_insertion_point(field_get:mediapipe.TimedBoxProto.confidence)
  return _internal_confidence();
}
inline void TimedBoxProto::_internal_set_confidence(float value) {
  _has_bits_[0] |= 0x00000100u;
  confidence_ = value;
}
inline void TimedBoxProto::set_confidence(float value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:mediapipe.TimedBoxProto.confidence)
}

// optional float aspect_ratio = 10;
inline bool TimedBoxProto::_internal_has_aspect_ratio() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool TimedBoxProto::has_aspect_ratio() const {
  return _internal_has_aspect_ratio();
}
inline void TimedBoxProto::clear_aspect_ratio() {
  aspect_ratio_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline float TimedBoxProto::_internal_aspect_ratio() const {
  return aspect_ratio_;
}
inline float TimedBoxProto::aspect_ratio() const {
  // @@protoc_insertion_point(field_get:mediapipe.TimedBoxProto.aspect_ratio)
  return _internal_aspect_ratio();
}
inline void TimedBoxProto::_internal_set_aspect_ratio(float value) {
  _has_bits_[0] |= 0x00000200u;
  aspect_ratio_ = value;
}
inline void TimedBoxProto::set_aspect_ratio(float value) {
  _internal_set_aspect_ratio(value);
  // @@protoc_insertion_point(field_set:mediapipe.TimedBoxProto.aspect_ratio)
}

// optional bool reacquisition = 11 [default = false];
inline bool TimedBoxProto::_internal_has_reacquisition() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool TimedBoxProto::has_reacquisition() const {
  return _internal_has_reacquisition();
}
inline void TimedBoxProto::clear_reacquisition() {
  reacquisition_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool TimedBoxProto::_internal_reacquisition() const {
  return reacquisition_;
}
inline bool TimedBoxProto::reacquisition() const {
  // @@protoc_insertion_point(field_get:mediapipe.TimedBoxProto.reacquisition)
  return _internal_reacquisition();
}
inline void TimedBoxProto::_internal_set_reacquisition(bool value) {
  _has_bits_[0] |= 0x00000400u;
  reacquisition_ = value;
}
inline void TimedBoxProto::set_reacquisition(bool value) {
  _internal_set_reacquisition(value);
  // @@protoc_insertion_point(field_set:mediapipe.TimedBoxProto.reacquisition)
}

// optional bool request_grouping = 12 [default = false];
inline bool TimedBoxProto::_internal_has_request_grouping() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool TimedBoxProto::has_request_grouping() const {
  return _internal_has_request_grouping();
}
inline void TimedBoxProto::clear_request_grouping() {
  request_grouping_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool TimedBoxProto::_internal_request_grouping() const {
  return request_grouping_;
}
inline bool TimedBoxProto::request_grouping() const {
  // @@protoc_insertion_point(field_get:mediapipe.TimedBoxProto.request_grouping)
  return _internal_request_grouping();
}
inline void TimedBoxProto::_internal_set_request_grouping(bool value) {
  _has_bits_[0] |= 0x00000800u;
  request_grouping_ = value;
}
inline void TimedBoxProto::set_request_grouping(bool value) {
  _internal_set_request_grouping(value);
  // @@protoc_insertion_point(field_set:mediapipe.TimedBoxProto.request_grouping)
}

// -------------------------------------------------------------------

// TimedBoxProtoList

// repeated .mediapipe.TimedBoxProto box = 1;
inline int TimedBoxProtoList::_internal_box_size() const {
  return box_.size();
}
inline int TimedBoxProtoList::box_size() const {
  return _internal_box_size();
}
inline void TimedBoxProtoList::clear_box() {
  box_.Clear();
}
inline ::mediapipe::TimedBoxProto* TimedBoxProtoList::mutable_box(int index) {
  // @@protoc_insertion_point(field_mutable:mediapipe.TimedBoxProtoList.box)
  return box_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::TimedBoxProto >*
TimedBoxProtoList::mutable_box() {
  // @@protoc_insertion_point(field_mutable_list:mediapipe.TimedBoxProtoList.box)
  return &box_;
}
inline const ::mediapipe::TimedBoxProto& TimedBoxProtoList::_internal_box(int index) const {
  return box_.Get(index);
}
inline const ::mediapipe::TimedBoxProto& TimedBoxProtoList::box(int index) const {
  // @@protoc_insertion_point(field_get:mediapipe.TimedBoxProtoList.box)
  return _internal_box(index);
}
inline ::mediapipe::TimedBoxProto* TimedBoxProtoList::_internal_add_box() {
  return box_.Add();
}
inline ::mediapipe::TimedBoxProto* TimedBoxProtoList::add_box() {
  // @@protoc_insertion_point(field_add:mediapipe.TimedBoxProtoList.box)
  return _internal_add_box();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mediapipe::TimedBoxProto >&
TimedBoxProtoList::box() const {
  // @@protoc_insertion_point(field_list:mediapipe.TimedBoxProtoList.box)
  return box_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mediapipe

// @@protoc_insertion_point(global_scope)

#include <x/google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_mediapipe_2futil_2ftracking_2fbox_5ftracker_2eproto
