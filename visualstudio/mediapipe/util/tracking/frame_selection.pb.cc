// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mediapipe/util/tracking/frame_selection.proto

#include "mediapipe/util/tracking/frame_selection.pb.h"

#include <algorithm>

#include <x/google/protobuf/io/coded_stream.h>
#include <x/google/protobuf/extension_set.h>
#include <x/google/protobuf/wire_format_lite.h>
#include <x/google/protobuf/descriptor.h>
#include <x/google/protobuf/generated_message_reflection.h>
#include <x/google/protobuf/reflection_ops.h>
#include <x/google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <x/google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace mediapipe {
constexpr FrameSelectionTimestamp::FrameSelectionTimestamp(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : timestamp_(PROTOBUF_LONGLONG(0))
  , frame_idx_(0)
  , processed_from_timestamp_(PROTOBUF_LONGLONG(-1)){}
struct FrameSelectionTimestampDefaultTypeInternal {
  constexpr FrameSelectionTimestampDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FrameSelectionTimestampDefaultTypeInternal() {}
  union {
    FrameSelectionTimestamp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FrameSelectionTimestampDefaultTypeInternal _FrameSelectionTimestamp_default_instance_;
constexpr FrameSelectionResult::FrameSelectionResult(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : camera_motion_(nullptr)
  , features_(nullptr)
  , timestamp_(PROTOBUF_LONGLONG(0))
  , frame_idx_(0)
  , processed_from_timestamp_(PROTOBUF_LONGLONG(-1)){}
struct FrameSelectionResultDefaultTypeInternal {
  constexpr FrameSelectionResultDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FrameSelectionResultDefaultTypeInternal() {}
  union {
    FrameSelectionResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FrameSelectionResultDefaultTypeInternal _FrameSelectionResult_default_instance_;
constexpr FrameSelectionCriterion::FrameSelectionCriterion(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : solution_evaluator_(nullptr)
  , sampling_rate_(0)
  , max_output_frames_(0)
  , bandwidth_frames_(50)
  , search_radius_frames_(1){}
struct FrameSelectionCriterionDefaultTypeInternal {
  constexpr FrameSelectionCriterionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FrameSelectionCriterionDefaultTypeInternal() {}
  union {
    FrameSelectionCriterion _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FrameSelectionCriterionDefaultTypeInternal _FrameSelectionCriterion_default_instance_;
constexpr FrameSelectionOptions::FrameSelectionOptions(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : criterion_()
  , chunk_size_(100){}
struct FrameSelectionOptionsDefaultTypeInternal {
  constexpr FrameSelectionOptionsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FrameSelectionOptionsDefaultTypeInternal() {}
  union {
    FrameSelectionOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FrameSelectionOptionsDefaultTypeInternal _FrameSelectionOptions_default_instance_;
}  // namespace mediapipe
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_mediapipe_2futil_2ftracking_2fframe_5fselection_2eproto[4];
static constexpr ::PROTOBUF_NAMESPACE_ID::EnumDescriptor const** file_level_enum_descriptors_mediapipe_2futil_2ftracking_2fframe_5fselection_2eproto = nullptr;
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_mediapipe_2futil_2ftracking_2fframe_5fselection_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_mediapipe_2futil_2ftracking_2fframe_5fselection_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::mediapipe::FrameSelectionTimestamp, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::FrameSelectionTimestamp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mediapipe::FrameSelectionTimestamp, timestamp_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::FrameSelectionTimestamp, frame_idx_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::FrameSelectionTimestamp, processed_from_timestamp_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::mediapipe::FrameSelectionResult, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::FrameSelectionResult, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mediapipe::FrameSelectionResult, timestamp_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::FrameSelectionResult, frame_idx_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::FrameSelectionResult, camera_motion_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::FrameSelectionResult, features_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::FrameSelectionResult, processed_from_timestamp_),
  2,
  3,
  0,
  1,
  4,
  PROTOBUF_FIELD_OFFSET(::mediapipe::FrameSelectionCriterion, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::FrameSelectionCriterion, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mediapipe::FrameSelectionCriterion, sampling_rate_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::FrameSelectionCriterion, bandwidth_frames_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::FrameSelectionCriterion, search_radius_frames_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::FrameSelectionCriterion, solution_evaluator_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::FrameSelectionCriterion, max_output_frames_),
  1,
  3,
  4,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::mediapipe::FrameSelectionOptions, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::FrameSelectionOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mediapipe::FrameSelectionOptions, criterion_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::FrameSelectionOptions, chunk_size_),
  ~0u,
  0,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, sizeof(::mediapipe::FrameSelectionTimestamp)},
  { 11, 21, sizeof(::mediapipe::FrameSelectionResult)},
  { 26, 36, sizeof(::mediapipe::FrameSelectionCriterion)},
  { 41, 48, sizeof(::mediapipe::FrameSelectionOptions)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mediapipe::_FrameSelectionTimestamp_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mediapipe::_FrameSelectionResult_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mediapipe::_FrameSelectionCriterion_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mediapipe::_FrameSelectionOptions_default_instance_),
};

const char descriptor_table_protodef_mediapipe_2futil_2ftracking_2fframe_5fselection_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n-mediapipe/util/tracking/frame_selectio"
  "n.proto\022\tmediapipe\032+mediapipe/util/track"
  "ing/camera_motion.proto\032@mediapipe/util/"
  "tracking/frame_selection_solution_evalua"
  "tor.proto\032)mediapipe/util/tracking/regio"
  "n_flow.proto\"e\n\027FrameSelectionTimestamp\022"
  "\021\n\ttimestamp\030\001 \001(\003\022\021\n\tframe_idx\030\002 \001(\005\022$\n"
  "\030processed_from_timestamp\030\003 \001(\003:\002-1\"\306\001\n\024"
  "FrameSelectionResult\022\021\n\ttimestamp\030\001 \001(\003\022"
  "\021\n\tframe_idx\030\002 \001(\005\022.\n\rcamera_motion\030\003 \001("
  "\0132\027.mediapipe.CameraMotion\0222\n\010features\030\004"
  " \001(\0132 .mediapipe.RegionFlowFeatureList\022$"
  "\n\030processed_from_timestamp\030\005 \001(\003:\002-1\"\334\001\n"
  "\027FrameSelectionCriterion\022\030\n\rsampling_rat"
  "e\030\001 \001(\005:\0010\022\034\n\020bandwidth_frames\030\002 \001(\002:\00250"
  "\022\037\n\024search_radius_frames\030\003 \001(\005:\0011\022J\n\022sol"
  "ution_evaluator\030\004 \001(\0132..mediapipe.FrameS"
  "electionSolutionEvaluatorType\022\034\n\021max_out"
  "put_frames\030\005 \001(\005:\0010\"g\n\025FrameSelectionOpt"
  "ions\0225\n\tcriterion\030\001 \003(\0132\".mediapipe.Fram"
  "eSelectionCriterion\022\027\n\nchunk_size\030\002 \001(\005:"
  "\003100"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_mediapipe_2futil_2ftracking_2fframe_5fselection_2eproto_deps[3] = {
  &::descriptor_table_mediapipe_2futil_2ftracking_2fcamera_5fmotion_2eproto,
  &::descriptor_table_mediapipe_2futil_2ftracking_2fframe_5fselection_5fsolution_5fevaluator_2eproto,
  &::descriptor_table_mediapipe_2futil_2ftracking_2fregion_5fflow_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_mediapipe_2futil_2ftracking_2fframe_5fselection_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_mediapipe_2futil_2ftracking_2fframe_5fselection_2eproto = {
  false, false, 844, descriptor_table_protodef_mediapipe_2futil_2ftracking_2fframe_5fselection_2eproto, "mediapipe/util/tracking/frame_selection.proto", 
  &descriptor_table_mediapipe_2futil_2ftracking_2fframe_5fselection_2eproto_once, descriptor_table_mediapipe_2futil_2ftracking_2fframe_5fselection_2eproto_deps, 3, 4,
  schemas, file_default_instances, TableStruct_mediapipe_2futil_2ftracking_2fframe_5fselection_2eproto::offsets,
  file_level_metadata_mediapipe_2futil_2ftracking_2fframe_5fselection_2eproto, file_level_enum_descriptors_mediapipe_2futil_2ftracking_2fframe_5fselection_2eproto, file_level_service_descriptors_mediapipe_2futil_2ftracking_2fframe_5fselection_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_mediapipe_2futil_2ftracking_2fframe_5fselection_2eproto_getter() {
  return &descriptor_table_mediapipe_2futil_2ftracking_2fframe_5fselection_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_mediapipe_2futil_2ftracking_2fframe_5fselection_2eproto(&descriptor_table_mediapipe_2futil_2ftracking_2fframe_5fselection_2eproto);
namespace mediapipe {

// ===================================================================

class FrameSelectionTimestamp::_Internal {
 public:
  using HasBits = decltype(std::declval<FrameSelectionTimestamp>()._has_bits_);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_frame_idx(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_processed_from_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

FrameSelectionTimestamp::FrameSelectionTimestamp(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mediapipe.FrameSelectionTimestamp)
}
FrameSelectionTimestamp::FrameSelectionTimestamp(const FrameSelectionTimestamp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&timestamp_, &from.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&processed_from_timestamp_) -
    reinterpret_cast<char*>(&timestamp_)) + sizeof(processed_from_timestamp_));
  // @@protoc_insertion_point(copy_constructor:mediapipe.FrameSelectionTimestamp)
}

void FrameSelectionTimestamp::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&frame_idx_) -
    reinterpret_cast<char*>(&timestamp_)) + sizeof(frame_idx_));
processed_from_timestamp_ = PROTOBUF_LONGLONG(-1);
}

FrameSelectionTimestamp::~FrameSelectionTimestamp() {
  // @@protoc_insertion_point(destructor:mediapipe.FrameSelectionTimestamp)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void FrameSelectionTimestamp::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void FrameSelectionTimestamp::ArenaDtor(void* object) {
  FrameSelectionTimestamp* _this = reinterpret_cast< FrameSelectionTimestamp* >(object);
  (void)_this;
}
void FrameSelectionTimestamp::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FrameSelectionTimestamp::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FrameSelectionTimestamp::Clear() {
// @@protoc_insertion_point(message_clear_start:mediapipe.FrameSelectionTimestamp)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&frame_idx_) -
        reinterpret_cast<char*>(&timestamp_)) + sizeof(frame_idx_));
    processed_from_timestamp_ = PROTOBUF_LONGLONG(-1);
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FrameSelectionTimestamp::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_timestamp(&has_bits);
          timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 frame_idx = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_frame_idx(&has_bits);
          frame_idx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 processed_from_timestamp = 3 [default = -1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_processed_from_timestamp(&has_bits);
          processed_from_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FrameSelectionTimestamp::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mediapipe.FrameSelectionTimestamp)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 timestamp = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp(), target);
  }

  // optional int32 frame_idx = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_frame_idx(), target);
  }

  // optional int64 processed_from_timestamp = 3 [default = -1];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_processed_from_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mediapipe.FrameSelectionTimestamp)
  return target;
}

size_t FrameSelectionTimestamp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mediapipe.FrameSelectionTimestamp)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int64 timestamp = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_timestamp());
    }

    // optional int32 frame_idx = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_frame_idx());
    }

    // optional int64 processed_from_timestamp = 3 [default = -1];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_processed_from_timestamp());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FrameSelectionTimestamp::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mediapipe.FrameSelectionTimestamp)
  GOOGLE_DCHECK_NE(&from, this);
  const FrameSelectionTimestamp* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<FrameSelectionTimestamp>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mediapipe.FrameSelectionTimestamp)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mediapipe.FrameSelectionTimestamp)
    MergeFrom(*source);
  }
}

void FrameSelectionTimestamp::MergeFrom(const FrameSelectionTimestamp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mediapipe.FrameSelectionTimestamp)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      timestamp_ = from.timestamp_;
    }
    if (cached_has_bits & 0x00000002u) {
      frame_idx_ = from.frame_idx_;
    }
    if (cached_has_bits & 0x00000004u) {
      processed_from_timestamp_ = from.processed_from_timestamp_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void FrameSelectionTimestamp::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mediapipe.FrameSelectionTimestamp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FrameSelectionTimestamp::CopyFrom(const FrameSelectionTimestamp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mediapipe.FrameSelectionTimestamp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrameSelectionTimestamp::IsInitialized() const {
  return true;
}

void FrameSelectionTimestamp::InternalSwap(FrameSelectionTimestamp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FrameSelectionTimestamp, frame_idx_)
      + sizeof(FrameSelectionTimestamp::frame_idx_)
      - PROTOBUF_FIELD_OFFSET(FrameSelectionTimestamp, timestamp_)>(
          reinterpret_cast<char*>(&timestamp_),
          reinterpret_cast<char*>(&other->timestamp_));
  swap(processed_from_timestamp_, other->processed_from_timestamp_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FrameSelectionTimestamp::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_mediapipe_2futil_2ftracking_2fframe_5fselection_2eproto_getter, &descriptor_table_mediapipe_2futil_2ftracking_2fframe_5fselection_2eproto_once,
      file_level_metadata_mediapipe_2futil_2ftracking_2fframe_5fselection_2eproto[0]);
}

// ===================================================================

class FrameSelectionResult::_Internal {
 public:
  using HasBits = decltype(std::declval<FrameSelectionResult>()._has_bits_);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_frame_idx(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::mediapipe::CameraMotion& camera_motion(const FrameSelectionResult* msg);
  static void set_has_camera_motion(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::mediapipe::RegionFlowFeatureList& features(const FrameSelectionResult* msg);
  static void set_has_features(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_processed_from_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::mediapipe::CameraMotion&
FrameSelectionResult::_Internal::camera_motion(const FrameSelectionResult* msg) {
  return *msg->camera_motion_;
}
const ::mediapipe::RegionFlowFeatureList&
FrameSelectionResult::_Internal::features(const FrameSelectionResult* msg) {
  return *msg->features_;
}
void FrameSelectionResult::clear_camera_motion() {
  if (camera_motion_ != nullptr) camera_motion_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void FrameSelectionResult::clear_features() {
  if (features_ != nullptr) features_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
FrameSelectionResult::FrameSelectionResult(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mediapipe.FrameSelectionResult)
}
FrameSelectionResult::FrameSelectionResult(const FrameSelectionResult& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_camera_motion()) {
    camera_motion_ = new ::mediapipe::CameraMotion(*from.camera_motion_);
  } else {
    camera_motion_ = nullptr;
  }
  if (from._internal_has_features()) {
    features_ = new ::mediapipe::RegionFlowFeatureList(*from.features_);
  } else {
    features_ = nullptr;
  }
  ::memcpy(&timestamp_, &from.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&processed_from_timestamp_) -
    reinterpret_cast<char*>(&timestamp_)) + sizeof(processed_from_timestamp_));
  // @@protoc_insertion_point(copy_constructor:mediapipe.FrameSelectionResult)
}

void FrameSelectionResult::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&camera_motion_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&frame_idx_) -
    reinterpret_cast<char*>(&camera_motion_)) + sizeof(frame_idx_));
processed_from_timestamp_ = PROTOBUF_LONGLONG(-1);
}

FrameSelectionResult::~FrameSelectionResult() {
  // @@protoc_insertion_point(destructor:mediapipe.FrameSelectionResult)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void FrameSelectionResult::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete camera_motion_;
  if (this != internal_default_instance()) delete features_;
}

void FrameSelectionResult::ArenaDtor(void* object) {
  FrameSelectionResult* _this = reinterpret_cast< FrameSelectionResult* >(object);
  (void)_this;
}
void FrameSelectionResult::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FrameSelectionResult::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FrameSelectionResult::Clear() {
// @@protoc_insertion_point(message_clear_start:mediapipe.FrameSelectionResult)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(camera_motion_ != nullptr);
      camera_motion_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(features_ != nullptr);
      features_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&frame_idx_) -
        reinterpret_cast<char*>(&timestamp_)) + sizeof(frame_idx_));
    processed_from_timestamp_ = PROTOBUF_LONGLONG(-1);
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FrameSelectionResult::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_timestamp(&has_bits);
          timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 frame_idx = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_frame_idx(&has_bits);
          frame_idx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mediapipe.CameraMotion camera_motion = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_camera_motion(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mediapipe.RegionFlowFeatureList features = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_features(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 processed_from_timestamp = 5 [default = -1];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_processed_from_timestamp(&has_bits);
          processed_from_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FrameSelectionResult::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mediapipe.FrameSelectionResult)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 timestamp = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp(), target);
  }

  // optional int32 frame_idx = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_frame_idx(), target);
  }

  // optional .mediapipe.CameraMotion camera_motion = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::camera_motion(this), target, stream);
  }

  // optional .mediapipe.RegionFlowFeatureList features = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::features(this), target, stream);
  }

  // optional int64 processed_from_timestamp = 5 [default = -1];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(5, this->_internal_processed_from_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mediapipe.FrameSelectionResult)
  return target;
}

size_t FrameSelectionResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mediapipe.FrameSelectionResult)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .mediapipe.CameraMotion camera_motion = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *camera_motion_);
    }

    // optional .mediapipe.RegionFlowFeatureList features = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *features_);
    }

    // optional int64 timestamp = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_timestamp());
    }

    // optional int32 frame_idx = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_frame_idx());
    }

    // optional int64 processed_from_timestamp = 5 [default = -1];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_processed_from_timestamp());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FrameSelectionResult::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mediapipe.FrameSelectionResult)
  GOOGLE_DCHECK_NE(&from, this);
  const FrameSelectionResult* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<FrameSelectionResult>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mediapipe.FrameSelectionResult)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mediapipe.FrameSelectionResult)
    MergeFrom(*source);
  }
}

void FrameSelectionResult::MergeFrom(const FrameSelectionResult& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mediapipe.FrameSelectionResult)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_camera_motion()->::mediapipe::CameraMotion::MergeFrom(from._internal_camera_motion());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_features()->::mediapipe::RegionFlowFeatureList::MergeFrom(from._internal_features());
    }
    if (cached_has_bits & 0x00000004u) {
      timestamp_ = from.timestamp_;
    }
    if (cached_has_bits & 0x00000008u) {
      frame_idx_ = from.frame_idx_;
    }
    if (cached_has_bits & 0x00000010u) {
      processed_from_timestamp_ = from.processed_from_timestamp_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void FrameSelectionResult::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mediapipe.FrameSelectionResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FrameSelectionResult::CopyFrom(const FrameSelectionResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mediapipe.FrameSelectionResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrameSelectionResult::IsInitialized() const {
  if (_internal_has_camera_motion()) {
    if (!camera_motion_->IsInitialized()) return false;
  }
  if (_internal_has_features()) {
    if (!features_->IsInitialized()) return false;
  }
  return true;
}

void FrameSelectionResult::InternalSwap(FrameSelectionResult* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FrameSelectionResult, frame_idx_)
      + sizeof(FrameSelectionResult::frame_idx_)
      - PROTOBUF_FIELD_OFFSET(FrameSelectionResult, camera_motion_)>(
          reinterpret_cast<char*>(&camera_motion_),
          reinterpret_cast<char*>(&other->camera_motion_));
  swap(processed_from_timestamp_, other->processed_from_timestamp_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FrameSelectionResult::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_mediapipe_2futil_2ftracking_2fframe_5fselection_2eproto_getter, &descriptor_table_mediapipe_2futil_2ftracking_2fframe_5fselection_2eproto_once,
      file_level_metadata_mediapipe_2futil_2ftracking_2fframe_5fselection_2eproto[1]);
}

// ===================================================================

class FrameSelectionCriterion::_Internal {
 public:
  using HasBits = decltype(std::declval<FrameSelectionCriterion>()._has_bits_);
  static void set_has_sampling_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_bandwidth_frames(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_search_radius_frames(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::mediapipe::FrameSelectionSolutionEvaluatorType& solution_evaluator(const FrameSelectionCriterion* msg);
  static void set_has_solution_evaluator(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_max_output_frames(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::mediapipe::FrameSelectionSolutionEvaluatorType&
FrameSelectionCriterion::_Internal::solution_evaluator(const FrameSelectionCriterion* msg) {
  return *msg->solution_evaluator_;
}
void FrameSelectionCriterion::clear_solution_evaluator() {
  if (solution_evaluator_ != nullptr) solution_evaluator_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
FrameSelectionCriterion::FrameSelectionCriterion(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mediapipe.FrameSelectionCriterion)
}
FrameSelectionCriterion::FrameSelectionCriterion(const FrameSelectionCriterion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_solution_evaluator()) {
    solution_evaluator_ = new ::mediapipe::FrameSelectionSolutionEvaluatorType(*from.solution_evaluator_);
  } else {
    solution_evaluator_ = nullptr;
  }
  ::memcpy(&sampling_rate_, &from.sampling_rate_,
    static_cast<size_t>(reinterpret_cast<char*>(&search_radius_frames_) -
    reinterpret_cast<char*>(&sampling_rate_)) + sizeof(search_radius_frames_));
  // @@protoc_insertion_point(copy_constructor:mediapipe.FrameSelectionCriterion)
}

void FrameSelectionCriterion::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&solution_evaluator_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&max_output_frames_) -
    reinterpret_cast<char*>(&solution_evaluator_)) + sizeof(max_output_frames_));
bandwidth_frames_ = 50;
search_radius_frames_ = 1;
}

FrameSelectionCriterion::~FrameSelectionCriterion() {
  // @@protoc_insertion_point(destructor:mediapipe.FrameSelectionCriterion)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void FrameSelectionCriterion::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete solution_evaluator_;
}

void FrameSelectionCriterion::ArenaDtor(void* object) {
  FrameSelectionCriterion* _this = reinterpret_cast< FrameSelectionCriterion* >(object);
  (void)_this;
}
void FrameSelectionCriterion::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FrameSelectionCriterion::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FrameSelectionCriterion::Clear() {
// @@protoc_insertion_point(message_clear_start:mediapipe.FrameSelectionCriterion)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(solution_evaluator_ != nullptr);
    solution_evaluator_->Clear();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&sampling_rate_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&max_output_frames_) -
        reinterpret_cast<char*>(&sampling_rate_)) + sizeof(max_output_frames_));
    bandwidth_frames_ = 50;
    search_radius_frames_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FrameSelectionCriterion::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 sampling_rate = 1 [default = 0];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_sampling_rate(&has_bits);
          sampling_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float bandwidth_frames = 2 [default = 50];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_bandwidth_frames(&has_bits);
          bandwidth_frames_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional int32 search_radius_frames = 3 [default = 1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_search_radius_frames(&has_bits);
          search_radius_frames_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mediapipe.FrameSelectionSolutionEvaluatorType solution_evaluator = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_solution_evaluator(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 max_output_frames = 5 [default = 0];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_max_output_frames(&has_bits);
          max_output_frames_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FrameSelectionCriterion::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mediapipe.FrameSelectionCriterion)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 sampling_rate = 1 [default = 0];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_sampling_rate(), target);
  }

  // optional float bandwidth_frames = 2 [default = 50];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_bandwidth_frames(), target);
  }

  // optional int32 search_radius_frames = 3 [default = 1];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_search_radius_frames(), target);
  }

  // optional .mediapipe.FrameSelectionSolutionEvaluatorType solution_evaluator = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::solution_evaluator(this), target, stream);
  }

  // optional int32 max_output_frames = 5 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_max_output_frames(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mediapipe.FrameSelectionCriterion)
  return target;
}

size_t FrameSelectionCriterion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mediapipe.FrameSelectionCriterion)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .mediapipe.FrameSelectionSolutionEvaluatorType solution_evaluator = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *solution_evaluator_);
    }

    // optional int32 sampling_rate = 1 [default = 0];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_sampling_rate());
    }

    // optional int32 max_output_frames = 5 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_max_output_frames());
    }

    // optional float bandwidth_frames = 2 [default = 50];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional int32 search_radius_frames = 3 [default = 1];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_search_radius_frames());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FrameSelectionCriterion::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mediapipe.FrameSelectionCriterion)
  GOOGLE_DCHECK_NE(&from, this);
  const FrameSelectionCriterion* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<FrameSelectionCriterion>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mediapipe.FrameSelectionCriterion)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mediapipe.FrameSelectionCriterion)
    MergeFrom(*source);
  }
}

void FrameSelectionCriterion::MergeFrom(const FrameSelectionCriterion& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mediapipe.FrameSelectionCriterion)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_solution_evaluator()->::mediapipe::FrameSelectionSolutionEvaluatorType::MergeFrom(from._internal_solution_evaluator());
    }
    if (cached_has_bits & 0x00000002u) {
      sampling_rate_ = from.sampling_rate_;
    }
    if (cached_has_bits & 0x00000004u) {
      max_output_frames_ = from.max_output_frames_;
    }
    if (cached_has_bits & 0x00000008u) {
      bandwidth_frames_ = from.bandwidth_frames_;
    }
    if (cached_has_bits & 0x00000010u) {
      search_radius_frames_ = from.search_radius_frames_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void FrameSelectionCriterion::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mediapipe.FrameSelectionCriterion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FrameSelectionCriterion::CopyFrom(const FrameSelectionCriterion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mediapipe.FrameSelectionCriterion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrameSelectionCriterion::IsInitialized() const {
  if (_internal_has_solution_evaluator()) {
    if (!solution_evaluator_->IsInitialized()) return false;
  }
  return true;
}

void FrameSelectionCriterion::InternalSwap(FrameSelectionCriterion* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FrameSelectionCriterion, max_output_frames_)
      + sizeof(FrameSelectionCriterion::max_output_frames_)
      - PROTOBUF_FIELD_OFFSET(FrameSelectionCriterion, solution_evaluator_)>(
          reinterpret_cast<char*>(&solution_evaluator_),
          reinterpret_cast<char*>(&other->solution_evaluator_));
  swap(bandwidth_frames_, other->bandwidth_frames_);
  swap(search_radius_frames_, other->search_radius_frames_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FrameSelectionCriterion::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_mediapipe_2futil_2ftracking_2fframe_5fselection_2eproto_getter, &descriptor_table_mediapipe_2futil_2ftracking_2fframe_5fselection_2eproto_once,
      file_level_metadata_mediapipe_2futil_2ftracking_2fframe_5fselection_2eproto[2]);
}

// ===================================================================

class FrameSelectionOptions::_Internal {
 public:
  using HasBits = decltype(std::declval<FrameSelectionOptions>()._has_bits_);
  static void set_has_chunk_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

FrameSelectionOptions::FrameSelectionOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  criterion_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mediapipe.FrameSelectionOptions)
}
FrameSelectionOptions::FrameSelectionOptions(const FrameSelectionOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      criterion_(from.criterion_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  chunk_size_ = from.chunk_size_;
  // @@protoc_insertion_point(copy_constructor:mediapipe.FrameSelectionOptions)
}

void FrameSelectionOptions::SharedCtor() {
chunk_size_ = 100;
}

FrameSelectionOptions::~FrameSelectionOptions() {
  // @@protoc_insertion_point(destructor:mediapipe.FrameSelectionOptions)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void FrameSelectionOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void FrameSelectionOptions::ArenaDtor(void* object) {
  FrameSelectionOptions* _this = reinterpret_cast< FrameSelectionOptions* >(object);
  (void)_this;
}
void FrameSelectionOptions::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FrameSelectionOptions::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FrameSelectionOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:mediapipe.FrameSelectionOptions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  criterion_.Clear();
  chunk_size_ = 100;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FrameSelectionOptions::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .mediapipe.FrameSelectionCriterion criterion = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_criterion(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      // optional int32 chunk_size = 2 [default = 100];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_chunk_size(&has_bits);
          chunk_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FrameSelectionOptions::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mediapipe.FrameSelectionOptions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .mediapipe.FrameSelectionCriterion criterion = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_criterion_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_criterion(i), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional int32 chunk_size = 2 [default = 100];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_chunk_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mediapipe.FrameSelectionOptions)
  return target;
}

size_t FrameSelectionOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mediapipe.FrameSelectionOptions)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mediapipe.FrameSelectionCriterion criterion = 1;
  total_size += 1UL * this->_internal_criterion_size();
  for (const auto& msg : this->criterion_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional int32 chunk_size = 2 [default = 100];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_chunk_size());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FrameSelectionOptions::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mediapipe.FrameSelectionOptions)
  GOOGLE_DCHECK_NE(&from, this);
  const FrameSelectionOptions* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<FrameSelectionOptions>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mediapipe.FrameSelectionOptions)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mediapipe.FrameSelectionOptions)
    MergeFrom(*source);
  }
}

void FrameSelectionOptions::MergeFrom(const FrameSelectionOptions& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mediapipe.FrameSelectionOptions)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  criterion_.MergeFrom(from.criterion_);
  if (from._internal_has_chunk_size()) {
    _internal_set_chunk_size(from._internal_chunk_size());
  }
}

void FrameSelectionOptions::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mediapipe.FrameSelectionOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FrameSelectionOptions::CopyFrom(const FrameSelectionOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mediapipe.FrameSelectionOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrameSelectionOptions::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(criterion_)) return false;
  return true;
}

void FrameSelectionOptions::InternalSwap(FrameSelectionOptions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  criterion_.InternalSwap(&other->criterion_);
  swap(chunk_size_, other->chunk_size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FrameSelectionOptions::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_mediapipe_2futil_2ftracking_2fframe_5fselection_2eproto_getter, &descriptor_table_mediapipe_2futil_2ftracking_2fframe_5fselection_2eproto_once,
      file_level_metadata_mediapipe_2futil_2ftracking_2fframe_5fselection_2eproto[3]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace mediapipe
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::mediapipe::FrameSelectionTimestamp* Arena::CreateMaybeMessage< ::mediapipe::FrameSelectionTimestamp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mediapipe::FrameSelectionTimestamp >(arena);
}
template<> PROTOBUF_NOINLINE ::mediapipe::FrameSelectionResult* Arena::CreateMaybeMessage< ::mediapipe::FrameSelectionResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mediapipe::FrameSelectionResult >(arena);
}
template<> PROTOBUF_NOINLINE ::mediapipe::FrameSelectionCriterion* Arena::CreateMaybeMessage< ::mediapipe::FrameSelectionCriterion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mediapipe::FrameSelectionCriterion >(arena);
}
template<> PROTOBUF_NOINLINE ::mediapipe::FrameSelectionOptions* Arena::CreateMaybeMessage< ::mediapipe::FrameSelectionOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mediapipe::FrameSelectionOptions >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <x/google/protobuf/port_undef.inc>
