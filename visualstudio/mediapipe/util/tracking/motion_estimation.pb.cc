// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mediapipe/util/tracking/motion_estimation.proto

#include "mediapipe/util/tracking/motion_estimation.pb.h"

#include <algorithm>

#include <x/google/protobuf/io/coded_stream.h>
#include <x/google/protobuf/extension_set.h>
#include <x/google/protobuf/wire_format_lite.h>
#include <x/google/protobuf/descriptor.h>
#include <x/google/protobuf/generated_message_reflection.h>
#include <x/google/protobuf/reflection_ops.h>
#include <x/google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <x/google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace mediapipe {
constexpr MotionEstimationOptions_IrlsOutlierInitialization::MotionEstimationOptions_IrlsOutlierInitialization(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : activated_(false)
  , rounds_(100)
  , cutoff_(0.003f){}
struct MotionEstimationOptions_IrlsOutlierInitializationDefaultTypeInternal {
  constexpr MotionEstimationOptions_IrlsOutlierInitializationDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MotionEstimationOptions_IrlsOutlierInitializationDefaultTypeInternal() {}
  union {
    MotionEstimationOptions_IrlsOutlierInitialization _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MotionEstimationOptions_IrlsOutlierInitializationDefaultTypeInternal _MotionEstimationOptions_IrlsOutlierInitialization_default_instance_;
constexpr MotionEstimationOptions_LongFeatureInitialization::MotionEstimationOptions_LongFeatureInitialization(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : activated_(false)
  , min_length_percentile_(0.95f)
  , upweight_multiplier_(5){}
struct MotionEstimationOptions_LongFeatureInitializationDefaultTypeInternal {
  constexpr MotionEstimationOptions_LongFeatureInitializationDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MotionEstimationOptions_LongFeatureInitializationDefaultTypeInternal() {}
  union {
    MotionEstimationOptions_LongFeatureInitialization _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MotionEstimationOptions_LongFeatureInitializationDefaultTypeInternal _MotionEstimationOptions_LongFeatureInitialization_default_instance_;
constexpr MotionEstimationOptions_IrlsMaskOptions::MotionEstimationOptions_IrlsMaskOptions(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : decay_(0.7f)
  , inlier_score_(0.4f)
  , base_score_(0.2f)
  , min_translation_norm_(0.002f)
  , translation_blend_alpha_(0.7f)
  , translation_prior_increase_(0.2f){}
struct MotionEstimationOptions_IrlsMaskOptionsDefaultTypeInternal {
  constexpr MotionEstimationOptions_IrlsMaskOptionsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MotionEstimationOptions_IrlsMaskOptionsDefaultTypeInternal() {}
  union {
    MotionEstimationOptions_IrlsMaskOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MotionEstimationOptions_IrlsMaskOptionsDefaultTypeInternal _MotionEstimationOptions_IrlsMaskOptions_default_instance_;
constexpr MotionEstimationOptions_JointTrackEstimationOptions::MotionEstimationOptions_JointTrackEstimationOptions(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : temporal_smoothing_(false)
  , num_motion_models_(3)
  , motion_stride_(15){}
struct MotionEstimationOptions_JointTrackEstimationOptionsDefaultTypeInternal {
  constexpr MotionEstimationOptions_JointTrackEstimationOptionsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MotionEstimationOptions_JointTrackEstimationOptionsDefaultTypeInternal() {}
  union {
    MotionEstimationOptions_JointTrackEstimationOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MotionEstimationOptions_JointTrackEstimationOptionsDefaultTypeInternal _MotionEstimationOptions_JointTrackEstimationOptions_default_instance_;
constexpr MotionEstimationOptions_LongFeatureBiasOptions::MotionEstimationOptions_LongFeatureBiasOptions(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : seed_priors_from_bias_(false)
  , total_rounds_(1)
  , inlier_bias_(0.98f)
  , outlier_bias_(0.7f)
  , num_irls_observations_(10)
  , max_irls_change_ratio_(10)
  , inlier_irls_weight_(0.2f)
  , use_spatial_bias_(true)
  , grid_size_(0.04f)
  , spatial_sigma_(0.02f)
  , color_sigma_(20)
  , long_track_threshold_(30)
  , long_track_confidence_fraction_(0.25f)
  , bias_stdev_(1){}
struct MotionEstimationOptions_LongFeatureBiasOptionsDefaultTypeInternal {
  constexpr MotionEstimationOptions_LongFeatureBiasOptionsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MotionEstimationOptions_LongFeatureBiasOptionsDefaultTypeInternal() {}
  union {
    MotionEstimationOptions_LongFeatureBiasOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MotionEstimationOptions_LongFeatureBiasOptionsDefaultTypeInternal _MotionEstimationOptions_LongFeatureBiasOptions_default_instance_;
constexpr MotionEstimationOptions_TranslationBounds::MotionEstimationOptions_TranslationBounds(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : max_acceleration_(20)
  , min_features_(3)
  , frac_max_motion_magnitude_(0.15f)
  , max_motion_stdev_(0.065f)
  , max_motion_stdev_threshold_(0.01f){}
struct MotionEstimationOptions_TranslationBoundsDefaultTypeInternal {
  constexpr MotionEstimationOptions_TranslationBoundsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MotionEstimationOptions_TranslationBoundsDefaultTypeInternal() {}
  union {
    MotionEstimationOptions_TranslationBounds _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MotionEstimationOptions_TranslationBoundsDefaultTypeInternal _MotionEstimationOptions_TranslationBounds_default_instance_;
constexpr MotionEstimationOptions_SimilarityBounds::MotionEstimationOptions_SimilarityBounds(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : frac_inlier_threshold_(0)
  , only_stable_input_(true)
  , min_inlier_fraction_(0.2f)
  , min_inliers_(30)
  , lower_scale_(0.8f)
  , upper_scale_(1.25f)
  , limit_rotation_(0.25f)
  , inlier_threshold_(4)
  , strict_inlier_threshold_(0.5f){}
struct MotionEstimationOptions_SimilarityBoundsDefaultTypeInternal {
  constexpr MotionEstimationOptions_SimilarityBoundsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MotionEstimationOptions_SimilarityBoundsDefaultTypeInternal() {}
  union {
    MotionEstimationOptions_SimilarityBounds _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MotionEstimationOptions_SimilarityBoundsDefaultTypeInternal _MotionEstimationOptions_SimilarityBounds_default_instance_;
constexpr MotionEstimationOptions_HomographyBounds::MotionEstimationOptions_HomographyBounds(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : frac_registration_threshold_(0)
  , frac_inlier_threshold_(0.002f)
  , lower_scale_(0.8f)
  , upper_scale_(1.25f)
  , limit_rotation_(0.25f)
  , limit_perspective_(0.0004f)
  , registration_threshold_(0.1f)
  , min_inlier_coverage_(0.3f){}
struct MotionEstimationOptions_HomographyBoundsDefaultTypeInternal {
  constexpr MotionEstimationOptions_HomographyBoundsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MotionEstimationOptions_HomographyBoundsDefaultTypeInternal() {}
  union {
    MotionEstimationOptions_HomographyBounds _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MotionEstimationOptions_HomographyBoundsDefaultTypeInternal _MotionEstimationOptions_HomographyBounds_default_instance_;
constexpr MotionEstimationOptions_MixtureHomographyBounds::MotionEstimationOptions_MixtureHomographyBounds(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : min_inlier_coverage_(0.4f)
  , max_adjacent_outlier_blocks_(5)
  , max_adjacent_empty_blocks_(3)
  , frac_inlier_threshold_(0.0025f){}
struct MotionEstimationOptions_MixtureHomographyBoundsDefaultTypeInternal {
  constexpr MotionEstimationOptions_MixtureHomographyBoundsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MotionEstimationOptions_MixtureHomographyBoundsDefaultTypeInternal() {}
  union {
    MotionEstimationOptions_MixtureHomographyBounds _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MotionEstimationOptions_MixtureHomographyBoundsDefaultTypeInternal _MotionEstimationOptions_MixtureHomographyBounds_default_instance_;
constexpr MotionEstimationOptions_OverlayDetectionOptions::MotionEstimationOptions_OverlayDetectionOptions(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : overlay_min_features_(10)
  , analysis_mask_size_(10)
  , strict_near_zero_motion_(0.2f)
  , strict_max_translation_ratio_(0.2f)
  , loose_near_zero_motion_(1)
  , strict_min_texturedness_(0.1f)
  , overlay_min_ratio_(0.3f){}
struct MotionEstimationOptions_OverlayDetectionOptionsDefaultTypeInternal {
  constexpr MotionEstimationOptions_OverlayDetectionOptionsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MotionEstimationOptions_OverlayDetectionOptionsDefaultTypeInternal() {}
  union {
    MotionEstimationOptions_OverlayDetectionOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MotionEstimationOptions_OverlayDetectionOptionsDefaultTypeInternal _MotionEstimationOptions_OverlayDetectionOptions_default_instance_;
constexpr MotionEstimationOptions_ShotBoundaryOptions::MotionEstimationOptions_ShotBoundaryOptions(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : motion_consistency_threshold_(0.02f)
  , appearance_consistency_threshold_(0.075f){}
struct MotionEstimationOptions_ShotBoundaryOptionsDefaultTypeInternal {
  constexpr MotionEstimationOptions_ShotBoundaryOptionsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MotionEstimationOptions_ShotBoundaryOptionsDefaultTypeInternal() {}
  union {
    MotionEstimationOptions_ShotBoundaryOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MotionEstimationOptions_ShotBoundaryOptionsDefaultTypeInternal _MotionEstimationOptions_ShotBoundaryOptions_default_instance_;
constexpr MotionEstimationOptions::MotionEstimationOptions(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : stable_homography_bounds_(nullptr)
  , stable_translation_bounds_(nullptr)
  , stable_similarity_bounds_(nullptr)
  , stable_mixture_homography_bounds_(nullptr)
  , overlay_detection_options_(nullptr)
  , irls_initialization_(nullptr)
  , irls_mask_options_(nullptr)
  , joint_track_estimation_(nullptr)
  , shot_boundary_options_(nullptr)
  , long_feature_bias_options_(nullptr)
  , long_feature_initialization_(nullptr)
  , mix_homography_estimation_(0)

  , project_valid_motions_down_(false)
  , estimate_similarity_(false)
  , affine_estimation_(0)

  , irls_weight_filter_(0)

  , filter_5_taps_(false)
  , overlay_detection_(false)
  , domain_limited_irls_scaling_(false)
  , deactivate_stable_motion_estimation_(false)
  , homography_exact_denominator_scaling_(false)
  , irls_weights_preinitialized_(false)
  , filter_initialized_irls_weights_(false)
  , feature_density_normalization_(false)
  , homography_perspective_regularizer_(0)
  , linear_similarity_estimation_(4)

  , homography_estimation_(2)

  , num_mixtures_(10)
  , mixture_row_sigma_(0.1f)
  , mixture_regularizer_(0.0001f)
  , irls_rounds_(10)
  , lin_sim_inlier_threshold_(0.003f)
  , mixture_model_mode_(2)

  , feature_grid_size_(0.05f)
  , spatial_sigma_(0.01f)
  , temporal_irls_diameter_(20)
  , temporal_sigma_(5)
  , feature_sigma_(30)
  , estimate_translation_irls_(true)
  , use_exact_homography_estimation_(true)
  , use_highest_accuracy_for_normal_equations_(true)
  , use_only_lin_sim_inliers_for_homography_(true)
  , irls_motion_magnitude_fraction_(0.08f)
  , overlay_analysis_chunk_size_(8)
  , label_empty_frames_as_valid_(true)
  , frame_confidence_weighting_(true)
  , output_refined_irls_weights_(true)
  , irls_use_l0_norm_(true)
  , strict_coverage_scale_(1.333f)
  , mixture_regularizer_levels_(3)
  , mixture_regularizer_base_(2.2f)
  , mixture_rs_analysis_level_(2)
  , homography_irls_weight_initialization_(3)

  , reset_confidence_threshold_(0.4f)
  , irls_prior_scale_(0.2f)
  , coverage_grid_size_(10)
  , estimation_policy_(1)

  , feature_mask_size_(10)
  , irls_mixture_fraction_scale_(1.5f){}
struct MotionEstimationOptionsDefaultTypeInternal {
  constexpr MotionEstimationOptionsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~MotionEstimationOptionsDefaultTypeInternal() {}
  union {
    MotionEstimationOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT MotionEstimationOptionsDefaultTypeInternal _MotionEstimationOptions_default_instance_;
}  // namespace mediapipe
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto[12];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto[8];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization, activated_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization, rounds_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization, cutoff_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_LongFeatureInitialization, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_LongFeatureInitialization, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_LongFeatureInitialization, activated_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_LongFeatureInitialization, min_length_percentile_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_LongFeatureInitialization, upweight_multiplier_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_IrlsMaskOptions, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_IrlsMaskOptions, _internal_metadata_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_IrlsMaskOptions, _extensions_),
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_IrlsMaskOptions, decay_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_IrlsMaskOptions, inlier_score_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_IrlsMaskOptions, base_score_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_IrlsMaskOptions, min_translation_norm_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_IrlsMaskOptions, translation_blend_alpha_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_IrlsMaskOptions, translation_prior_increase_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions, num_motion_models_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions, motion_stride_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions, temporal_smoothing_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions, total_rounds_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions, inlier_bias_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions, outlier_bias_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions, num_irls_observations_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions, max_irls_change_ratio_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions, inlier_irls_weight_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions, bias_stdev_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions, use_spatial_bias_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions, grid_size_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions, spatial_sigma_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions, color_sigma_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions, long_track_threshold_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions, long_track_confidence_fraction_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions, seed_priors_from_bias_),
  1,
  2,
  3,
  4,
  5,
  6,
  13,
  7,
  8,
  9,
  10,
  11,
  12,
  0,
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_TranslationBounds, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_TranslationBounds, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_TranslationBounds, min_features_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_TranslationBounds, frac_max_motion_magnitude_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_TranslationBounds, max_motion_stdev_threshold_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_TranslationBounds, max_motion_stdev_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_TranslationBounds, max_acceleration_),
  1,
  2,
  4,
  3,
  0,
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_SimilarityBounds, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_SimilarityBounds, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_SimilarityBounds, only_stable_input_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_SimilarityBounds, min_inlier_fraction_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_SimilarityBounds, min_inliers_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_SimilarityBounds, lower_scale_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_SimilarityBounds, upper_scale_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_SimilarityBounds, limit_rotation_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_SimilarityBounds, inlier_threshold_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_SimilarityBounds, frac_inlier_threshold_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_SimilarityBounds, strict_inlier_threshold_),
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  0,
  8,
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_HomographyBounds, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_HomographyBounds, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_HomographyBounds, lower_scale_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_HomographyBounds, upper_scale_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_HomographyBounds, limit_rotation_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_HomographyBounds, limit_perspective_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_HomographyBounds, registration_threshold_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_HomographyBounds, frac_registration_threshold_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_HomographyBounds, min_inlier_coverage_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_HomographyBounds, frac_inlier_threshold_),
  2,
  3,
  4,
  5,
  6,
  0,
  7,
  1,
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_MixtureHomographyBounds, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_MixtureHomographyBounds, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_MixtureHomographyBounds, min_inlier_coverage_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_MixtureHomographyBounds, max_adjacent_outlier_blocks_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_MixtureHomographyBounds, max_adjacent_empty_blocks_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_MixtureHomographyBounds, frac_inlier_threshold_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_OverlayDetectionOptions, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_OverlayDetectionOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_OverlayDetectionOptions, analysis_mask_size_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_OverlayDetectionOptions, strict_near_zero_motion_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_OverlayDetectionOptions, strict_max_translation_ratio_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_OverlayDetectionOptions, strict_min_texturedness_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_OverlayDetectionOptions, loose_near_zero_motion_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_OverlayDetectionOptions, overlay_min_ratio_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_OverlayDetectionOptions, overlay_min_features_),
  1,
  2,
  3,
  5,
  4,
  6,
  0,
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_ShotBoundaryOptions, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_ShotBoundaryOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_ShotBoundaryOptions, motion_consistency_threshold_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions_ShotBoundaryOptions, appearance_consistency_threshold_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, _internal_metadata_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, _extensions_),
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, estimate_translation_irls_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, linear_similarity_estimation_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, affine_estimation_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, homography_estimation_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, homography_exact_denominator_scaling_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, use_exact_homography_estimation_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, use_highest_accuracy_for_normal_equations_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, homography_perspective_regularizer_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, mix_homography_estimation_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, num_mixtures_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, mixture_row_sigma_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, mixture_regularizer_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, mixture_regularizer_levels_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, mixture_regularizer_base_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, mixture_rs_analysis_level_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, irls_rounds_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, irls_prior_scale_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, irls_motion_magnitude_fraction_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, irls_mixture_fraction_scale_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, irls_weights_preinitialized_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, filter_initialized_irls_weights_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, irls_initialization_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, feature_density_normalization_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, feature_mask_size_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, long_feature_initialization_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, irls_mask_options_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, joint_track_estimation_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, long_feature_bias_options_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, estimation_policy_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, coverage_grid_size_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, mixture_model_mode_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, use_only_lin_sim_inliers_for_homography_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, lin_sim_inlier_threshold_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, stable_translation_bounds_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, stable_similarity_bounds_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, stable_homography_bounds_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, stable_mixture_homography_bounds_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, strict_coverage_scale_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, label_empty_frames_as_valid_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, feature_grid_size_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, spatial_sigma_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, temporal_irls_diameter_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, temporal_sigma_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, feature_sigma_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, filter_5_taps_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, frame_confidence_weighting_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, reset_confidence_threshold_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, irls_weight_filter_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, overlay_detection_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, overlay_analysis_chunk_size_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, overlay_detection_options_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, shot_boundary_options_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, output_refined_irls_weights_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, homography_irls_weight_initialization_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, irls_use_l0_norm_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, domain_limited_irls_scaling_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, deactivate_stable_motion_estimation_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, project_valid_motions_down_),
  PROTOBUF_FIELD_OFFSET(::mediapipe::MotionEstimationOptions, estimate_similarity_),
  38,
  25,
  14,
  26,
  20,
  39,
  40,
  24,
  11,
  27,
  28,
  29,
  49,
  50,
  51,
  30,
  54,
  42,
  58,
  21,
  22,
  5,
  23,
  57,
  10,
  6,
  7,
  9,
  56,
  55,
  32,
  41,
  31,
  1,
  2,
  0,
  3,
  48,
  44,
  33,
  34,
  35,
  36,
  37,
  16,
  45,
  53,
  15,
  17,
  43,
  4,
  8,
  46,
  52,
  47,
  18,
  19,
  12,
  13,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, sizeof(::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization)},
  { 11, 19, sizeof(::mediapipe::MotionEstimationOptions_LongFeatureInitialization)},
  { 22, 33, sizeof(::mediapipe::MotionEstimationOptions_IrlsMaskOptions)},
  { 39, 47, sizeof(::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions)},
  { 50, 69, sizeof(::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions)},
  { 83, 93, sizeof(::mediapipe::MotionEstimationOptions_TranslationBounds)},
  { 98, 112, sizeof(::mediapipe::MotionEstimationOptions_SimilarityBounds)},
  { 121, 134, sizeof(::mediapipe::MotionEstimationOptions_HomographyBounds)},
  { 142, 151, sizeof(::mediapipe::MotionEstimationOptions_MixtureHomographyBounds)},
  { 155, 167, sizeof(::mediapipe::MotionEstimationOptions_OverlayDetectionOptions)},
  { 174, 181, sizeof(::mediapipe::MotionEstimationOptions_ShotBoundaryOptions)},
  { 183, 247, sizeof(::mediapipe::MotionEstimationOptions)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mediapipe::_MotionEstimationOptions_IrlsOutlierInitialization_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mediapipe::_MotionEstimationOptions_LongFeatureInitialization_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mediapipe::_MotionEstimationOptions_IrlsMaskOptions_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mediapipe::_MotionEstimationOptions_JointTrackEstimationOptions_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mediapipe::_MotionEstimationOptions_LongFeatureBiasOptions_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mediapipe::_MotionEstimationOptions_TranslationBounds_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mediapipe::_MotionEstimationOptions_SimilarityBounds_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mediapipe::_MotionEstimationOptions_HomographyBounds_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mediapipe::_MotionEstimationOptions_MixtureHomographyBounds_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mediapipe::_MotionEstimationOptions_OverlayDetectionOptions_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mediapipe::_MotionEstimationOptions_ShotBoundaryOptions_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::mediapipe::_MotionEstimationOptions_default_instance_),
};

const char descriptor_table_protodef_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n/mediapipe/util/tracking/motion_estimat"
  "ion.proto\022\tmediapipe\"\2675\n\027MotionEstimatio"
  "nOptions\022\'\n\031estimate_translation_irls\030\001 "
  "\001(\010:\004true\022w\n\034linear_similarity_estimatio"
  "n\030\003 \001(\0162=.mediapipe.MotionEstimationOpti"
  "ons.LinearSimilarityEstimation:\022ESTIMATI"
  "ON_LS_IRLS\022f\n\021affine_estimation\030\036 \001(\01623."
  "mediapipe.MotionEstimationOptions.Affine"
  "Estimation:\026ESTIMATION_AFFINE_NONE\022m\n\025ho"
  "mography_estimation\030\005 \001(\01627.mediapipe.Mo"
  "tionEstimationOptions.HomographyEstimati"
  "on:\025ESTIMATION_HOMOG_IRLS\0223\n$homography_"
  "exact_denominator_scaling\0305 \001(\010:\005false\022-"
  "\n\037use_exact_homography_estimation\0306 \001(\010:"
  "\004true\0227\n)use_highest_accuracy_for_normal"
  "_equations\0307 \001(\010:\004true\022-\n\"homography_per"
  "spective_regularizer\030= \001(\002:\0010\022|\n\031mix_hom"
  "ography_estimation\030\014 \001(\0162>.mediapipe.Mot"
  "ionEstimationOptions.MixtureHomographyEs"
  "timation:\031ESTIMATION_HOMOG_MIX_NONE\022\030\n\014n"
  "um_mixtures\030\r \001(\005:\00210\022\036\n\021mixture_row_sig"
  "ma\030\016 \001(\002:\0030.1\022#\n\023mixture_regularizer\030\017 \001"
  "(\002:\0060.0001\022%\n\032mixture_regularizer_levels"
  "\030* \001(\002:\0013\022%\n\030mixture_regularizer_base\030+ "
  "\001(\002:\0032.2\022$\n\031mixture_rs_analysis_level\030, "
  "\001(\005:\0012\022\027\n\013irls_rounds\030\021 \001(\005:\00210\022\035\n\020irls_"
  "prior_scale\0302 \001(\002:\0030.2\022,\n\036irls_motion_ma"
  "gnitude_fraction\030\037 \001(\002:\0040.08\022(\n\033irls_mix"
  "ture_fraction_scale\030D \001(\002:\0031.5\022*\n\033irls_w"
  "eights_preinitialized\030\' \001(\010:\005false\022.\n\037fi"
  "lter_initialized_irls_weights\030C \001(\010:\005fal"
  "se\022Y\n\023irls_initialization\0308 \001(\0132<.mediap"
  "ipe.MotionEstimationOptions.IrlsOutlierI"
  "nitialization\022,\n\035feature_density_normali"
  "zation\030> \001(\010:\005false\022\035\n\021feature_mask_size"
  "\030\? \001(\005:\00210\022a\n\033long_feature_initializatio"
  "n\030B \001(\0132<.mediapipe.MotionEstimationOpti"
  "ons.LongFeatureInitialization\022M\n\021irls_ma"
  "sk_options\0309 \001(\01322.mediapipe.MotionEstim"
  "ationOptions.IrlsMaskOptions\022^\n\026joint_tr"
  "ack_estimation\030; \001(\0132>.mediapipe.MotionE"
  "stimationOptions.JointTrackEstimationOpt"
  "ions\022\\\n\031long_feature_bias_options\030@ \001(\0132"
  "9.mediapipe.MotionEstimationOptions.Long"
  "FeatureBiasOptions\022d\n\021estimation_policy\030"
  ": \001(\01623.mediapipe.MotionEstimationOption"
  "s.EstimationPolicy:\024INDEPENDENT_PARALLEL"
  "\022\036\n\022coverage_grid_size\0303 \001(\005:\00210\022f\n\022mixt"
  "ure_model_mode\030\027 \001(\01623.mediapipe.MotionE"
  "stimationOptions.MixtureModelMode:\025SKEW_"
  "ROTATION_MIXTURE\0225\n\'use_only_lin_sim_inl"
  "iers_for_homography\030\006 \001(\010:\004true\022\'\n\030lin_s"
  "im_inlier_threshold\030\024 \001(\002:\0050.003\022W\n\031stab"
  "le_translation_bounds\030  \001(\01324.mediapipe."
  "MotionEstimationOptions.TranslationBound"
  "s\022U\n\030stable_similarity_bounds\030! \001(\01323.me"
  "diapipe.MotionEstimationOptions.Similari"
  "tyBounds\022U\n\030stable_homography_bounds\030\013 \001"
  "(\01323.mediapipe.MotionEstimationOptions.H"
  "omographyBounds\022d\n stable_mixture_homogr"
  "aphy_bounds\030\" \001(\0132:.mediapipe.MotionEsti"
  "mationOptions.MixtureHomographyBounds\022$\n"
  "\025strict_coverage_scale\030) \001(\002:\0051.333\022)\n\033l"
  "abel_empty_frames_as_valid\030\026 \001(\010:\004true\022\037"
  "\n\021feature_grid_size\030\030 \001(\002:\0040.05\022\033\n\rspati"
  "al_sigma\030\031 \001(\002:\0040.01\022\"\n\026temporal_irls_di"
  "ameter\030\032 \001(\005:\00220\022\031\n\016temporal_sigma\030\033 \001(\002"
  ":\0015\022\031\n\rfeature_sigma\030\034 \001(\002:\00230\022\034\n\rfilter"
  "_5_taps\030\035 \001(\010:\005false\022(\n\032frame_confidence"
  "_weighting\0300 \001(\010:\004true\022\'\n\032reset_confiden"
  "ce_threshold\0301 \001(\002:\0030.4\022a\n\022irls_weight_f"
  "ilter\030# \001(\01623.mediapipe.MotionEstimation"
  "Options.IRLSWeightFilter:\020IRLS_FILTER_NO"
  "NE\022 \n\021overlay_detection\030$ \001(\010:\005false\022&\n\033"
  "overlay_analysis_chunk_size\030% \001(\005:\0018\022]\n\031"
  "overlay_detection_options\030& \001(\0132:.mediap"
  "ipe.MotionEstimationOptions.OverlayDetec"
  "tionOptions\022U\n\025shot_boundary_options\030< \001"
  "(\01326.mediapipe.MotionEstimationOptions.S"
  "hotBoundaryOptions\022)\n\033output_refined_irl"
  "s_weights\030( \001(\010:\004true\022\224\001\n%homography_irl"
  "s_weight_initialization\030- \001(\0162E.mediapip"
  "e.MotionEstimationOptions.HomographyIrls"
  "WeightInitialization:\036IRLS_WEIGHT_PERIME"
  "TER_GAUSSIAN\022\036\n\020irls_use_l0_norm\030. \001(\010:\004"
  "true\022*\n\033domain_limited_irls_scaling\030A \001("
  "\010:\005false\0222\n#deactivate_stable_motion_est"
  "imation\030/ \001(\010:\005false\022)\n\032project_valid_mo"
  "tions_down\0304 \001(\010:\005false\022\037\n\023estimate_simi"
  "larity\030\002 \001(\010B\002\030\001\032a\n\031IrlsOutlierInitializ"
  "ation\022\030\n\tactivated\030\001 \001(\010:\005false\022\023\n\006round"
  "s\030\002 \001(\005:\003100\022\025\n\006cutoff\030\003 \001(\002:\0050.003\032z\n\031L"
  "ongFeatureInitialization\022\030\n\tactivated\030\001 "
  "\001(\010:\005false\022#\n\025min_length_percentile\030\002 \001("
  "\002:\0040.95\022\036\n\023upweight_multiplier\030\003 \001(\002:\0015\032"
  "\323\001\n\017IrlsMaskOptions\022\022\n\005decay\030\002 \001(\002:\0030.7\022"
  "\031\n\014inlier_score\030\003 \001(\002:\0030.4\022\027\n\nbase_score"
  "\030\004 \001(\002:\0030.2\022#\n\024min_translation_norm\030\005 \001("
  "\002:\0050.002\022$\n\027translation_blend_alpha\030\006 \001("
  "\002:\0030.7\022\'\n\032translation_prior_increase\030\007 \001"
  "(\002:\0030.2*\004\010\001\020\002\032y\n\033JointTrackEstimationOpt"
  "ions\022\034\n\021num_motion_models\030\001 \001(\005:\0013\022\031\n\rmo"
  "tion_stride\030\002 \001(\005:\00215\022!\n\022temporal_smooth"
  "ing\030\003 \001(\010:\005false\032\312\003\n\026LongFeatureBiasOpti"
  "ons\022\027\n\014total_rounds\030\r \001(\005:\0011\022\031\n\013inlier_b"
  "ias\030\001 \001(\002:\0040.98\022\031\n\014outlier_bias\030\002 \001(\002:\0030"
  ".7\022!\n\025num_irls_observations\030\003 \001(\005:\00210\022!\n"
  "\025max_irls_change_ratio\030\004 \001(\002:\00210\022\037\n\022inli"
  "er_irls_weight\030\005 \001(\002:\0030.2\022\025\n\nbias_stdev\030"
  "\014 \001(\002:\0011\022\036\n\020use_spatial_bias\030\006 \001(\010:\004true"
  "\022\027\n\tgrid_size\030\007 \001(\002:\0040.04\022\033\n\rspatial_sig"
  "ma\030\010 \001(\002:\0040.02\022\027\n\013color_sigma\030\t \001(\002:\00220\022"
  " \n\024long_track_threshold\030\n \001(\005:\00230\022,\n\036lon"
  "g_track_confidence_fraction\030\013 \001(\002:\0040.25\022"
  "$\n\025seed_priors_from_bias\030\016 \001(\010:\005false\032\276\001"
  "\n\021TranslationBounds\022\027\n\014min_features\030\001 \001("
  "\005:\0013\022\'\n\031frac_max_motion_magnitude\030\002 \001(\002:"
  "\0040.15\022(\n\032max_motion_stdev_threshold\030\004 \001("
  "\002:\0040.01\022\037\n\020max_motion_stdev\030\003 \001(\002:\0050.065"
  "\022\034\n\020max_acceleration\030\005 \001(\002:\00220\032\246\002\n\020Simil"
  "arityBounds\022\037\n\021only_stable_input\030\001 \001(\010:\004"
  "true\022 \n\023min_inlier_fraction\030\002 \001(\002:\0030.2\022\027"
  "\n\013min_inliers\030\003 \001(\002:\00230\022\030\n\013lower_scale\030\004"
  " \001(\002:\0030.8\022\031\n\013upper_scale\030\005 \001(\002:\0041.25\022\034\n\016"
  "limit_rotation\030\006 \001(\002:\0040.25\022\033\n\020inlier_thr"
  "eshold\030\007 \001(\002:\0014\022 \n\025frac_inlier_threshold"
  "\030\010 \001(\002:\0010\022$\n\027strict_inlier_threshold\030\t \001"
  "(\002:\0030.5\032\235\002\n\020HomographyBounds\022\030\n\013lower_sc"
  "ale\030\001 \001(\002:\0030.8\022\031\n\013upper_scale\030\002 \001(\002:\0041.2"
  "5\022\034\n\016limit_rotation\030\003 \001(\002:\0040.25\022!\n\021limit"
  "_perspective\030\004 \001(\002:\0060.0004\022#\n\026registrati"
  "on_threshold\030\005 \001(\002:\0030.1\022&\n\033frac_registra"
  "tion_threshold\030\010 \001(\002:\0010\022 \n\023min_inlier_co"
  "verage\030\006 \001(\002:\0030.3\022$\n\025frac_inlier_thresho"
  "ld\030\007 \001(\002:\0050.002\032\260\001\n\027MixtureHomographyBou"
  "nds\022 \n\023min_inlier_coverage\030\001 \001(\002:\0030.4\022&\n"
  "\033max_adjacent_outlier_blocks\030\002 \001(\005:\0015\022$\n"
  "\031max_adjacent_empty_blocks\030\003 \001(\005:\0013\022%\n\025f"
  "rac_inlier_threshold\030\007 \001(\002:\0060.0025\032\225\002\n\027O"
  "verlayDetectionOptions\022\036\n\022analysis_mask_"
  "size\030\001 \001(\005:\00210\022$\n\027strict_near_zero_motio"
  "n\030\002 \001(\002:\0030.2\022)\n\034strict_max_translation_r"
  "atio\030\003 \001(\002:\0030.2\022$\n\027strict_min_texturedne"
  "ss\030\005 \001(\002:\0030.1\022!\n\026loose_near_zero_motion\030"
  "\004 \001(\002:\0011\022\036\n\021overlay_min_ratio\030\006 \001(\002:\0030.3"
  "\022 \n\024overlay_min_features\030\007 \001(\002:\00210\032r\n\023Sh"
  "otBoundaryOptions\022*\n\034motion_consistency_"
  "threshold\030\001 \001(\002:\0040.02\022/\n appearance_cons"
  "istency_threshold\030\002 \001(\002:\0050.075\"\225\001\n\032Linea"
  "rSimilarityEstimation\022\026\n\022ESTIMATION_LS_N"
  "ONE\020\000\022\024\n\020ESTIMATION_LS_L2\020\001\022\026\n\022ESTIMATIO"
  "N_LS_IRLS\020\004\022\033\n\027ESTIMATION_LS_L2_RANSAC\020\002"
  "\022\024\n\020ESTIMATION_LS_L1\020\003\"d\n\020AffineEstimati"
  "on\022\032\n\026ESTIMATION_AFFINE_NONE\020\000\022\030\n\024ESTIMA"
  "TION_AFFINE_L2\020\001\022\032\n\026ESTIMATION_AFFINE_IR"
  "LS\020\002\"e\n\024HomographyEstimation\022\031\n\025ESTIMATI"
  "ON_HOMOG_NONE\020\000\022\027\n\023ESTIMATION_HOMOG_L2\020\001"
  "\022\031\n\025ESTIMATION_HOMOG_IRLS\020\002\"x\n\033MixtureHo"
  "mographyEstimation\022\035\n\031ESTIMATION_HOMOG_M"
  "IX_NONE\020\000\022\033\n\027ESTIMATION_HOMOG_MIX_L2\020\001\022\035"
  "\n\031ESTIMATION_HOMOG_MIX_IRLS\020\002\"}\n\020Estimat"
  "ionPolicy\022\030\n\024INDEPENDENT_PARALLEL\020\001\022\026\n\022T"
  "EMPORAL_IRLS_MASK\020\002\022\036\n\032TEMPORAL_LONG_FEA"
  "TURE_BIAS\020\004\022\027\n\023JOINTLY_FROM_TRACKS\020\003\"X\n\020"
  "MixtureModelMode\022\020\n\014FULL_MIXTURE\020\000\022\027\n\023TR"
  "ANSLATION_MIXTURE\020\001\022\031\n\025SKEW_ROTATION_MIX"
  "TURE\020\002\"b\n\020IRLSWeightFilter\022\024\n\020IRLS_FILTE"
  "R_NONE\020\000\022\027\n\023IRLS_FILTER_TEXTURE\020\001\022\037\n\033IRL"
  "S_FILTER_CORNER_RESPONSE\020\002\"\207\001\n\"Homograph"
  "yIrlsWeightInitialization\022\034\n\030IRLS_WEIGHT"
  "_CONSTANT_ONE\020\001\022\037\n\033IRLS_WEIGHT_CENTER_GA"
  "USSIAN\020\002\022\"\n\036IRLS_WEIGHT_PERIMETER_GAUSSI"
  "AN\020\003*\004\010\007\020\010*\004\010\010\020\t*\004\010\020\020\021"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto = {
  false, false, 6902, descriptor_table_protodef_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto, "mediapipe/util/tracking/motion_estimation.proto", 
  &descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto_once, nullptr, 0, 12,
  schemas, file_default_instances, TableStruct_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto::offsets,
  file_level_metadata_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto, file_level_enum_descriptors_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto, file_level_service_descriptors_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto_getter() {
  return &descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto(&descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto);
namespace mediapipe {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MotionEstimationOptions_LinearSimilarityEstimation_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto);
  return file_level_enum_descriptors_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto[0];
}
bool MotionEstimationOptions_LinearSimilarityEstimation_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr MotionEstimationOptions_LinearSimilarityEstimation MotionEstimationOptions::ESTIMATION_LS_NONE;
constexpr MotionEstimationOptions_LinearSimilarityEstimation MotionEstimationOptions::ESTIMATION_LS_L2;
constexpr MotionEstimationOptions_LinearSimilarityEstimation MotionEstimationOptions::ESTIMATION_LS_IRLS;
constexpr MotionEstimationOptions_LinearSimilarityEstimation MotionEstimationOptions::ESTIMATION_LS_L2_RANSAC;
constexpr MotionEstimationOptions_LinearSimilarityEstimation MotionEstimationOptions::ESTIMATION_LS_L1;
constexpr MotionEstimationOptions_LinearSimilarityEstimation MotionEstimationOptions::LinearSimilarityEstimation_MIN;
constexpr MotionEstimationOptions_LinearSimilarityEstimation MotionEstimationOptions::LinearSimilarityEstimation_MAX;
constexpr int MotionEstimationOptions::LinearSimilarityEstimation_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MotionEstimationOptions_AffineEstimation_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto);
  return file_level_enum_descriptors_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto[1];
}
bool MotionEstimationOptions_AffineEstimation_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr MotionEstimationOptions_AffineEstimation MotionEstimationOptions::ESTIMATION_AFFINE_NONE;
constexpr MotionEstimationOptions_AffineEstimation MotionEstimationOptions::ESTIMATION_AFFINE_L2;
constexpr MotionEstimationOptions_AffineEstimation MotionEstimationOptions::ESTIMATION_AFFINE_IRLS;
constexpr MotionEstimationOptions_AffineEstimation MotionEstimationOptions::AffineEstimation_MIN;
constexpr MotionEstimationOptions_AffineEstimation MotionEstimationOptions::AffineEstimation_MAX;
constexpr int MotionEstimationOptions::AffineEstimation_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MotionEstimationOptions_HomographyEstimation_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto);
  return file_level_enum_descriptors_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto[2];
}
bool MotionEstimationOptions_HomographyEstimation_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr MotionEstimationOptions_HomographyEstimation MotionEstimationOptions::ESTIMATION_HOMOG_NONE;
constexpr MotionEstimationOptions_HomographyEstimation MotionEstimationOptions::ESTIMATION_HOMOG_L2;
constexpr MotionEstimationOptions_HomographyEstimation MotionEstimationOptions::ESTIMATION_HOMOG_IRLS;
constexpr MotionEstimationOptions_HomographyEstimation MotionEstimationOptions::HomographyEstimation_MIN;
constexpr MotionEstimationOptions_HomographyEstimation MotionEstimationOptions::HomographyEstimation_MAX;
constexpr int MotionEstimationOptions::HomographyEstimation_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MotionEstimationOptions_MixtureHomographyEstimation_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto);
  return file_level_enum_descriptors_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto[3];
}
bool MotionEstimationOptions_MixtureHomographyEstimation_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr MotionEstimationOptions_MixtureHomographyEstimation MotionEstimationOptions::ESTIMATION_HOMOG_MIX_NONE;
constexpr MotionEstimationOptions_MixtureHomographyEstimation MotionEstimationOptions::ESTIMATION_HOMOG_MIX_L2;
constexpr MotionEstimationOptions_MixtureHomographyEstimation MotionEstimationOptions::ESTIMATION_HOMOG_MIX_IRLS;
constexpr MotionEstimationOptions_MixtureHomographyEstimation MotionEstimationOptions::MixtureHomographyEstimation_MIN;
constexpr MotionEstimationOptions_MixtureHomographyEstimation MotionEstimationOptions::MixtureHomographyEstimation_MAX;
constexpr int MotionEstimationOptions::MixtureHomographyEstimation_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MotionEstimationOptions_EstimationPolicy_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto);
  return file_level_enum_descriptors_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto[4];
}
bool MotionEstimationOptions_EstimationPolicy_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr MotionEstimationOptions_EstimationPolicy MotionEstimationOptions::INDEPENDENT_PARALLEL;
constexpr MotionEstimationOptions_EstimationPolicy MotionEstimationOptions::TEMPORAL_IRLS_MASK;
constexpr MotionEstimationOptions_EstimationPolicy MotionEstimationOptions::TEMPORAL_LONG_FEATURE_BIAS;
constexpr MotionEstimationOptions_EstimationPolicy MotionEstimationOptions::JOINTLY_FROM_TRACKS;
constexpr MotionEstimationOptions_EstimationPolicy MotionEstimationOptions::EstimationPolicy_MIN;
constexpr MotionEstimationOptions_EstimationPolicy MotionEstimationOptions::EstimationPolicy_MAX;
constexpr int MotionEstimationOptions::EstimationPolicy_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MotionEstimationOptions_MixtureModelMode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto);
  return file_level_enum_descriptors_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto[5];
}
bool MotionEstimationOptions_MixtureModelMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr MotionEstimationOptions_MixtureModelMode MotionEstimationOptions::FULL_MIXTURE;
constexpr MotionEstimationOptions_MixtureModelMode MotionEstimationOptions::TRANSLATION_MIXTURE;
constexpr MotionEstimationOptions_MixtureModelMode MotionEstimationOptions::SKEW_ROTATION_MIXTURE;
constexpr MotionEstimationOptions_MixtureModelMode MotionEstimationOptions::MixtureModelMode_MIN;
constexpr MotionEstimationOptions_MixtureModelMode MotionEstimationOptions::MixtureModelMode_MAX;
constexpr int MotionEstimationOptions::MixtureModelMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MotionEstimationOptions_IRLSWeightFilter_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto);
  return file_level_enum_descriptors_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto[6];
}
bool MotionEstimationOptions_IRLSWeightFilter_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr MotionEstimationOptions_IRLSWeightFilter MotionEstimationOptions::IRLS_FILTER_NONE;
constexpr MotionEstimationOptions_IRLSWeightFilter MotionEstimationOptions::IRLS_FILTER_TEXTURE;
constexpr MotionEstimationOptions_IRLSWeightFilter MotionEstimationOptions::IRLS_FILTER_CORNER_RESPONSE;
constexpr MotionEstimationOptions_IRLSWeightFilter MotionEstimationOptions::IRLSWeightFilter_MIN;
constexpr MotionEstimationOptions_IRLSWeightFilter MotionEstimationOptions::IRLSWeightFilter_MAX;
constexpr int MotionEstimationOptions::IRLSWeightFilter_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MotionEstimationOptions_HomographyIrlsWeightInitialization_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto);
  return file_level_enum_descriptors_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto[7];
}
bool MotionEstimationOptions_HomographyIrlsWeightInitialization_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr MotionEstimationOptions_HomographyIrlsWeightInitialization MotionEstimationOptions::IRLS_WEIGHT_CONSTANT_ONE;
constexpr MotionEstimationOptions_HomographyIrlsWeightInitialization MotionEstimationOptions::IRLS_WEIGHT_CENTER_GAUSSIAN;
constexpr MotionEstimationOptions_HomographyIrlsWeightInitialization MotionEstimationOptions::IRLS_WEIGHT_PERIMETER_GAUSSIAN;
constexpr MotionEstimationOptions_HomographyIrlsWeightInitialization MotionEstimationOptions::HomographyIrlsWeightInitialization_MIN;
constexpr MotionEstimationOptions_HomographyIrlsWeightInitialization MotionEstimationOptions::HomographyIrlsWeightInitialization_MAX;
constexpr int MotionEstimationOptions::HomographyIrlsWeightInitialization_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)

// ===================================================================

class MotionEstimationOptions_IrlsOutlierInitialization::_Internal {
 public:
  using HasBits = decltype(std::declval<MotionEstimationOptions_IrlsOutlierInitialization>()._has_bits_);
  static void set_has_activated(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_rounds(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_cutoff(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

MotionEstimationOptions_IrlsOutlierInitialization::MotionEstimationOptions_IrlsOutlierInitialization(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mediapipe.MotionEstimationOptions.IrlsOutlierInitialization)
}
MotionEstimationOptions_IrlsOutlierInitialization::MotionEstimationOptions_IrlsOutlierInitialization(const MotionEstimationOptions_IrlsOutlierInitialization& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&activated_, &from.activated_,
    static_cast<size_t>(reinterpret_cast<char*>(&cutoff_) -
    reinterpret_cast<char*>(&activated_)) + sizeof(cutoff_));
  // @@protoc_insertion_point(copy_constructor:mediapipe.MotionEstimationOptions.IrlsOutlierInitialization)
}

void MotionEstimationOptions_IrlsOutlierInitialization::SharedCtor() {
activated_ = false;
rounds_ = 100;
cutoff_ = 0.003f;
}

MotionEstimationOptions_IrlsOutlierInitialization::~MotionEstimationOptions_IrlsOutlierInitialization() {
  // @@protoc_insertion_point(destructor:mediapipe.MotionEstimationOptions.IrlsOutlierInitialization)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void MotionEstimationOptions_IrlsOutlierInitialization::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void MotionEstimationOptions_IrlsOutlierInitialization::ArenaDtor(void* object) {
  MotionEstimationOptions_IrlsOutlierInitialization* _this = reinterpret_cast< MotionEstimationOptions_IrlsOutlierInitialization* >(object);
  (void)_this;
}
void MotionEstimationOptions_IrlsOutlierInitialization::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MotionEstimationOptions_IrlsOutlierInitialization::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MotionEstimationOptions_IrlsOutlierInitialization::Clear() {
// @@protoc_insertion_point(message_clear_start:mediapipe.MotionEstimationOptions.IrlsOutlierInitialization)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    activated_ = false;
    rounds_ = 100;
    cutoff_ = 0.003f;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MotionEstimationOptions_IrlsOutlierInitialization::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool activated = 1 [default = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_activated(&has_bits);
          activated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 rounds = 2 [default = 100];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_rounds(&has_bits);
          rounds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float cutoff = 3 [default = 0.003];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_cutoff(&has_bits);
          cutoff_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* MotionEstimationOptions_IrlsOutlierInitialization::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mediapipe.MotionEstimationOptions.IrlsOutlierInitialization)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool activated = 1 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_activated(), target);
  }

  // optional int32 rounds = 2 [default = 100];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_rounds(), target);
  }

  // optional float cutoff = 3 [default = 0.003];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_cutoff(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mediapipe.MotionEstimationOptions.IrlsOutlierInitialization)
  return target;
}

size_t MotionEstimationOptions_IrlsOutlierInitialization::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mediapipe.MotionEstimationOptions.IrlsOutlierInitialization)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bool activated = 1 [default = false];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional int32 rounds = 2 [default = 100];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_rounds());
    }

    // optional float cutoff = 3 [default = 0.003];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MotionEstimationOptions_IrlsOutlierInitialization::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mediapipe.MotionEstimationOptions.IrlsOutlierInitialization)
  GOOGLE_DCHECK_NE(&from, this);
  const MotionEstimationOptions_IrlsOutlierInitialization* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<MotionEstimationOptions_IrlsOutlierInitialization>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mediapipe.MotionEstimationOptions.IrlsOutlierInitialization)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mediapipe.MotionEstimationOptions.IrlsOutlierInitialization)
    MergeFrom(*source);
  }
}

void MotionEstimationOptions_IrlsOutlierInitialization::MergeFrom(const MotionEstimationOptions_IrlsOutlierInitialization& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mediapipe.MotionEstimationOptions.IrlsOutlierInitialization)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      activated_ = from.activated_;
    }
    if (cached_has_bits & 0x00000002u) {
      rounds_ = from.rounds_;
    }
    if (cached_has_bits & 0x00000004u) {
      cutoff_ = from.cutoff_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void MotionEstimationOptions_IrlsOutlierInitialization::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mediapipe.MotionEstimationOptions.IrlsOutlierInitialization)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MotionEstimationOptions_IrlsOutlierInitialization::CopyFrom(const MotionEstimationOptions_IrlsOutlierInitialization& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mediapipe.MotionEstimationOptions.IrlsOutlierInitialization)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MotionEstimationOptions_IrlsOutlierInitialization::IsInitialized() const {
  return true;
}

void MotionEstimationOptions_IrlsOutlierInitialization::InternalSwap(MotionEstimationOptions_IrlsOutlierInitialization* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(activated_, other->activated_);
  swap(rounds_, other->rounds_);
  swap(cutoff_, other->cutoff_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MotionEstimationOptions_IrlsOutlierInitialization::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto_getter, &descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto_once,
      file_level_metadata_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto[0]);
}

// ===================================================================

class MotionEstimationOptions_LongFeatureInitialization::_Internal {
 public:
  using HasBits = decltype(std::declval<MotionEstimationOptions_LongFeatureInitialization>()._has_bits_);
  static void set_has_activated(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_min_length_percentile(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_upweight_multiplier(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

MotionEstimationOptions_LongFeatureInitialization::MotionEstimationOptions_LongFeatureInitialization(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mediapipe.MotionEstimationOptions.LongFeatureInitialization)
}
MotionEstimationOptions_LongFeatureInitialization::MotionEstimationOptions_LongFeatureInitialization(const MotionEstimationOptions_LongFeatureInitialization& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&activated_, &from.activated_,
    static_cast<size_t>(reinterpret_cast<char*>(&upweight_multiplier_) -
    reinterpret_cast<char*>(&activated_)) + sizeof(upweight_multiplier_));
  // @@protoc_insertion_point(copy_constructor:mediapipe.MotionEstimationOptions.LongFeatureInitialization)
}

void MotionEstimationOptions_LongFeatureInitialization::SharedCtor() {
activated_ = false;
min_length_percentile_ = 0.95f;
upweight_multiplier_ = 5;
}

MotionEstimationOptions_LongFeatureInitialization::~MotionEstimationOptions_LongFeatureInitialization() {
  // @@protoc_insertion_point(destructor:mediapipe.MotionEstimationOptions.LongFeatureInitialization)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void MotionEstimationOptions_LongFeatureInitialization::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void MotionEstimationOptions_LongFeatureInitialization::ArenaDtor(void* object) {
  MotionEstimationOptions_LongFeatureInitialization* _this = reinterpret_cast< MotionEstimationOptions_LongFeatureInitialization* >(object);
  (void)_this;
}
void MotionEstimationOptions_LongFeatureInitialization::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MotionEstimationOptions_LongFeatureInitialization::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MotionEstimationOptions_LongFeatureInitialization::Clear() {
// @@protoc_insertion_point(message_clear_start:mediapipe.MotionEstimationOptions.LongFeatureInitialization)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    activated_ = false;
    min_length_percentile_ = 0.95f;
    upweight_multiplier_ = 5;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MotionEstimationOptions_LongFeatureInitialization::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool activated = 1 [default = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_activated(&has_bits);
          activated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float min_length_percentile = 2 [default = 0.95];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_min_length_percentile(&has_bits);
          min_length_percentile_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float upweight_multiplier = 3 [default = 5];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_upweight_multiplier(&has_bits);
          upweight_multiplier_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* MotionEstimationOptions_LongFeatureInitialization::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mediapipe.MotionEstimationOptions.LongFeatureInitialization)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool activated = 1 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_activated(), target);
  }

  // optional float min_length_percentile = 2 [default = 0.95];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_min_length_percentile(), target);
  }

  // optional float upweight_multiplier = 3 [default = 5];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_upweight_multiplier(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mediapipe.MotionEstimationOptions.LongFeatureInitialization)
  return target;
}

size_t MotionEstimationOptions_LongFeatureInitialization::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mediapipe.MotionEstimationOptions.LongFeatureInitialization)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bool activated = 1 [default = false];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional float min_length_percentile = 2 [default = 0.95];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float upweight_multiplier = 3 [default = 5];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MotionEstimationOptions_LongFeatureInitialization::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mediapipe.MotionEstimationOptions.LongFeatureInitialization)
  GOOGLE_DCHECK_NE(&from, this);
  const MotionEstimationOptions_LongFeatureInitialization* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<MotionEstimationOptions_LongFeatureInitialization>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mediapipe.MotionEstimationOptions.LongFeatureInitialization)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mediapipe.MotionEstimationOptions.LongFeatureInitialization)
    MergeFrom(*source);
  }
}

void MotionEstimationOptions_LongFeatureInitialization::MergeFrom(const MotionEstimationOptions_LongFeatureInitialization& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mediapipe.MotionEstimationOptions.LongFeatureInitialization)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      activated_ = from.activated_;
    }
    if (cached_has_bits & 0x00000002u) {
      min_length_percentile_ = from.min_length_percentile_;
    }
    if (cached_has_bits & 0x00000004u) {
      upweight_multiplier_ = from.upweight_multiplier_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void MotionEstimationOptions_LongFeatureInitialization::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mediapipe.MotionEstimationOptions.LongFeatureInitialization)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MotionEstimationOptions_LongFeatureInitialization::CopyFrom(const MotionEstimationOptions_LongFeatureInitialization& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mediapipe.MotionEstimationOptions.LongFeatureInitialization)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MotionEstimationOptions_LongFeatureInitialization::IsInitialized() const {
  return true;
}

void MotionEstimationOptions_LongFeatureInitialization::InternalSwap(MotionEstimationOptions_LongFeatureInitialization* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(activated_, other->activated_);
  swap(min_length_percentile_, other->min_length_percentile_);
  swap(upweight_multiplier_, other->upweight_multiplier_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MotionEstimationOptions_LongFeatureInitialization::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto_getter, &descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto_once,
      file_level_metadata_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto[1]);
}

// ===================================================================

class MotionEstimationOptions_IrlsMaskOptions::_Internal {
 public:
  using HasBits = decltype(std::declval<MotionEstimationOptions_IrlsMaskOptions>()._has_bits_);
  static void set_has_decay(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_inlier_score(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_base_score(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_min_translation_norm(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_translation_blend_alpha(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_translation_prior_increase(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

MotionEstimationOptions_IrlsMaskOptions::MotionEstimationOptions_IrlsMaskOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  _extensions_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mediapipe.MotionEstimationOptions.IrlsMaskOptions)
}
MotionEstimationOptions_IrlsMaskOptions::MotionEstimationOptions_IrlsMaskOptions(const MotionEstimationOptions_IrlsMaskOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _extensions_.MergeFrom(from._extensions_);
  ::memcpy(&decay_, &from.decay_,
    static_cast<size_t>(reinterpret_cast<char*>(&translation_prior_increase_) -
    reinterpret_cast<char*>(&decay_)) + sizeof(translation_prior_increase_));
  // @@protoc_insertion_point(copy_constructor:mediapipe.MotionEstimationOptions.IrlsMaskOptions)
}

void MotionEstimationOptions_IrlsMaskOptions::SharedCtor() {
decay_ = 0.7f;
inlier_score_ = 0.4f;
base_score_ = 0.2f;
min_translation_norm_ = 0.002f;
translation_blend_alpha_ = 0.7f;
translation_prior_increase_ = 0.2f;
}

MotionEstimationOptions_IrlsMaskOptions::~MotionEstimationOptions_IrlsMaskOptions() {
  // @@protoc_insertion_point(destructor:mediapipe.MotionEstimationOptions.IrlsMaskOptions)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void MotionEstimationOptions_IrlsMaskOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void MotionEstimationOptions_IrlsMaskOptions::ArenaDtor(void* object) {
  MotionEstimationOptions_IrlsMaskOptions* _this = reinterpret_cast< MotionEstimationOptions_IrlsMaskOptions* >(object);
  (void)_this;
}
void MotionEstimationOptions_IrlsMaskOptions::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MotionEstimationOptions_IrlsMaskOptions::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MotionEstimationOptions_IrlsMaskOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:mediapipe.MotionEstimationOptions.IrlsMaskOptions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _extensions_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    decay_ = 0.7f;
    inlier_score_ = 0.4f;
    base_score_ = 0.2f;
    min_translation_norm_ = 0.002f;
    translation_blend_alpha_ = 0.7f;
    translation_prior_increase_ = 0.2f;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MotionEstimationOptions_IrlsMaskOptions::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float decay = 2 [default = 0.7];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_decay(&has_bits);
          decay_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float inlier_score = 3 [default = 0.4];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_inlier_score(&has_bits);
          inlier_score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float base_score = 4 [default = 0.2];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_base_score(&has_bits);
          base_score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float min_translation_norm = 5 [default = 0.002];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_min_translation_norm(&has_bits);
          min_translation_norm_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float translation_blend_alpha = 6 [default = 0.7];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          _Internal::set_has_translation_blend_alpha(&has_bits);
          translation_blend_alpha_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float translation_prior_increase = 7 [default = 0.2];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          _Internal::set_has_translation_prior_increase(&has_bits);
          translation_prior_increase_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
      if ((8u <= tag && tag < 16u)) {
        ptr = _extensions_.ParseField(tag, ptr,
            internal_default_instance(), &_internal_metadata_, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* MotionEstimationOptions_IrlsMaskOptions::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mediapipe.MotionEstimationOptions.IrlsMaskOptions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // Extension range [1, 2)
  target = _extensions_._InternalSerialize(
      1, 2, target, stream);

  cached_has_bits = _has_bits_[0];
  // optional float decay = 2 [default = 0.7];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_decay(), target);
  }

  // optional float inlier_score = 3 [default = 0.4];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_inlier_score(), target);
  }

  // optional float base_score = 4 [default = 0.2];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_base_score(), target);
  }

  // optional float min_translation_norm = 5 [default = 0.002];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_min_translation_norm(), target);
  }

  // optional float translation_blend_alpha = 6 [default = 0.7];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_translation_blend_alpha(), target);
  }

  // optional float translation_prior_increase = 7 [default = 0.2];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_translation_prior_increase(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mediapipe.MotionEstimationOptions.IrlsMaskOptions)
  return target;
}

size_t MotionEstimationOptions_IrlsMaskOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mediapipe.MotionEstimationOptions.IrlsMaskOptions)
  size_t total_size = 0;

  total_size += _extensions_.ByteSize();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional float decay = 2 [default = 0.7];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float inlier_score = 3 [default = 0.4];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float base_score = 4 [default = 0.2];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float min_translation_norm = 5 [default = 0.002];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float translation_blend_alpha = 6 [default = 0.7];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float translation_prior_increase = 7 [default = 0.2];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MotionEstimationOptions_IrlsMaskOptions::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mediapipe.MotionEstimationOptions.IrlsMaskOptions)
  GOOGLE_DCHECK_NE(&from, this);
  const MotionEstimationOptions_IrlsMaskOptions* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<MotionEstimationOptions_IrlsMaskOptions>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mediapipe.MotionEstimationOptions.IrlsMaskOptions)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mediapipe.MotionEstimationOptions.IrlsMaskOptions)
    MergeFrom(*source);
  }
}

void MotionEstimationOptions_IrlsMaskOptions::MergeFrom(const MotionEstimationOptions_IrlsMaskOptions& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mediapipe.MotionEstimationOptions.IrlsMaskOptions)
  GOOGLE_DCHECK_NE(&from, this);
  _extensions_.MergeFrom(from._extensions_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      decay_ = from.decay_;
    }
    if (cached_has_bits & 0x00000002u) {
      inlier_score_ = from.inlier_score_;
    }
    if (cached_has_bits & 0x00000004u) {
      base_score_ = from.base_score_;
    }
    if (cached_has_bits & 0x00000008u) {
      min_translation_norm_ = from.min_translation_norm_;
    }
    if (cached_has_bits & 0x00000010u) {
      translation_blend_alpha_ = from.translation_blend_alpha_;
    }
    if (cached_has_bits & 0x00000020u) {
      translation_prior_increase_ = from.translation_prior_increase_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void MotionEstimationOptions_IrlsMaskOptions::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mediapipe.MotionEstimationOptions.IrlsMaskOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MotionEstimationOptions_IrlsMaskOptions::CopyFrom(const MotionEstimationOptions_IrlsMaskOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mediapipe.MotionEstimationOptions.IrlsMaskOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MotionEstimationOptions_IrlsMaskOptions::IsInitialized() const {
  if (!_extensions_.IsInitialized()) {
    return false;
  }

  return true;
}

void MotionEstimationOptions_IrlsMaskOptions::InternalSwap(MotionEstimationOptions_IrlsMaskOptions* other) {
  using std::swap;
  _extensions_.InternalSwap(&other->_extensions_);
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(decay_, other->decay_);
  swap(inlier_score_, other->inlier_score_);
  swap(base_score_, other->base_score_);
  swap(min_translation_norm_, other->min_translation_norm_);
  swap(translation_blend_alpha_, other->translation_blend_alpha_);
  swap(translation_prior_increase_, other->translation_prior_increase_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MotionEstimationOptions_IrlsMaskOptions::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto_getter, &descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto_once,
      file_level_metadata_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto[2]);
}

// ===================================================================

class MotionEstimationOptions_JointTrackEstimationOptions::_Internal {
 public:
  using HasBits = decltype(std::declval<MotionEstimationOptions_JointTrackEstimationOptions>()._has_bits_);
  static void set_has_num_motion_models(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_motion_stride(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_temporal_smoothing(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

MotionEstimationOptions_JointTrackEstimationOptions::MotionEstimationOptions_JointTrackEstimationOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mediapipe.MotionEstimationOptions.JointTrackEstimationOptions)
}
MotionEstimationOptions_JointTrackEstimationOptions::MotionEstimationOptions_JointTrackEstimationOptions(const MotionEstimationOptions_JointTrackEstimationOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&temporal_smoothing_, &from.temporal_smoothing_,
    static_cast<size_t>(reinterpret_cast<char*>(&motion_stride_) -
    reinterpret_cast<char*>(&temporal_smoothing_)) + sizeof(motion_stride_));
  // @@protoc_insertion_point(copy_constructor:mediapipe.MotionEstimationOptions.JointTrackEstimationOptions)
}

void MotionEstimationOptions_JointTrackEstimationOptions::SharedCtor() {
temporal_smoothing_ = false;
num_motion_models_ = 3;
motion_stride_ = 15;
}

MotionEstimationOptions_JointTrackEstimationOptions::~MotionEstimationOptions_JointTrackEstimationOptions() {
  // @@protoc_insertion_point(destructor:mediapipe.MotionEstimationOptions.JointTrackEstimationOptions)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void MotionEstimationOptions_JointTrackEstimationOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void MotionEstimationOptions_JointTrackEstimationOptions::ArenaDtor(void* object) {
  MotionEstimationOptions_JointTrackEstimationOptions* _this = reinterpret_cast< MotionEstimationOptions_JointTrackEstimationOptions* >(object);
  (void)_this;
}
void MotionEstimationOptions_JointTrackEstimationOptions::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MotionEstimationOptions_JointTrackEstimationOptions::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MotionEstimationOptions_JointTrackEstimationOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:mediapipe.MotionEstimationOptions.JointTrackEstimationOptions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    temporal_smoothing_ = false;
    num_motion_models_ = 3;
    motion_stride_ = 15;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MotionEstimationOptions_JointTrackEstimationOptions::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 num_motion_models = 1 [default = 3];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_num_motion_models(&has_bits);
          num_motion_models_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 motion_stride = 2 [default = 15];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_motion_stride(&has_bits);
          motion_stride_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool temporal_smoothing = 3 [default = false];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_temporal_smoothing(&has_bits);
          temporal_smoothing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* MotionEstimationOptions_JointTrackEstimationOptions::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mediapipe.MotionEstimationOptions.JointTrackEstimationOptions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 num_motion_models = 1 [default = 3];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_num_motion_models(), target);
  }

  // optional int32 motion_stride = 2 [default = 15];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_motion_stride(), target);
  }

  // optional bool temporal_smoothing = 3 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_temporal_smoothing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mediapipe.MotionEstimationOptions.JointTrackEstimationOptions)
  return target;
}

size_t MotionEstimationOptions_JointTrackEstimationOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mediapipe.MotionEstimationOptions.JointTrackEstimationOptions)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bool temporal_smoothing = 3 [default = false];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional int32 num_motion_models = 1 [default = 3];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_num_motion_models());
    }

    // optional int32 motion_stride = 2 [default = 15];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_motion_stride());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MotionEstimationOptions_JointTrackEstimationOptions::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mediapipe.MotionEstimationOptions.JointTrackEstimationOptions)
  GOOGLE_DCHECK_NE(&from, this);
  const MotionEstimationOptions_JointTrackEstimationOptions* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<MotionEstimationOptions_JointTrackEstimationOptions>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mediapipe.MotionEstimationOptions.JointTrackEstimationOptions)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mediapipe.MotionEstimationOptions.JointTrackEstimationOptions)
    MergeFrom(*source);
  }
}

void MotionEstimationOptions_JointTrackEstimationOptions::MergeFrom(const MotionEstimationOptions_JointTrackEstimationOptions& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mediapipe.MotionEstimationOptions.JointTrackEstimationOptions)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      temporal_smoothing_ = from.temporal_smoothing_;
    }
    if (cached_has_bits & 0x00000002u) {
      num_motion_models_ = from.num_motion_models_;
    }
    if (cached_has_bits & 0x00000004u) {
      motion_stride_ = from.motion_stride_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void MotionEstimationOptions_JointTrackEstimationOptions::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mediapipe.MotionEstimationOptions.JointTrackEstimationOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MotionEstimationOptions_JointTrackEstimationOptions::CopyFrom(const MotionEstimationOptions_JointTrackEstimationOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mediapipe.MotionEstimationOptions.JointTrackEstimationOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MotionEstimationOptions_JointTrackEstimationOptions::IsInitialized() const {
  return true;
}

void MotionEstimationOptions_JointTrackEstimationOptions::InternalSwap(MotionEstimationOptions_JointTrackEstimationOptions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(temporal_smoothing_, other->temporal_smoothing_);
  swap(num_motion_models_, other->num_motion_models_);
  swap(motion_stride_, other->motion_stride_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MotionEstimationOptions_JointTrackEstimationOptions::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto_getter, &descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto_once,
      file_level_metadata_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto[3]);
}

// ===================================================================

class MotionEstimationOptions_LongFeatureBiasOptions::_Internal {
 public:
  using HasBits = decltype(std::declval<MotionEstimationOptions_LongFeatureBiasOptions>()._has_bits_);
  static void set_has_total_rounds(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_inlier_bias(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_outlier_bias(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_num_irls_observations(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_max_irls_change_ratio(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_inlier_irls_weight(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_bias_stdev(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_use_spatial_bias(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_grid_size(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_spatial_sigma(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_color_sigma(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_long_track_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_long_track_confidence_fraction(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_seed_priors_from_bias(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

MotionEstimationOptions_LongFeatureBiasOptions::MotionEstimationOptions_LongFeatureBiasOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions)
}
MotionEstimationOptions_LongFeatureBiasOptions::MotionEstimationOptions_LongFeatureBiasOptions(const MotionEstimationOptions_LongFeatureBiasOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&seed_priors_from_bias_, &from.seed_priors_from_bias_,
    static_cast<size_t>(reinterpret_cast<char*>(&bias_stdev_) -
    reinterpret_cast<char*>(&seed_priors_from_bias_)) + sizeof(bias_stdev_));
  // @@protoc_insertion_point(copy_constructor:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions)
}

void MotionEstimationOptions_LongFeatureBiasOptions::SharedCtor() {
seed_priors_from_bias_ = false;
total_rounds_ = 1;
inlier_bias_ = 0.98f;
outlier_bias_ = 0.7f;
num_irls_observations_ = 10;
max_irls_change_ratio_ = 10;
inlier_irls_weight_ = 0.2f;
use_spatial_bias_ = true;
grid_size_ = 0.04f;
spatial_sigma_ = 0.02f;
color_sigma_ = 20;
long_track_threshold_ = 30;
long_track_confidence_fraction_ = 0.25f;
bias_stdev_ = 1;
}

MotionEstimationOptions_LongFeatureBiasOptions::~MotionEstimationOptions_LongFeatureBiasOptions() {
  // @@protoc_insertion_point(destructor:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void MotionEstimationOptions_LongFeatureBiasOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void MotionEstimationOptions_LongFeatureBiasOptions::ArenaDtor(void* object) {
  MotionEstimationOptions_LongFeatureBiasOptions* _this = reinterpret_cast< MotionEstimationOptions_LongFeatureBiasOptions* >(object);
  (void)_this;
}
void MotionEstimationOptions_LongFeatureBiasOptions::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MotionEstimationOptions_LongFeatureBiasOptions::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MotionEstimationOptions_LongFeatureBiasOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    seed_priors_from_bias_ = false;
    total_rounds_ = 1;
    inlier_bias_ = 0.98f;
    outlier_bias_ = 0.7f;
    num_irls_observations_ = 10;
    max_irls_change_ratio_ = 10;
    inlier_irls_weight_ = 0.2f;
    use_spatial_bias_ = true;
  }
  if (cached_has_bits & 0x00003f00u) {
    grid_size_ = 0.04f;
    spatial_sigma_ = 0.02f;
    color_sigma_ = 20;
    long_track_threshold_ = 30;
    long_track_confidence_fraction_ = 0.25f;
    bias_stdev_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MotionEstimationOptions_LongFeatureBiasOptions::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float inlier_bias = 1 [default = 0.98];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_inlier_bias(&has_bits);
          inlier_bias_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float outlier_bias = 2 [default = 0.7];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_outlier_bias(&has_bits);
          outlier_bias_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional int32 num_irls_observations = 3 [default = 10];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_num_irls_observations(&has_bits);
          num_irls_observations_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float max_irls_change_ratio = 4 [default = 10];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_max_irls_change_ratio(&has_bits);
          max_irls_change_ratio_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float inlier_irls_weight = 5 [default = 0.2];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_inlier_irls_weight(&has_bits);
          inlier_irls_weight_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional bool use_spatial_bias = 6 [default = true];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_use_spatial_bias(&has_bits);
          use_spatial_bias_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float grid_size = 7 [default = 0.04];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          _Internal::set_has_grid_size(&has_bits);
          grid_size_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float spatial_sigma = 8 [default = 0.02];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 69)) {
          _Internal::set_has_spatial_sigma(&has_bits);
          spatial_sigma_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float color_sigma = 9 [default = 20];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 77)) {
          _Internal::set_has_color_sigma(&has_bits);
          color_sigma_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional int32 long_track_threshold = 10 [default = 30];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_long_track_threshold(&has_bits);
          long_track_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float long_track_confidence_fraction = 11 [default = 0.25];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 93)) {
          _Internal::set_has_long_track_confidence_fraction(&has_bits);
          long_track_confidence_fraction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float bias_stdev = 12 [default = 1];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 101)) {
          _Internal::set_has_bias_stdev(&has_bits);
          bias_stdev_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional int32 total_rounds = 13 [default = 1];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_total_rounds(&has_bits);
          total_rounds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool seed_priors_from_bias = 14 [default = false];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          _Internal::set_has_seed_priors_from_bias(&has_bits);
          seed_priors_from_bias_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* MotionEstimationOptions_LongFeatureBiasOptions::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float inlier_bias = 1 [default = 0.98];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_inlier_bias(), target);
  }

  // optional float outlier_bias = 2 [default = 0.7];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_outlier_bias(), target);
  }

  // optional int32 num_irls_observations = 3 [default = 10];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_num_irls_observations(), target);
  }

  // optional float max_irls_change_ratio = 4 [default = 10];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_max_irls_change_ratio(), target);
  }

  // optional float inlier_irls_weight = 5 [default = 0.2];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_inlier_irls_weight(), target);
  }

  // optional bool use_spatial_bias = 6 [default = true];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_use_spatial_bias(), target);
  }

  // optional float grid_size = 7 [default = 0.04];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_grid_size(), target);
  }

  // optional float spatial_sigma = 8 [default = 0.02];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(8, this->_internal_spatial_sigma(), target);
  }

  // optional float color_sigma = 9 [default = 20];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(9, this->_internal_color_sigma(), target);
  }

  // optional int32 long_track_threshold = 10 [default = 30];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(10, this->_internal_long_track_threshold(), target);
  }

  // optional float long_track_confidence_fraction = 11 [default = 0.25];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(11, this->_internal_long_track_confidence_fraction(), target);
  }

  // optional float bias_stdev = 12 [default = 1];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(12, this->_internal_bias_stdev(), target);
  }

  // optional int32 total_rounds = 13 [default = 1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(13, this->_internal_total_rounds(), target);
  }

  // optional bool seed_priors_from_bias = 14 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(14, this->_internal_seed_priors_from_bias(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions)
  return target;
}

size_t MotionEstimationOptions_LongFeatureBiasOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bool seed_priors_from_bias = 14 [default = false];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional int32 total_rounds = 13 [default = 1];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_total_rounds());
    }

    // optional float inlier_bias = 1 [default = 0.98];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float outlier_bias = 2 [default = 0.7];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional int32 num_irls_observations = 3 [default = 10];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_num_irls_observations());
    }

    // optional float max_irls_change_ratio = 4 [default = 10];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float inlier_irls_weight = 5 [default = 0.2];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional bool use_spatial_bias = 6 [default = true];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional float grid_size = 7 [default = 0.04];
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional float spatial_sigma = 8 [default = 0.02];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

    // optional float color_sigma = 9 [default = 20];
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 4;
    }

    // optional int32 long_track_threshold = 10 [default = 30];
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_long_track_threshold());
    }

    // optional float long_track_confidence_fraction = 11 [default = 0.25];
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 4;
    }

    // optional float bias_stdev = 12 [default = 1];
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MotionEstimationOptions_LongFeatureBiasOptions::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions)
  GOOGLE_DCHECK_NE(&from, this);
  const MotionEstimationOptions_LongFeatureBiasOptions* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<MotionEstimationOptions_LongFeatureBiasOptions>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions)
    MergeFrom(*source);
  }
}

void MotionEstimationOptions_LongFeatureBiasOptions::MergeFrom(const MotionEstimationOptions_LongFeatureBiasOptions& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      seed_priors_from_bias_ = from.seed_priors_from_bias_;
    }
    if (cached_has_bits & 0x00000002u) {
      total_rounds_ = from.total_rounds_;
    }
    if (cached_has_bits & 0x00000004u) {
      inlier_bias_ = from.inlier_bias_;
    }
    if (cached_has_bits & 0x00000008u) {
      outlier_bias_ = from.outlier_bias_;
    }
    if (cached_has_bits & 0x00000010u) {
      num_irls_observations_ = from.num_irls_observations_;
    }
    if (cached_has_bits & 0x00000020u) {
      max_irls_change_ratio_ = from.max_irls_change_ratio_;
    }
    if (cached_has_bits & 0x00000040u) {
      inlier_irls_weight_ = from.inlier_irls_weight_;
    }
    if (cached_has_bits & 0x00000080u) {
      use_spatial_bias_ = from.use_spatial_bias_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      grid_size_ = from.grid_size_;
    }
    if (cached_has_bits & 0x00000200u) {
      spatial_sigma_ = from.spatial_sigma_;
    }
    if (cached_has_bits & 0x00000400u) {
      color_sigma_ = from.color_sigma_;
    }
    if (cached_has_bits & 0x00000800u) {
      long_track_threshold_ = from.long_track_threshold_;
    }
    if (cached_has_bits & 0x00001000u) {
      long_track_confidence_fraction_ = from.long_track_confidence_fraction_;
    }
    if (cached_has_bits & 0x00002000u) {
      bias_stdev_ = from.bias_stdev_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void MotionEstimationOptions_LongFeatureBiasOptions::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MotionEstimationOptions_LongFeatureBiasOptions::CopyFrom(const MotionEstimationOptions_LongFeatureBiasOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MotionEstimationOptions_LongFeatureBiasOptions::IsInitialized() const {
  return true;
}

void MotionEstimationOptions_LongFeatureBiasOptions::InternalSwap(MotionEstimationOptions_LongFeatureBiasOptions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(seed_priors_from_bias_, other->seed_priors_from_bias_);
  swap(total_rounds_, other->total_rounds_);
  swap(inlier_bias_, other->inlier_bias_);
  swap(outlier_bias_, other->outlier_bias_);
  swap(num_irls_observations_, other->num_irls_observations_);
  swap(max_irls_change_ratio_, other->max_irls_change_ratio_);
  swap(inlier_irls_weight_, other->inlier_irls_weight_);
  swap(use_spatial_bias_, other->use_spatial_bias_);
  swap(grid_size_, other->grid_size_);
  swap(spatial_sigma_, other->spatial_sigma_);
  swap(color_sigma_, other->color_sigma_);
  swap(long_track_threshold_, other->long_track_threshold_);
  swap(long_track_confidence_fraction_, other->long_track_confidence_fraction_);
  swap(bias_stdev_, other->bias_stdev_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MotionEstimationOptions_LongFeatureBiasOptions::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto_getter, &descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto_once,
      file_level_metadata_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto[4]);
}

// ===================================================================

class MotionEstimationOptions_TranslationBounds::_Internal {
 public:
  using HasBits = decltype(std::declval<MotionEstimationOptions_TranslationBounds>()._has_bits_);
  static void set_has_min_features(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_frac_max_motion_magnitude(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_max_motion_stdev_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_max_motion_stdev(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_max_acceleration(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

MotionEstimationOptions_TranslationBounds::MotionEstimationOptions_TranslationBounds(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mediapipe.MotionEstimationOptions.TranslationBounds)
}
MotionEstimationOptions_TranslationBounds::MotionEstimationOptions_TranslationBounds(const MotionEstimationOptions_TranslationBounds& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&max_acceleration_, &from.max_acceleration_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_motion_stdev_threshold_) -
    reinterpret_cast<char*>(&max_acceleration_)) + sizeof(max_motion_stdev_threshold_));
  // @@protoc_insertion_point(copy_constructor:mediapipe.MotionEstimationOptions.TranslationBounds)
}

void MotionEstimationOptions_TranslationBounds::SharedCtor() {
max_acceleration_ = 20;
min_features_ = 3;
frac_max_motion_magnitude_ = 0.15f;
max_motion_stdev_ = 0.065f;
max_motion_stdev_threshold_ = 0.01f;
}

MotionEstimationOptions_TranslationBounds::~MotionEstimationOptions_TranslationBounds() {
  // @@protoc_insertion_point(destructor:mediapipe.MotionEstimationOptions.TranslationBounds)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void MotionEstimationOptions_TranslationBounds::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void MotionEstimationOptions_TranslationBounds::ArenaDtor(void* object) {
  MotionEstimationOptions_TranslationBounds* _this = reinterpret_cast< MotionEstimationOptions_TranslationBounds* >(object);
  (void)_this;
}
void MotionEstimationOptions_TranslationBounds::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MotionEstimationOptions_TranslationBounds::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MotionEstimationOptions_TranslationBounds::Clear() {
// @@protoc_insertion_point(message_clear_start:mediapipe.MotionEstimationOptions.TranslationBounds)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    max_acceleration_ = 20;
    min_features_ = 3;
    frac_max_motion_magnitude_ = 0.15f;
    max_motion_stdev_ = 0.065f;
    max_motion_stdev_threshold_ = 0.01f;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MotionEstimationOptions_TranslationBounds::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 min_features = 1 [default = 3];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_min_features(&has_bits);
          min_features_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float frac_max_motion_magnitude = 2 [default = 0.15];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_frac_max_motion_magnitude(&has_bits);
          frac_max_motion_magnitude_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float max_motion_stdev = 3 [default = 0.065];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_max_motion_stdev(&has_bits);
          max_motion_stdev_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float max_motion_stdev_threshold = 4 [default = 0.01];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_max_motion_stdev_threshold(&has_bits);
          max_motion_stdev_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float max_acceleration = 5 [default = 20];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_max_acceleration(&has_bits);
          max_acceleration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* MotionEstimationOptions_TranslationBounds::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mediapipe.MotionEstimationOptions.TranslationBounds)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 min_features = 1 [default = 3];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_min_features(), target);
  }

  // optional float frac_max_motion_magnitude = 2 [default = 0.15];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_frac_max_motion_magnitude(), target);
  }

  // optional float max_motion_stdev = 3 [default = 0.065];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_max_motion_stdev(), target);
  }

  // optional float max_motion_stdev_threshold = 4 [default = 0.01];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_max_motion_stdev_threshold(), target);
  }

  // optional float max_acceleration = 5 [default = 20];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_max_acceleration(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mediapipe.MotionEstimationOptions.TranslationBounds)
  return target;
}

size_t MotionEstimationOptions_TranslationBounds::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mediapipe.MotionEstimationOptions.TranslationBounds)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional float max_acceleration = 5 [default = 20];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional int32 min_features = 1 [default = 3];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_min_features());
    }

    // optional float frac_max_motion_magnitude = 2 [default = 0.15];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float max_motion_stdev = 3 [default = 0.065];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float max_motion_stdev_threshold = 4 [default = 0.01];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MotionEstimationOptions_TranslationBounds::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mediapipe.MotionEstimationOptions.TranslationBounds)
  GOOGLE_DCHECK_NE(&from, this);
  const MotionEstimationOptions_TranslationBounds* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<MotionEstimationOptions_TranslationBounds>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mediapipe.MotionEstimationOptions.TranslationBounds)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mediapipe.MotionEstimationOptions.TranslationBounds)
    MergeFrom(*source);
  }
}

void MotionEstimationOptions_TranslationBounds::MergeFrom(const MotionEstimationOptions_TranslationBounds& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mediapipe.MotionEstimationOptions.TranslationBounds)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      max_acceleration_ = from.max_acceleration_;
    }
    if (cached_has_bits & 0x00000002u) {
      min_features_ = from.min_features_;
    }
    if (cached_has_bits & 0x00000004u) {
      frac_max_motion_magnitude_ = from.frac_max_motion_magnitude_;
    }
    if (cached_has_bits & 0x00000008u) {
      max_motion_stdev_ = from.max_motion_stdev_;
    }
    if (cached_has_bits & 0x00000010u) {
      max_motion_stdev_threshold_ = from.max_motion_stdev_threshold_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void MotionEstimationOptions_TranslationBounds::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mediapipe.MotionEstimationOptions.TranslationBounds)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MotionEstimationOptions_TranslationBounds::CopyFrom(const MotionEstimationOptions_TranslationBounds& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mediapipe.MotionEstimationOptions.TranslationBounds)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MotionEstimationOptions_TranslationBounds::IsInitialized() const {
  return true;
}

void MotionEstimationOptions_TranslationBounds::InternalSwap(MotionEstimationOptions_TranslationBounds* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(max_acceleration_, other->max_acceleration_);
  swap(min_features_, other->min_features_);
  swap(frac_max_motion_magnitude_, other->frac_max_motion_magnitude_);
  swap(max_motion_stdev_, other->max_motion_stdev_);
  swap(max_motion_stdev_threshold_, other->max_motion_stdev_threshold_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MotionEstimationOptions_TranslationBounds::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto_getter, &descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto_once,
      file_level_metadata_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto[5]);
}

// ===================================================================

class MotionEstimationOptions_SimilarityBounds::_Internal {
 public:
  using HasBits = decltype(std::declval<MotionEstimationOptions_SimilarityBounds>()._has_bits_);
  static void set_has_only_stable_input(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_min_inlier_fraction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_min_inliers(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_lower_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_upper_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_limit_rotation(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_inlier_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_frac_inlier_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_strict_inlier_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

MotionEstimationOptions_SimilarityBounds::MotionEstimationOptions_SimilarityBounds(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mediapipe.MotionEstimationOptions.SimilarityBounds)
}
MotionEstimationOptions_SimilarityBounds::MotionEstimationOptions_SimilarityBounds(const MotionEstimationOptions_SimilarityBounds& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&frac_inlier_threshold_, &from.frac_inlier_threshold_,
    static_cast<size_t>(reinterpret_cast<char*>(&strict_inlier_threshold_) -
    reinterpret_cast<char*>(&frac_inlier_threshold_)) + sizeof(strict_inlier_threshold_));
  // @@protoc_insertion_point(copy_constructor:mediapipe.MotionEstimationOptions.SimilarityBounds)
}

void MotionEstimationOptions_SimilarityBounds::SharedCtor() {
frac_inlier_threshold_ = 0;
only_stable_input_ = true;
min_inlier_fraction_ = 0.2f;
min_inliers_ = 30;
lower_scale_ = 0.8f;
upper_scale_ = 1.25f;
limit_rotation_ = 0.25f;
inlier_threshold_ = 4;
strict_inlier_threshold_ = 0.5f;
}

MotionEstimationOptions_SimilarityBounds::~MotionEstimationOptions_SimilarityBounds() {
  // @@protoc_insertion_point(destructor:mediapipe.MotionEstimationOptions.SimilarityBounds)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void MotionEstimationOptions_SimilarityBounds::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void MotionEstimationOptions_SimilarityBounds::ArenaDtor(void* object) {
  MotionEstimationOptions_SimilarityBounds* _this = reinterpret_cast< MotionEstimationOptions_SimilarityBounds* >(object);
  (void)_this;
}
void MotionEstimationOptions_SimilarityBounds::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MotionEstimationOptions_SimilarityBounds::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MotionEstimationOptions_SimilarityBounds::Clear() {
// @@protoc_insertion_point(message_clear_start:mediapipe.MotionEstimationOptions.SimilarityBounds)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    frac_inlier_threshold_ = 0;
    only_stable_input_ = true;
    min_inlier_fraction_ = 0.2f;
    min_inliers_ = 30;
    lower_scale_ = 0.8f;
    upper_scale_ = 1.25f;
    limit_rotation_ = 0.25f;
    inlier_threshold_ = 4;
  }
  strict_inlier_threshold_ = 0.5f;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MotionEstimationOptions_SimilarityBounds::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool only_stable_input = 1 [default = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_only_stable_input(&has_bits);
          only_stable_input_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float min_inlier_fraction = 2 [default = 0.2];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_min_inlier_fraction(&has_bits);
          min_inlier_fraction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float min_inliers = 3 [default = 30];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_min_inliers(&has_bits);
          min_inliers_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float lower_scale = 4 [default = 0.8];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_lower_scale(&has_bits);
          lower_scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float upper_scale = 5 [default = 1.25];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_upper_scale(&has_bits);
          upper_scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float limit_rotation = 6 [default = 0.25];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          _Internal::set_has_limit_rotation(&has_bits);
          limit_rotation_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float inlier_threshold = 7 [default = 4];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          _Internal::set_has_inlier_threshold(&has_bits);
          inlier_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float frac_inlier_threshold = 8 [default = 0];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 69)) {
          _Internal::set_has_frac_inlier_threshold(&has_bits);
          frac_inlier_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float strict_inlier_threshold = 9 [default = 0.5];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 77)) {
          _Internal::set_has_strict_inlier_threshold(&has_bits);
          strict_inlier_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* MotionEstimationOptions_SimilarityBounds::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mediapipe.MotionEstimationOptions.SimilarityBounds)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool only_stable_input = 1 [default = true];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_only_stable_input(), target);
  }

  // optional float min_inlier_fraction = 2 [default = 0.2];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_min_inlier_fraction(), target);
  }

  // optional float min_inliers = 3 [default = 30];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_min_inliers(), target);
  }

  // optional float lower_scale = 4 [default = 0.8];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_lower_scale(), target);
  }

  // optional float upper_scale = 5 [default = 1.25];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_upper_scale(), target);
  }

  // optional float limit_rotation = 6 [default = 0.25];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_limit_rotation(), target);
  }

  // optional float inlier_threshold = 7 [default = 4];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_inlier_threshold(), target);
  }

  // optional float frac_inlier_threshold = 8 [default = 0];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(8, this->_internal_frac_inlier_threshold(), target);
  }

  // optional float strict_inlier_threshold = 9 [default = 0.5];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(9, this->_internal_strict_inlier_threshold(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mediapipe.MotionEstimationOptions.SimilarityBounds)
  return target;
}

size_t MotionEstimationOptions_SimilarityBounds::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mediapipe.MotionEstimationOptions.SimilarityBounds)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional float frac_inlier_threshold = 8 [default = 0];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional bool only_stable_input = 1 [default = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional float min_inlier_fraction = 2 [default = 0.2];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float min_inliers = 3 [default = 30];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float lower_scale = 4 [default = 0.8];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float upper_scale = 5 [default = 1.25];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float limit_rotation = 6 [default = 0.25];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float inlier_threshold = 7 [default = 4];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  // optional float strict_inlier_threshold = 9 [default = 0.5];
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MotionEstimationOptions_SimilarityBounds::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mediapipe.MotionEstimationOptions.SimilarityBounds)
  GOOGLE_DCHECK_NE(&from, this);
  const MotionEstimationOptions_SimilarityBounds* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<MotionEstimationOptions_SimilarityBounds>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mediapipe.MotionEstimationOptions.SimilarityBounds)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mediapipe.MotionEstimationOptions.SimilarityBounds)
    MergeFrom(*source);
  }
}

void MotionEstimationOptions_SimilarityBounds::MergeFrom(const MotionEstimationOptions_SimilarityBounds& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mediapipe.MotionEstimationOptions.SimilarityBounds)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      frac_inlier_threshold_ = from.frac_inlier_threshold_;
    }
    if (cached_has_bits & 0x00000002u) {
      only_stable_input_ = from.only_stable_input_;
    }
    if (cached_has_bits & 0x00000004u) {
      min_inlier_fraction_ = from.min_inlier_fraction_;
    }
    if (cached_has_bits & 0x00000008u) {
      min_inliers_ = from.min_inliers_;
    }
    if (cached_has_bits & 0x00000010u) {
      lower_scale_ = from.lower_scale_;
    }
    if (cached_has_bits & 0x00000020u) {
      upper_scale_ = from.upper_scale_;
    }
    if (cached_has_bits & 0x00000040u) {
      limit_rotation_ = from.limit_rotation_;
    }
    if (cached_has_bits & 0x00000080u) {
      inlier_threshold_ = from.inlier_threshold_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_strict_inlier_threshold(from._internal_strict_inlier_threshold());
  }
}

void MotionEstimationOptions_SimilarityBounds::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mediapipe.MotionEstimationOptions.SimilarityBounds)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MotionEstimationOptions_SimilarityBounds::CopyFrom(const MotionEstimationOptions_SimilarityBounds& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mediapipe.MotionEstimationOptions.SimilarityBounds)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MotionEstimationOptions_SimilarityBounds::IsInitialized() const {
  return true;
}

void MotionEstimationOptions_SimilarityBounds::InternalSwap(MotionEstimationOptions_SimilarityBounds* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(frac_inlier_threshold_, other->frac_inlier_threshold_);
  swap(only_stable_input_, other->only_stable_input_);
  swap(min_inlier_fraction_, other->min_inlier_fraction_);
  swap(min_inliers_, other->min_inliers_);
  swap(lower_scale_, other->lower_scale_);
  swap(upper_scale_, other->upper_scale_);
  swap(limit_rotation_, other->limit_rotation_);
  swap(inlier_threshold_, other->inlier_threshold_);
  swap(strict_inlier_threshold_, other->strict_inlier_threshold_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MotionEstimationOptions_SimilarityBounds::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto_getter, &descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto_once,
      file_level_metadata_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto[6]);
}

// ===================================================================

class MotionEstimationOptions_HomographyBounds::_Internal {
 public:
  using HasBits = decltype(std::declval<MotionEstimationOptions_HomographyBounds>()._has_bits_);
  static void set_has_lower_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_upper_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_limit_rotation(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_limit_perspective(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_registration_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_frac_registration_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_min_inlier_coverage(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_frac_inlier_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

MotionEstimationOptions_HomographyBounds::MotionEstimationOptions_HomographyBounds(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mediapipe.MotionEstimationOptions.HomographyBounds)
}
MotionEstimationOptions_HomographyBounds::MotionEstimationOptions_HomographyBounds(const MotionEstimationOptions_HomographyBounds& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&frac_registration_threshold_, &from.frac_registration_threshold_,
    static_cast<size_t>(reinterpret_cast<char*>(&min_inlier_coverage_) -
    reinterpret_cast<char*>(&frac_registration_threshold_)) + sizeof(min_inlier_coverage_));
  // @@protoc_insertion_point(copy_constructor:mediapipe.MotionEstimationOptions.HomographyBounds)
}

void MotionEstimationOptions_HomographyBounds::SharedCtor() {
frac_registration_threshold_ = 0;
frac_inlier_threshold_ = 0.002f;
lower_scale_ = 0.8f;
upper_scale_ = 1.25f;
limit_rotation_ = 0.25f;
limit_perspective_ = 0.0004f;
registration_threshold_ = 0.1f;
min_inlier_coverage_ = 0.3f;
}

MotionEstimationOptions_HomographyBounds::~MotionEstimationOptions_HomographyBounds() {
  // @@protoc_insertion_point(destructor:mediapipe.MotionEstimationOptions.HomographyBounds)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void MotionEstimationOptions_HomographyBounds::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void MotionEstimationOptions_HomographyBounds::ArenaDtor(void* object) {
  MotionEstimationOptions_HomographyBounds* _this = reinterpret_cast< MotionEstimationOptions_HomographyBounds* >(object);
  (void)_this;
}
void MotionEstimationOptions_HomographyBounds::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MotionEstimationOptions_HomographyBounds::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MotionEstimationOptions_HomographyBounds::Clear() {
// @@protoc_insertion_point(message_clear_start:mediapipe.MotionEstimationOptions.HomographyBounds)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    frac_registration_threshold_ = 0;
    frac_inlier_threshold_ = 0.002f;
    lower_scale_ = 0.8f;
    upper_scale_ = 1.25f;
    limit_rotation_ = 0.25f;
    limit_perspective_ = 0.0004f;
    registration_threshold_ = 0.1f;
    min_inlier_coverage_ = 0.3f;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MotionEstimationOptions_HomographyBounds::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float lower_scale = 1 [default = 0.8];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_lower_scale(&has_bits);
          lower_scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float upper_scale = 2 [default = 1.25];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_upper_scale(&has_bits);
          upper_scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float limit_rotation = 3 [default = 0.25];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_limit_rotation(&has_bits);
          limit_rotation_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float limit_perspective = 4 [default = 0.0004];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_limit_perspective(&has_bits);
          limit_perspective_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float registration_threshold = 5 [default = 0.1];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_registration_threshold(&has_bits);
          registration_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float min_inlier_coverage = 6 [default = 0.3];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          _Internal::set_has_min_inlier_coverage(&has_bits);
          min_inlier_coverage_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float frac_inlier_threshold = 7 [default = 0.002];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          _Internal::set_has_frac_inlier_threshold(&has_bits);
          frac_inlier_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float frac_registration_threshold = 8 [default = 0];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 69)) {
          _Internal::set_has_frac_registration_threshold(&has_bits);
          frac_registration_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* MotionEstimationOptions_HomographyBounds::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mediapipe.MotionEstimationOptions.HomographyBounds)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float lower_scale = 1 [default = 0.8];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_lower_scale(), target);
  }

  // optional float upper_scale = 2 [default = 1.25];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_upper_scale(), target);
  }

  // optional float limit_rotation = 3 [default = 0.25];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_limit_rotation(), target);
  }

  // optional float limit_perspective = 4 [default = 0.0004];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_limit_perspective(), target);
  }

  // optional float registration_threshold = 5 [default = 0.1];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_registration_threshold(), target);
  }

  // optional float min_inlier_coverage = 6 [default = 0.3];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_min_inlier_coverage(), target);
  }

  // optional float frac_inlier_threshold = 7 [default = 0.002];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_frac_inlier_threshold(), target);
  }

  // optional float frac_registration_threshold = 8 [default = 0];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(8, this->_internal_frac_registration_threshold(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mediapipe.MotionEstimationOptions.HomographyBounds)
  return target;
}

size_t MotionEstimationOptions_HomographyBounds::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mediapipe.MotionEstimationOptions.HomographyBounds)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional float frac_registration_threshold = 8 [default = 0];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float frac_inlier_threshold = 7 [default = 0.002];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float lower_scale = 1 [default = 0.8];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float upper_scale = 2 [default = 1.25];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float limit_rotation = 3 [default = 0.25];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float limit_perspective = 4 [default = 0.0004];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float registration_threshold = 5 [default = 0.1];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float min_inlier_coverage = 6 [default = 0.3];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MotionEstimationOptions_HomographyBounds::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mediapipe.MotionEstimationOptions.HomographyBounds)
  GOOGLE_DCHECK_NE(&from, this);
  const MotionEstimationOptions_HomographyBounds* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<MotionEstimationOptions_HomographyBounds>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mediapipe.MotionEstimationOptions.HomographyBounds)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mediapipe.MotionEstimationOptions.HomographyBounds)
    MergeFrom(*source);
  }
}

void MotionEstimationOptions_HomographyBounds::MergeFrom(const MotionEstimationOptions_HomographyBounds& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mediapipe.MotionEstimationOptions.HomographyBounds)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      frac_registration_threshold_ = from.frac_registration_threshold_;
    }
    if (cached_has_bits & 0x00000002u) {
      frac_inlier_threshold_ = from.frac_inlier_threshold_;
    }
    if (cached_has_bits & 0x00000004u) {
      lower_scale_ = from.lower_scale_;
    }
    if (cached_has_bits & 0x00000008u) {
      upper_scale_ = from.upper_scale_;
    }
    if (cached_has_bits & 0x00000010u) {
      limit_rotation_ = from.limit_rotation_;
    }
    if (cached_has_bits & 0x00000020u) {
      limit_perspective_ = from.limit_perspective_;
    }
    if (cached_has_bits & 0x00000040u) {
      registration_threshold_ = from.registration_threshold_;
    }
    if (cached_has_bits & 0x00000080u) {
      min_inlier_coverage_ = from.min_inlier_coverage_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void MotionEstimationOptions_HomographyBounds::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mediapipe.MotionEstimationOptions.HomographyBounds)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MotionEstimationOptions_HomographyBounds::CopyFrom(const MotionEstimationOptions_HomographyBounds& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mediapipe.MotionEstimationOptions.HomographyBounds)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MotionEstimationOptions_HomographyBounds::IsInitialized() const {
  return true;
}

void MotionEstimationOptions_HomographyBounds::InternalSwap(MotionEstimationOptions_HomographyBounds* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(frac_registration_threshold_, other->frac_registration_threshold_);
  swap(frac_inlier_threshold_, other->frac_inlier_threshold_);
  swap(lower_scale_, other->lower_scale_);
  swap(upper_scale_, other->upper_scale_);
  swap(limit_rotation_, other->limit_rotation_);
  swap(limit_perspective_, other->limit_perspective_);
  swap(registration_threshold_, other->registration_threshold_);
  swap(min_inlier_coverage_, other->min_inlier_coverage_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MotionEstimationOptions_HomographyBounds::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto_getter, &descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto_once,
      file_level_metadata_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto[7]);
}

// ===================================================================

class MotionEstimationOptions_MixtureHomographyBounds::_Internal {
 public:
  using HasBits = decltype(std::declval<MotionEstimationOptions_MixtureHomographyBounds>()._has_bits_);
  static void set_has_min_inlier_coverage(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_max_adjacent_outlier_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_max_adjacent_empty_blocks(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_frac_inlier_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

MotionEstimationOptions_MixtureHomographyBounds::MotionEstimationOptions_MixtureHomographyBounds(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mediapipe.MotionEstimationOptions.MixtureHomographyBounds)
}
MotionEstimationOptions_MixtureHomographyBounds::MotionEstimationOptions_MixtureHomographyBounds(const MotionEstimationOptions_MixtureHomographyBounds& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&min_inlier_coverage_, &from.min_inlier_coverage_,
    static_cast<size_t>(reinterpret_cast<char*>(&frac_inlier_threshold_) -
    reinterpret_cast<char*>(&min_inlier_coverage_)) + sizeof(frac_inlier_threshold_));
  // @@protoc_insertion_point(copy_constructor:mediapipe.MotionEstimationOptions.MixtureHomographyBounds)
}

void MotionEstimationOptions_MixtureHomographyBounds::SharedCtor() {
min_inlier_coverage_ = 0.4f;
max_adjacent_outlier_blocks_ = 5;
max_adjacent_empty_blocks_ = 3;
frac_inlier_threshold_ = 0.0025f;
}

MotionEstimationOptions_MixtureHomographyBounds::~MotionEstimationOptions_MixtureHomographyBounds() {
  // @@protoc_insertion_point(destructor:mediapipe.MotionEstimationOptions.MixtureHomographyBounds)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void MotionEstimationOptions_MixtureHomographyBounds::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void MotionEstimationOptions_MixtureHomographyBounds::ArenaDtor(void* object) {
  MotionEstimationOptions_MixtureHomographyBounds* _this = reinterpret_cast< MotionEstimationOptions_MixtureHomographyBounds* >(object);
  (void)_this;
}
void MotionEstimationOptions_MixtureHomographyBounds::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MotionEstimationOptions_MixtureHomographyBounds::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MotionEstimationOptions_MixtureHomographyBounds::Clear() {
// @@protoc_insertion_point(message_clear_start:mediapipe.MotionEstimationOptions.MixtureHomographyBounds)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    min_inlier_coverage_ = 0.4f;
    max_adjacent_outlier_blocks_ = 5;
    max_adjacent_empty_blocks_ = 3;
    frac_inlier_threshold_ = 0.0025f;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MotionEstimationOptions_MixtureHomographyBounds::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float min_inlier_coverage = 1 [default = 0.4];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_min_inlier_coverage(&has_bits);
          min_inlier_coverage_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional int32 max_adjacent_outlier_blocks = 2 [default = 5];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_max_adjacent_outlier_blocks(&has_bits);
          max_adjacent_outlier_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 max_adjacent_empty_blocks = 3 [default = 3];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_max_adjacent_empty_blocks(&has_bits);
          max_adjacent_empty_blocks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float frac_inlier_threshold = 7 [default = 0.0025];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          _Internal::set_has_frac_inlier_threshold(&has_bits);
          frac_inlier_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* MotionEstimationOptions_MixtureHomographyBounds::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mediapipe.MotionEstimationOptions.MixtureHomographyBounds)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float min_inlier_coverage = 1 [default = 0.4];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_min_inlier_coverage(), target);
  }

  // optional int32 max_adjacent_outlier_blocks = 2 [default = 5];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_max_adjacent_outlier_blocks(), target);
  }

  // optional int32 max_adjacent_empty_blocks = 3 [default = 3];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_max_adjacent_empty_blocks(), target);
  }

  // optional float frac_inlier_threshold = 7 [default = 0.0025];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_frac_inlier_threshold(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mediapipe.MotionEstimationOptions.MixtureHomographyBounds)
  return target;
}

size_t MotionEstimationOptions_MixtureHomographyBounds::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mediapipe.MotionEstimationOptions.MixtureHomographyBounds)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional float min_inlier_coverage = 1 [default = 0.4];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional int32 max_adjacent_outlier_blocks = 2 [default = 5];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_max_adjacent_outlier_blocks());
    }

    // optional int32 max_adjacent_empty_blocks = 3 [default = 3];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_max_adjacent_empty_blocks());
    }

    // optional float frac_inlier_threshold = 7 [default = 0.0025];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MotionEstimationOptions_MixtureHomographyBounds::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mediapipe.MotionEstimationOptions.MixtureHomographyBounds)
  GOOGLE_DCHECK_NE(&from, this);
  const MotionEstimationOptions_MixtureHomographyBounds* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<MotionEstimationOptions_MixtureHomographyBounds>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mediapipe.MotionEstimationOptions.MixtureHomographyBounds)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mediapipe.MotionEstimationOptions.MixtureHomographyBounds)
    MergeFrom(*source);
  }
}

void MotionEstimationOptions_MixtureHomographyBounds::MergeFrom(const MotionEstimationOptions_MixtureHomographyBounds& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mediapipe.MotionEstimationOptions.MixtureHomographyBounds)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      min_inlier_coverage_ = from.min_inlier_coverage_;
    }
    if (cached_has_bits & 0x00000002u) {
      max_adjacent_outlier_blocks_ = from.max_adjacent_outlier_blocks_;
    }
    if (cached_has_bits & 0x00000004u) {
      max_adjacent_empty_blocks_ = from.max_adjacent_empty_blocks_;
    }
    if (cached_has_bits & 0x00000008u) {
      frac_inlier_threshold_ = from.frac_inlier_threshold_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void MotionEstimationOptions_MixtureHomographyBounds::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mediapipe.MotionEstimationOptions.MixtureHomographyBounds)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MotionEstimationOptions_MixtureHomographyBounds::CopyFrom(const MotionEstimationOptions_MixtureHomographyBounds& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mediapipe.MotionEstimationOptions.MixtureHomographyBounds)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MotionEstimationOptions_MixtureHomographyBounds::IsInitialized() const {
  return true;
}

void MotionEstimationOptions_MixtureHomographyBounds::InternalSwap(MotionEstimationOptions_MixtureHomographyBounds* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(min_inlier_coverage_, other->min_inlier_coverage_);
  swap(max_adjacent_outlier_blocks_, other->max_adjacent_outlier_blocks_);
  swap(max_adjacent_empty_blocks_, other->max_adjacent_empty_blocks_);
  swap(frac_inlier_threshold_, other->frac_inlier_threshold_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MotionEstimationOptions_MixtureHomographyBounds::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto_getter, &descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto_once,
      file_level_metadata_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto[8]);
}

// ===================================================================

class MotionEstimationOptions_OverlayDetectionOptions::_Internal {
 public:
  using HasBits = decltype(std::declval<MotionEstimationOptions_OverlayDetectionOptions>()._has_bits_);
  static void set_has_analysis_mask_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_strict_near_zero_motion(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_strict_max_translation_ratio(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_strict_min_texturedness(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_loose_near_zero_motion(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_overlay_min_ratio(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_overlay_min_features(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

MotionEstimationOptions_OverlayDetectionOptions::MotionEstimationOptions_OverlayDetectionOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mediapipe.MotionEstimationOptions.OverlayDetectionOptions)
}
MotionEstimationOptions_OverlayDetectionOptions::MotionEstimationOptions_OverlayDetectionOptions(const MotionEstimationOptions_OverlayDetectionOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&overlay_min_features_, &from.overlay_min_features_,
    static_cast<size_t>(reinterpret_cast<char*>(&overlay_min_ratio_) -
    reinterpret_cast<char*>(&overlay_min_features_)) + sizeof(overlay_min_ratio_));
  // @@protoc_insertion_point(copy_constructor:mediapipe.MotionEstimationOptions.OverlayDetectionOptions)
}

void MotionEstimationOptions_OverlayDetectionOptions::SharedCtor() {
overlay_min_features_ = 10;
analysis_mask_size_ = 10;
strict_near_zero_motion_ = 0.2f;
strict_max_translation_ratio_ = 0.2f;
loose_near_zero_motion_ = 1;
strict_min_texturedness_ = 0.1f;
overlay_min_ratio_ = 0.3f;
}

MotionEstimationOptions_OverlayDetectionOptions::~MotionEstimationOptions_OverlayDetectionOptions() {
  // @@protoc_insertion_point(destructor:mediapipe.MotionEstimationOptions.OverlayDetectionOptions)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void MotionEstimationOptions_OverlayDetectionOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void MotionEstimationOptions_OverlayDetectionOptions::ArenaDtor(void* object) {
  MotionEstimationOptions_OverlayDetectionOptions* _this = reinterpret_cast< MotionEstimationOptions_OverlayDetectionOptions* >(object);
  (void)_this;
}
void MotionEstimationOptions_OverlayDetectionOptions::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MotionEstimationOptions_OverlayDetectionOptions::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MotionEstimationOptions_OverlayDetectionOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:mediapipe.MotionEstimationOptions.OverlayDetectionOptions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    overlay_min_features_ = 10;
    analysis_mask_size_ = 10;
    strict_near_zero_motion_ = 0.2f;
    strict_max_translation_ratio_ = 0.2f;
    loose_near_zero_motion_ = 1;
    strict_min_texturedness_ = 0.1f;
    overlay_min_ratio_ = 0.3f;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MotionEstimationOptions_OverlayDetectionOptions::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 analysis_mask_size = 1 [default = 10];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_analysis_mask_size(&has_bits);
          analysis_mask_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float strict_near_zero_motion = 2 [default = 0.2];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_strict_near_zero_motion(&has_bits);
          strict_near_zero_motion_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float strict_max_translation_ratio = 3 [default = 0.2];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_strict_max_translation_ratio(&has_bits);
          strict_max_translation_ratio_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float loose_near_zero_motion = 4 [default = 1];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_loose_near_zero_motion(&has_bits);
          loose_near_zero_motion_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float strict_min_texturedness = 5 [default = 0.1];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_strict_min_texturedness(&has_bits);
          strict_min_texturedness_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float overlay_min_ratio = 6 [default = 0.3];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          _Internal::set_has_overlay_min_ratio(&has_bits);
          overlay_min_ratio_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float overlay_min_features = 7 [default = 10];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          _Internal::set_has_overlay_min_features(&has_bits);
          overlay_min_features_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* MotionEstimationOptions_OverlayDetectionOptions::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mediapipe.MotionEstimationOptions.OverlayDetectionOptions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 analysis_mask_size = 1 [default = 10];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_analysis_mask_size(), target);
  }

  // optional float strict_near_zero_motion = 2 [default = 0.2];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_strict_near_zero_motion(), target);
  }

  // optional float strict_max_translation_ratio = 3 [default = 0.2];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_strict_max_translation_ratio(), target);
  }

  // optional float loose_near_zero_motion = 4 [default = 1];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_loose_near_zero_motion(), target);
  }

  // optional float strict_min_texturedness = 5 [default = 0.1];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_strict_min_texturedness(), target);
  }

  // optional float overlay_min_ratio = 6 [default = 0.3];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_overlay_min_ratio(), target);
  }

  // optional float overlay_min_features = 7 [default = 10];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_overlay_min_features(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mediapipe.MotionEstimationOptions.OverlayDetectionOptions)
  return target;
}

size_t MotionEstimationOptions_OverlayDetectionOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mediapipe.MotionEstimationOptions.OverlayDetectionOptions)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional float overlay_min_features = 7 [default = 10];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional int32 analysis_mask_size = 1 [default = 10];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_analysis_mask_size());
    }

    // optional float strict_near_zero_motion = 2 [default = 0.2];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float strict_max_translation_ratio = 3 [default = 0.2];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float loose_near_zero_motion = 4 [default = 1];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float strict_min_texturedness = 5 [default = 0.1];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float overlay_min_ratio = 6 [default = 0.3];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MotionEstimationOptions_OverlayDetectionOptions::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mediapipe.MotionEstimationOptions.OverlayDetectionOptions)
  GOOGLE_DCHECK_NE(&from, this);
  const MotionEstimationOptions_OverlayDetectionOptions* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<MotionEstimationOptions_OverlayDetectionOptions>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mediapipe.MotionEstimationOptions.OverlayDetectionOptions)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mediapipe.MotionEstimationOptions.OverlayDetectionOptions)
    MergeFrom(*source);
  }
}

void MotionEstimationOptions_OverlayDetectionOptions::MergeFrom(const MotionEstimationOptions_OverlayDetectionOptions& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mediapipe.MotionEstimationOptions.OverlayDetectionOptions)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      overlay_min_features_ = from.overlay_min_features_;
    }
    if (cached_has_bits & 0x00000002u) {
      analysis_mask_size_ = from.analysis_mask_size_;
    }
    if (cached_has_bits & 0x00000004u) {
      strict_near_zero_motion_ = from.strict_near_zero_motion_;
    }
    if (cached_has_bits & 0x00000008u) {
      strict_max_translation_ratio_ = from.strict_max_translation_ratio_;
    }
    if (cached_has_bits & 0x00000010u) {
      loose_near_zero_motion_ = from.loose_near_zero_motion_;
    }
    if (cached_has_bits & 0x00000020u) {
      strict_min_texturedness_ = from.strict_min_texturedness_;
    }
    if (cached_has_bits & 0x00000040u) {
      overlay_min_ratio_ = from.overlay_min_ratio_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void MotionEstimationOptions_OverlayDetectionOptions::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mediapipe.MotionEstimationOptions.OverlayDetectionOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MotionEstimationOptions_OverlayDetectionOptions::CopyFrom(const MotionEstimationOptions_OverlayDetectionOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mediapipe.MotionEstimationOptions.OverlayDetectionOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MotionEstimationOptions_OverlayDetectionOptions::IsInitialized() const {
  return true;
}

void MotionEstimationOptions_OverlayDetectionOptions::InternalSwap(MotionEstimationOptions_OverlayDetectionOptions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(overlay_min_features_, other->overlay_min_features_);
  swap(analysis_mask_size_, other->analysis_mask_size_);
  swap(strict_near_zero_motion_, other->strict_near_zero_motion_);
  swap(strict_max_translation_ratio_, other->strict_max_translation_ratio_);
  swap(loose_near_zero_motion_, other->loose_near_zero_motion_);
  swap(strict_min_texturedness_, other->strict_min_texturedness_);
  swap(overlay_min_ratio_, other->overlay_min_ratio_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MotionEstimationOptions_OverlayDetectionOptions::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto_getter, &descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto_once,
      file_level_metadata_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto[9]);
}

// ===================================================================

class MotionEstimationOptions_ShotBoundaryOptions::_Internal {
 public:
  using HasBits = decltype(std::declval<MotionEstimationOptions_ShotBoundaryOptions>()._has_bits_);
  static void set_has_motion_consistency_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_appearance_consistency_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

MotionEstimationOptions_ShotBoundaryOptions::MotionEstimationOptions_ShotBoundaryOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mediapipe.MotionEstimationOptions.ShotBoundaryOptions)
}
MotionEstimationOptions_ShotBoundaryOptions::MotionEstimationOptions_ShotBoundaryOptions(const MotionEstimationOptions_ShotBoundaryOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&motion_consistency_threshold_, &from.motion_consistency_threshold_,
    static_cast<size_t>(reinterpret_cast<char*>(&appearance_consistency_threshold_) -
    reinterpret_cast<char*>(&motion_consistency_threshold_)) + sizeof(appearance_consistency_threshold_));
  // @@protoc_insertion_point(copy_constructor:mediapipe.MotionEstimationOptions.ShotBoundaryOptions)
}

void MotionEstimationOptions_ShotBoundaryOptions::SharedCtor() {
motion_consistency_threshold_ = 0.02f;
appearance_consistency_threshold_ = 0.075f;
}

MotionEstimationOptions_ShotBoundaryOptions::~MotionEstimationOptions_ShotBoundaryOptions() {
  // @@protoc_insertion_point(destructor:mediapipe.MotionEstimationOptions.ShotBoundaryOptions)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void MotionEstimationOptions_ShotBoundaryOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void MotionEstimationOptions_ShotBoundaryOptions::ArenaDtor(void* object) {
  MotionEstimationOptions_ShotBoundaryOptions* _this = reinterpret_cast< MotionEstimationOptions_ShotBoundaryOptions* >(object);
  (void)_this;
}
void MotionEstimationOptions_ShotBoundaryOptions::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MotionEstimationOptions_ShotBoundaryOptions::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MotionEstimationOptions_ShotBoundaryOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:mediapipe.MotionEstimationOptions.ShotBoundaryOptions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    motion_consistency_threshold_ = 0.02f;
    appearance_consistency_threshold_ = 0.075f;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MotionEstimationOptions_ShotBoundaryOptions::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float motion_consistency_threshold = 1 [default = 0.02];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_motion_consistency_threshold(&has_bits);
          motion_consistency_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float appearance_consistency_threshold = 2 [default = 0.075];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_appearance_consistency_threshold(&has_bits);
          appearance_consistency_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* MotionEstimationOptions_ShotBoundaryOptions::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mediapipe.MotionEstimationOptions.ShotBoundaryOptions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float motion_consistency_threshold = 1 [default = 0.02];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_motion_consistency_threshold(), target);
  }

  // optional float appearance_consistency_threshold = 2 [default = 0.075];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_appearance_consistency_threshold(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mediapipe.MotionEstimationOptions.ShotBoundaryOptions)
  return target;
}

size_t MotionEstimationOptions_ShotBoundaryOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mediapipe.MotionEstimationOptions.ShotBoundaryOptions)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional float motion_consistency_threshold = 1 [default = 0.02];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float appearance_consistency_threshold = 2 [default = 0.075];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MotionEstimationOptions_ShotBoundaryOptions::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mediapipe.MotionEstimationOptions.ShotBoundaryOptions)
  GOOGLE_DCHECK_NE(&from, this);
  const MotionEstimationOptions_ShotBoundaryOptions* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<MotionEstimationOptions_ShotBoundaryOptions>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mediapipe.MotionEstimationOptions.ShotBoundaryOptions)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mediapipe.MotionEstimationOptions.ShotBoundaryOptions)
    MergeFrom(*source);
  }
}

void MotionEstimationOptions_ShotBoundaryOptions::MergeFrom(const MotionEstimationOptions_ShotBoundaryOptions& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mediapipe.MotionEstimationOptions.ShotBoundaryOptions)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      motion_consistency_threshold_ = from.motion_consistency_threshold_;
    }
    if (cached_has_bits & 0x00000002u) {
      appearance_consistency_threshold_ = from.appearance_consistency_threshold_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void MotionEstimationOptions_ShotBoundaryOptions::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mediapipe.MotionEstimationOptions.ShotBoundaryOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MotionEstimationOptions_ShotBoundaryOptions::CopyFrom(const MotionEstimationOptions_ShotBoundaryOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mediapipe.MotionEstimationOptions.ShotBoundaryOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MotionEstimationOptions_ShotBoundaryOptions::IsInitialized() const {
  return true;
}

void MotionEstimationOptions_ShotBoundaryOptions::InternalSwap(MotionEstimationOptions_ShotBoundaryOptions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(motion_consistency_threshold_, other->motion_consistency_threshold_);
  swap(appearance_consistency_threshold_, other->appearance_consistency_threshold_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MotionEstimationOptions_ShotBoundaryOptions::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto_getter, &descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto_once,
      file_level_metadata_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto[10]);
}

// ===================================================================

class MotionEstimationOptions::_Internal {
 public:
  using HasBits = decltype(std::declval<MotionEstimationOptions>()._has_bits_);
  static void set_has_estimate_translation_irls(HasBits* has_bits) {
    (*has_bits)[1] |= 64u;
  }
  static void set_has_linear_similarity_estimation(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_affine_estimation(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_homography_estimation(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_homography_exact_denominator_scaling(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_use_exact_homography_estimation(HasBits* has_bits) {
    (*has_bits)[1] |= 128u;
  }
  static void set_has_use_highest_accuracy_for_normal_equations(HasBits* has_bits) {
    (*has_bits)[1] |= 256u;
  }
  static void set_has_homography_perspective_regularizer(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_mix_homography_estimation(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_num_mixtures(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_mixture_row_sigma(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_mixture_regularizer(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_mixture_regularizer_levels(HasBits* has_bits) {
    (*has_bits)[1] |= 131072u;
  }
  static void set_has_mixture_regularizer_base(HasBits* has_bits) {
    (*has_bits)[1] |= 262144u;
  }
  static void set_has_mixture_rs_analysis_level(HasBits* has_bits) {
    (*has_bits)[1] |= 524288u;
  }
  static void set_has_irls_rounds(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_irls_prior_scale(HasBits* has_bits) {
    (*has_bits)[1] |= 4194304u;
  }
  static void set_has_irls_motion_magnitude_fraction(HasBits* has_bits) {
    (*has_bits)[1] |= 1024u;
  }
  static void set_has_irls_mixture_fraction_scale(HasBits* has_bits) {
    (*has_bits)[1] |= 67108864u;
  }
  static void set_has_irls_weights_preinitialized(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_filter_initialized_irls_weights(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static const ::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization& irls_initialization(const MotionEstimationOptions* msg);
  static void set_has_irls_initialization(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_feature_density_normalization(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_feature_mask_size(HasBits* has_bits) {
    (*has_bits)[1] |= 33554432u;
  }
  static const ::mediapipe::MotionEstimationOptions_LongFeatureInitialization& long_feature_initialization(const MotionEstimationOptions* msg);
  static void set_has_long_feature_initialization(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::mediapipe::MotionEstimationOptions_IrlsMaskOptions& irls_mask_options(const MotionEstimationOptions* msg);
  static void set_has_irls_mask_options(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions& joint_track_estimation(const MotionEstimationOptions* msg);
  static void set_has_joint_track_estimation(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions& long_feature_bias_options(const MotionEstimationOptions* msg);
  static void set_has_long_feature_bias_options(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_estimation_policy(HasBits* has_bits) {
    (*has_bits)[1] |= 16777216u;
  }
  static void set_has_coverage_grid_size(HasBits* has_bits) {
    (*has_bits)[1] |= 8388608u;
  }
  static void set_has_mixture_model_mode(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static void set_has_use_only_lin_sim_inliers_for_homography(HasBits* has_bits) {
    (*has_bits)[1] |= 512u;
  }
  static void set_has_lin_sim_inlier_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static const ::mediapipe::MotionEstimationOptions_TranslationBounds& stable_translation_bounds(const MotionEstimationOptions* msg);
  static void set_has_stable_translation_bounds(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::mediapipe::MotionEstimationOptions_SimilarityBounds& stable_similarity_bounds(const MotionEstimationOptions* msg);
  static void set_has_stable_similarity_bounds(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::mediapipe::MotionEstimationOptions_HomographyBounds& stable_homography_bounds(const MotionEstimationOptions* msg);
  static void set_has_stable_homography_bounds(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::mediapipe::MotionEstimationOptions_MixtureHomographyBounds& stable_mixture_homography_bounds(const MotionEstimationOptions* msg);
  static void set_has_stable_mixture_homography_bounds(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_strict_coverage_scale(HasBits* has_bits) {
    (*has_bits)[1] |= 65536u;
  }
  static void set_has_label_empty_frames_as_valid(HasBits* has_bits) {
    (*has_bits)[1] |= 4096u;
  }
  static void set_has_feature_grid_size(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static void set_has_spatial_sigma(HasBits* has_bits) {
    (*has_bits)[1] |= 4u;
  }
  static void set_has_temporal_irls_diameter(HasBits* has_bits) {
    (*has_bits)[1] |= 8u;
  }
  static void set_has_temporal_sigma(HasBits* has_bits) {
    (*has_bits)[1] |= 16u;
  }
  static void set_has_feature_sigma(HasBits* has_bits) {
    (*has_bits)[1] |= 32u;
  }
  static void set_has_filter_5_taps(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_frame_confidence_weighting(HasBits* has_bits) {
    (*has_bits)[1] |= 8192u;
  }
  static void set_has_reset_confidence_threshold(HasBits* has_bits) {
    (*has_bits)[1] |= 2097152u;
  }
  static void set_has_irls_weight_filter(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_overlay_detection(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_overlay_analysis_chunk_size(HasBits* has_bits) {
    (*has_bits)[1] |= 2048u;
  }
  static const ::mediapipe::MotionEstimationOptions_OverlayDetectionOptions& overlay_detection_options(const MotionEstimationOptions* msg);
  static void set_has_overlay_detection_options(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::mediapipe::MotionEstimationOptions_ShotBoundaryOptions& shot_boundary_options(const MotionEstimationOptions* msg);
  static void set_has_shot_boundary_options(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_output_refined_irls_weights(HasBits* has_bits) {
    (*has_bits)[1] |= 16384u;
  }
  static void set_has_homography_irls_weight_initialization(HasBits* has_bits) {
    (*has_bits)[1] |= 1048576u;
  }
  static void set_has_irls_use_l0_norm(HasBits* has_bits) {
    (*has_bits)[1] |= 32768u;
  }
  static void set_has_domain_limited_irls_scaling(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_deactivate_stable_motion_estimation(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_project_valid_motions_down(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_estimate_similarity(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
};

const ::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization&
MotionEstimationOptions::_Internal::irls_initialization(const MotionEstimationOptions* msg) {
  return *msg->irls_initialization_;
}
const ::mediapipe::MotionEstimationOptions_LongFeatureInitialization&
MotionEstimationOptions::_Internal::long_feature_initialization(const MotionEstimationOptions* msg) {
  return *msg->long_feature_initialization_;
}
const ::mediapipe::MotionEstimationOptions_IrlsMaskOptions&
MotionEstimationOptions::_Internal::irls_mask_options(const MotionEstimationOptions* msg) {
  return *msg->irls_mask_options_;
}
const ::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions&
MotionEstimationOptions::_Internal::joint_track_estimation(const MotionEstimationOptions* msg) {
  return *msg->joint_track_estimation_;
}
const ::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions&
MotionEstimationOptions::_Internal::long_feature_bias_options(const MotionEstimationOptions* msg) {
  return *msg->long_feature_bias_options_;
}
const ::mediapipe::MotionEstimationOptions_TranslationBounds&
MotionEstimationOptions::_Internal::stable_translation_bounds(const MotionEstimationOptions* msg) {
  return *msg->stable_translation_bounds_;
}
const ::mediapipe::MotionEstimationOptions_SimilarityBounds&
MotionEstimationOptions::_Internal::stable_similarity_bounds(const MotionEstimationOptions* msg) {
  return *msg->stable_similarity_bounds_;
}
const ::mediapipe::MotionEstimationOptions_HomographyBounds&
MotionEstimationOptions::_Internal::stable_homography_bounds(const MotionEstimationOptions* msg) {
  return *msg->stable_homography_bounds_;
}
const ::mediapipe::MotionEstimationOptions_MixtureHomographyBounds&
MotionEstimationOptions::_Internal::stable_mixture_homography_bounds(const MotionEstimationOptions* msg) {
  return *msg->stable_mixture_homography_bounds_;
}
const ::mediapipe::MotionEstimationOptions_OverlayDetectionOptions&
MotionEstimationOptions::_Internal::overlay_detection_options(const MotionEstimationOptions* msg) {
  return *msg->overlay_detection_options_;
}
const ::mediapipe::MotionEstimationOptions_ShotBoundaryOptions&
MotionEstimationOptions::_Internal::shot_boundary_options(const MotionEstimationOptions* msg) {
  return *msg->shot_boundary_options_;
}
MotionEstimationOptions::MotionEstimationOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  _extensions_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:mediapipe.MotionEstimationOptions)
}
MotionEstimationOptions::MotionEstimationOptions(const MotionEstimationOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _extensions_.MergeFrom(from._extensions_);
  if (from._internal_has_stable_homography_bounds()) {
    stable_homography_bounds_ = new ::mediapipe::MotionEstimationOptions_HomographyBounds(*from.stable_homography_bounds_);
  } else {
    stable_homography_bounds_ = nullptr;
  }
  if (from._internal_has_stable_translation_bounds()) {
    stable_translation_bounds_ = new ::mediapipe::MotionEstimationOptions_TranslationBounds(*from.stable_translation_bounds_);
  } else {
    stable_translation_bounds_ = nullptr;
  }
  if (from._internal_has_stable_similarity_bounds()) {
    stable_similarity_bounds_ = new ::mediapipe::MotionEstimationOptions_SimilarityBounds(*from.stable_similarity_bounds_);
  } else {
    stable_similarity_bounds_ = nullptr;
  }
  if (from._internal_has_stable_mixture_homography_bounds()) {
    stable_mixture_homography_bounds_ = new ::mediapipe::MotionEstimationOptions_MixtureHomographyBounds(*from.stable_mixture_homography_bounds_);
  } else {
    stable_mixture_homography_bounds_ = nullptr;
  }
  if (from._internal_has_overlay_detection_options()) {
    overlay_detection_options_ = new ::mediapipe::MotionEstimationOptions_OverlayDetectionOptions(*from.overlay_detection_options_);
  } else {
    overlay_detection_options_ = nullptr;
  }
  if (from._internal_has_irls_initialization()) {
    irls_initialization_ = new ::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization(*from.irls_initialization_);
  } else {
    irls_initialization_ = nullptr;
  }
  if (from._internal_has_irls_mask_options()) {
    irls_mask_options_ = new ::mediapipe::MotionEstimationOptions_IrlsMaskOptions(*from.irls_mask_options_);
  } else {
    irls_mask_options_ = nullptr;
  }
  if (from._internal_has_joint_track_estimation()) {
    joint_track_estimation_ = new ::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions(*from.joint_track_estimation_);
  } else {
    joint_track_estimation_ = nullptr;
  }
  if (from._internal_has_shot_boundary_options()) {
    shot_boundary_options_ = new ::mediapipe::MotionEstimationOptions_ShotBoundaryOptions(*from.shot_boundary_options_);
  } else {
    shot_boundary_options_ = nullptr;
  }
  if (from._internal_has_long_feature_bias_options()) {
    long_feature_bias_options_ = new ::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions(*from.long_feature_bias_options_);
  } else {
    long_feature_bias_options_ = nullptr;
  }
  if (from._internal_has_long_feature_initialization()) {
    long_feature_initialization_ = new ::mediapipe::MotionEstimationOptions_LongFeatureInitialization(*from.long_feature_initialization_);
  } else {
    long_feature_initialization_ = nullptr;
  }
  ::memcpy(&mix_homography_estimation_, &from.mix_homography_estimation_,
    static_cast<size_t>(reinterpret_cast<char*>(&irls_mixture_fraction_scale_) -
    reinterpret_cast<char*>(&mix_homography_estimation_)) + sizeof(irls_mixture_fraction_scale_));
  // @@protoc_insertion_point(copy_constructor:mediapipe.MotionEstimationOptions)
}

void MotionEstimationOptions::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&stable_homography_bounds_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&homography_perspective_regularizer_) -
    reinterpret_cast<char*>(&stable_homography_bounds_)) + sizeof(homography_perspective_regularizer_));
linear_similarity_estimation_ = 4;
homography_estimation_ = 2;
num_mixtures_ = 10;
mixture_row_sigma_ = 0.1f;
mixture_regularizer_ = 0.0001f;
irls_rounds_ = 10;
lin_sim_inlier_threshold_ = 0.003f;
mixture_model_mode_ = 2;
feature_grid_size_ = 0.05f;
spatial_sigma_ = 0.01f;
temporal_irls_diameter_ = 20;
temporal_sigma_ = 5;
feature_sigma_ = 30;
estimate_translation_irls_ = true;
use_exact_homography_estimation_ = true;
use_highest_accuracy_for_normal_equations_ = true;
use_only_lin_sim_inliers_for_homography_ = true;
irls_motion_magnitude_fraction_ = 0.08f;
overlay_analysis_chunk_size_ = 8;
label_empty_frames_as_valid_ = true;
frame_confidence_weighting_ = true;
output_refined_irls_weights_ = true;
irls_use_l0_norm_ = true;
strict_coverage_scale_ = 1.333f;
mixture_regularizer_levels_ = 3;
mixture_regularizer_base_ = 2.2f;
mixture_rs_analysis_level_ = 2;
homography_irls_weight_initialization_ = 3;
reset_confidence_threshold_ = 0.4f;
irls_prior_scale_ = 0.2f;
coverage_grid_size_ = 10;
estimation_policy_ = 1;
feature_mask_size_ = 10;
irls_mixture_fraction_scale_ = 1.5f;
}

MotionEstimationOptions::~MotionEstimationOptions() {
  // @@protoc_insertion_point(destructor:mediapipe.MotionEstimationOptions)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void MotionEstimationOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete stable_homography_bounds_;
  if (this != internal_default_instance()) delete stable_translation_bounds_;
  if (this != internal_default_instance()) delete stable_similarity_bounds_;
  if (this != internal_default_instance()) delete stable_mixture_homography_bounds_;
  if (this != internal_default_instance()) delete overlay_detection_options_;
  if (this != internal_default_instance()) delete irls_initialization_;
  if (this != internal_default_instance()) delete irls_mask_options_;
  if (this != internal_default_instance()) delete joint_track_estimation_;
  if (this != internal_default_instance()) delete shot_boundary_options_;
  if (this != internal_default_instance()) delete long_feature_bias_options_;
  if (this != internal_default_instance()) delete long_feature_initialization_;
}

void MotionEstimationOptions::ArenaDtor(void* object) {
  MotionEstimationOptions* _this = reinterpret_cast< MotionEstimationOptions* >(object);
  (void)_this;
}
void MotionEstimationOptions::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MotionEstimationOptions::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MotionEstimationOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:mediapipe.MotionEstimationOptions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _extensions_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(stable_homography_bounds_ != nullptr);
      stable_homography_bounds_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(stable_translation_bounds_ != nullptr);
      stable_translation_bounds_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(stable_similarity_bounds_ != nullptr);
      stable_similarity_bounds_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(stable_mixture_homography_bounds_ != nullptr);
      stable_mixture_homography_bounds_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(overlay_detection_options_ != nullptr);
      overlay_detection_options_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(irls_initialization_ != nullptr);
      irls_initialization_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(irls_mask_options_ != nullptr);
      irls_mask_options_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(joint_track_estimation_ != nullptr);
      joint_track_estimation_->Clear();
    }
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(shot_boundary_options_ != nullptr);
      shot_boundary_options_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(long_feature_bias_options_ != nullptr);
      long_feature_bias_options_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(long_feature_initialization_ != nullptr);
      long_feature_initialization_->Clear();
    }
  }
  if (cached_has_bits & 0x0000f800u) {
    ::memset(&mix_homography_estimation_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&irls_weight_filter_) -
        reinterpret_cast<char*>(&mix_homography_estimation_)) + sizeof(irls_weight_filter_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&filter_5_taps_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&feature_density_normalization_) -
        reinterpret_cast<char*>(&filter_5_taps_)) + sizeof(feature_density_normalization_));
  }
  if (cached_has_bits & 0xff000000u) {
    homography_perspective_regularizer_ = 0;
    linear_similarity_estimation_ = 4;
    homography_estimation_ = 2;
    num_mixtures_ = 10;
    mixture_row_sigma_ = 0.1f;
    mixture_regularizer_ = 0.0001f;
    irls_rounds_ = 10;
    lin_sim_inlier_threshold_ = 0.003f;
  }
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    mixture_model_mode_ = 2;
    feature_grid_size_ = 0.05f;
    spatial_sigma_ = 0.01f;
    temporal_irls_diameter_ = 20;
    temporal_sigma_ = 5;
    feature_sigma_ = 30;
    estimate_translation_irls_ = true;
    use_exact_homography_estimation_ = true;
  }
  if (cached_has_bits & 0x0000ff00u) {
    use_highest_accuracy_for_normal_equations_ = true;
    use_only_lin_sim_inliers_for_homography_ = true;
    irls_motion_magnitude_fraction_ = 0.08f;
    overlay_analysis_chunk_size_ = 8;
    label_empty_frames_as_valid_ = true;
    frame_confidence_weighting_ = true;
    output_refined_irls_weights_ = true;
    irls_use_l0_norm_ = true;
  }
  if (cached_has_bits & 0x00ff0000u) {
    strict_coverage_scale_ = 1.333f;
    mixture_regularizer_levels_ = 3;
    mixture_regularizer_base_ = 2.2f;
    mixture_rs_analysis_level_ = 2;
    homography_irls_weight_initialization_ = 3;
    reset_confidence_threshold_ = 0.4f;
    irls_prior_scale_ = 0.2f;
    coverage_grid_size_ = 10;
  }
  if (cached_has_bits & 0x07000000u) {
    estimation_policy_ = 1;
    feature_mask_size_ = 10;
    irls_mixture_fraction_scale_ = 1.5f;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MotionEstimationOptions::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool estimate_translation_irls = 1 [default = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_estimate_translation_irls(&_has_bits_);
          estimate_translation_irls_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool estimate_similarity = 2 [deprecated = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_estimate_similarity(&_has_bits_);
          estimate_similarity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mediapipe.MotionEstimationOptions.LinearSimilarityEstimation linear_similarity_estimation = 3 [default = ESTIMATION_LS_IRLS];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mediapipe::MotionEstimationOptions_LinearSimilarityEstimation_IsValid(val))) {
            _internal_set_linear_similarity_estimation(static_cast<::mediapipe::MotionEstimationOptions_LinearSimilarityEstimation>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .mediapipe.MotionEstimationOptions.HomographyEstimation homography_estimation = 5 [default = ESTIMATION_HOMOG_IRLS];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mediapipe::MotionEstimationOptions_HomographyEstimation_IsValid(val))) {
            _internal_set_homography_estimation(static_cast<::mediapipe::MotionEstimationOptions_HomographyEstimation>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bool use_only_lin_sim_inliers_for_homography = 6 [default = true];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_use_only_lin_sim_inliers_for_homography(&_has_bits_);
          use_only_lin_sim_inliers_for_homography_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mediapipe.MotionEstimationOptions.HomographyBounds stable_homography_bounds = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_stable_homography_bounds(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mediapipe.MotionEstimationOptions.MixtureHomographyEstimation mix_homography_estimation = 12 [default = ESTIMATION_HOMOG_MIX_NONE];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mediapipe::MotionEstimationOptions_MixtureHomographyEstimation_IsValid(val))) {
            _internal_set_mix_homography_estimation(static_cast<::mediapipe::MotionEstimationOptions_MixtureHomographyEstimation>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(12, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional int32 num_mixtures = 13 [default = 10];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_num_mixtures(&_has_bits_);
          num_mixtures_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float mixture_row_sigma = 14 [default = 0.1];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 117)) {
          _Internal::set_has_mixture_row_sigma(&_has_bits_);
          mixture_row_sigma_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float mixture_regularizer = 15 [default = 0.0001];
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 125)) {
          _Internal::set_has_mixture_regularizer(&_has_bits_);
          mixture_regularizer_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional int32 irls_rounds = 17 [default = 10];
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 136)) {
          _Internal::set_has_irls_rounds(&_has_bits_);
          irls_rounds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float lin_sim_inlier_threshold = 20 [default = 0.003];
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 165)) {
          _Internal::set_has_lin_sim_inlier_threshold(&_has_bits_);
          lin_sim_inlier_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional bool label_empty_frames_as_valid = 22 [default = true];
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 176)) {
          _Internal::set_has_label_empty_frames_as_valid(&_has_bits_);
          label_empty_frames_as_valid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mediapipe.MotionEstimationOptions.MixtureModelMode mixture_model_mode = 23 [default = SKEW_ROTATION_MIXTURE];
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 184)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mediapipe::MotionEstimationOptions_MixtureModelMode_IsValid(val))) {
            _internal_set_mixture_model_mode(static_cast<::mediapipe::MotionEstimationOptions_MixtureModelMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(23, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional float feature_grid_size = 24 [default = 0.05];
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 197)) {
          _Internal::set_has_feature_grid_size(&_has_bits_);
          feature_grid_size_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float spatial_sigma = 25 [default = 0.01];
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 205)) {
          _Internal::set_has_spatial_sigma(&_has_bits_);
          spatial_sigma_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional int32 temporal_irls_diameter = 26 [default = 20];
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 208)) {
          _Internal::set_has_temporal_irls_diameter(&_has_bits_);
          temporal_irls_diameter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float temporal_sigma = 27 [default = 5];
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 221)) {
          _Internal::set_has_temporal_sigma(&_has_bits_);
          temporal_sigma_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float feature_sigma = 28 [default = 30];
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 229)) {
          _Internal::set_has_feature_sigma(&_has_bits_);
          feature_sigma_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional bool filter_5_taps = 29 [default = false];
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 232)) {
          _Internal::set_has_filter_5_taps(&_has_bits_);
          filter_5_taps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mediapipe.MotionEstimationOptions.AffineEstimation affine_estimation = 30 [default = ESTIMATION_AFFINE_NONE];
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 240)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mediapipe::MotionEstimationOptions_AffineEstimation_IsValid(val))) {
            _internal_set_affine_estimation(static_cast<::mediapipe::MotionEstimationOptions_AffineEstimation>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(30, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional float irls_motion_magnitude_fraction = 31 [default = 0.08];
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 253)) {
          _Internal::set_has_irls_motion_magnitude_fraction(&_has_bits_);
          irls_motion_magnitude_fraction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional .mediapipe.MotionEstimationOptions.TranslationBounds stable_translation_bounds = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_stable_translation_bounds(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mediapipe.MotionEstimationOptions.SimilarityBounds stable_similarity_bounds = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_stable_similarity_bounds(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mediapipe.MotionEstimationOptions.MixtureHomographyBounds stable_mixture_homography_bounds = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_stable_mixture_homography_bounds(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mediapipe.MotionEstimationOptions.IRLSWeightFilter irls_weight_filter = 35 [default = IRLS_FILTER_NONE];
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mediapipe::MotionEstimationOptions_IRLSWeightFilter_IsValid(val))) {
            _internal_set_irls_weight_filter(static_cast<::mediapipe::MotionEstimationOptions_IRLSWeightFilter>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(35, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bool overlay_detection = 36 [default = false];
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_overlay_detection(&_has_bits_);
          overlay_detection_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 overlay_analysis_chunk_size = 37 [default = 8];
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_overlay_analysis_chunk_size(&_has_bits_);
          overlay_analysis_chunk_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mediapipe.MotionEstimationOptions.OverlayDetectionOptions overlay_detection_options = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_overlay_detection_options(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool irls_weights_preinitialized = 39 [default = false];
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_irls_weights_preinitialized(&_has_bits_);
          irls_weights_preinitialized_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool output_refined_irls_weights = 40 [default = true];
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_output_refined_irls_weights(&_has_bits_);
          output_refined_irls_weights_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float strict_coverage_scale = 41 [default = 1.333];
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 77)) {
          _Internal::set_has_strict_coverage_scale(&_has_bits_);
          strict_coverage_scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float mixture_regularizer_levels = 42 [default = 3];
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 85)) {
          _Internal::set_has_mixture_regularizer_levels(&_has_bits_);
          mixture_regularizer_levels_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float mixture_regularizer_base = 43 [default = 2.2];
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 93)) {
          _Internal::set_has_mixture_regularizer_base(&_has_bits_);
          mixture_regularizer_base_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional int32 mixture_rs_analysis_level = 44 [default = 2];
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_mixture_rs_analysis_level(&_has_bits_);
          mixture_rs_analysis_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mediapipe.MotionEstimationOptions.HomographyIrlsWeightInitialization homography_irls_weight_initialization = 45 [default = IRLS_WEIGHT_PERIMETER_GAUSSIAN];
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mediapipe::MotionEstimationOptions_HomographyIrlsWeightInitialization_IsValid(val))) {
            _internal_set_homography_irls_weight_initialization(static_cast<::mediapipe::MotionEstimationOptions_HomographyIrlsWeightInitialization>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(45, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bool irls_use_l0_norm = 46 [default = true];
      case 46:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          _Internal::set_has_irls_use_l0_norm(&_has_bits_);
          irls_use_l0_norm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool deactivate_stable_motion_estimation = 47 [default = false];
      case 47:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 120)) {
          _Internal::set_has_deactivate_stable_motion_estimation(&_has_bits_);
          deactivate_stable_motion_estimation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool frame_confidence_weighting = 48 [default = true];
      case 48:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 128)) {
          _Internal::set_has_frame_confidence_weighting(&_has_bits_);
          frame_confidence_weighting_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float reset_confidence_threshold = 49 [default = 0.4];
      case 49:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 141)) {
          _Internal::set_has_reset_confidence_threshold(&_has_bits_);
          reset_confidence_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float irls_prior_scale = 50 [default = 0.2];
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 149)) {
          _Internal::set_has_irls_prior_scale(&_has_bits_);
          irls_prior_scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional int32 coverage_grid_size = 51 [default = 10];
      case 51:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 152)) {
          _Internal::set_has_coverage_grid_size(&_has_bits_);
          coverage_grid_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool project_valid_motions_down = 52 [default = false];
      case 52:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 160)) {
          _Internal::set_has_project_valid_motions_down(&_has_bits_);
          project_valid_motions_down_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool homography_exact_denominator_scaling = 53 [default = false];
      case 53:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 168)) {
          _Internal::set_has_homography_exact_denominator_scaling(&_has_bits_);
          homography_exact_denominator_scaling_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool use_exact_homography_estimation = 54 [default = true];
      case 54:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 176)) {
          _Internal::set_has_use_exact_homography_estimation(&_has_bits_);
          use_exact_homography_estimation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool use_highest_accuracy_for_normal_equations = 55 [default = true];
      case 55:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 184)) {
          _Internal::set_has_use_highest_accuracy_for_normal_equations(&_has_bits_);
          use_highest_accuracy_for_normal_equations_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mediapipe.MotionEstimationOptions.IrlsOutlierInitialization irls_initialization = 56;
      case 56:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_irls_initialization(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mediapipe.MotionEstimationOptions.IrlsMaskOptions irls_mask_options = 57;
      case 57:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_irls_mask_options(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mediapipe.MotionEstimationOptions.EstimationPolicy estimation_policy = 58 [default = INDEPENDENT_PARALLEL];
      case 58:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 208)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::mediapipe::MotionEstimationOptions_EstimationPolicy_IsValid(val))) {
            _internal_set_estimation_policy(static_cast<::mediapipe::MotionEstimationOptions_EstimationPolicy>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(58, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .mediapipe.MotionEstimationOptions.JointTrackEstimationOptions joint_track_estimation = 59;
      case 59:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_joint_track_estimation(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mediapipe.MotionEstimationOptions.ShotBoundaryOptions shot_boundary_options = 60;
      case 60:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_shot_boundary_options(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float homography_perspective_regularizer = 61 [default = 0];
      case 61:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 237)) {
          _Internal::set_has_homography_perspective_regularizer(&_has_bits_);
          homography_perspective_regularizer_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional bool feature_density_normalization = 62 [default = false];
      case 62:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 240)) {
          _Internal::set_has_feature_density_normalization(&_has_bits_);
          feature_density_normalization_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 feature_mask_size = 63 [default = 10];
      case 63:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 248)) {
          _Internal::set_has_feature_mask_size(&_has_bits_);
          feature_mask_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mediapipe.MotionEstimationOptions.LongFeatureBiasOptions long_feature_bias_options = 64;
      case 64:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 2)) {
          ptr = ctx->ParseMessage(_internal_mutable_long_feature_bias_options(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool domain_limited_irls_scaling = 65 [default = false];
      case 65:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_domain_limited_irls_scaling(&_has_bits_);
          domain_limited_irls_scaling_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .mediapipe.MotionEstimationOptions.LongFeatureInitialization long_feature_initialization = 66;
      case 66:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_long_feature_initialization(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool filter_initialized_irls_weights = 67 [default = false];
      case 67:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_filter_initialized_irls_weights(&_has_bits_);
          filter_initialized_irls_weights_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float irls_mixture_fraction_scale = 68 [default = 1.5];
      case 68:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_irls_mixture_fraction_scale(&_has_bits_);
          irls_mixture_fraction_scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
      if ((56u <= tag && tag < 64u) ||
          (64u <= tag && tag < 72u) ||
          (128u <= tag && tag < 136u)) {
        ptr = _extensions_.ParseField(tag, ptr,
            internal_default_instance(), &_internal_metadata_, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* MotionEstimationOptions::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mediapipe.MotionEstimationOptions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[1];
  // optional bool estimate_translation_irls = 1 [default = true];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_estimate_translation_irls(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool estimate_similarity = 2 [deprecated = true];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_estimate_similarity(), target);
  }

  // optional .mediapipe.MotionEstimationOptions.LinearSimilarityEstimation linear_similarity_estimation = 3 [default = ESTIMATION_LS_IRLS];
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_linear_similarity_estimation(), target);
  }

  // optional .mediapipe.MotionEstimationOptions.HomographyEstimation homography_estimation = 5 [default = ESTIMATION_HOMOG_IRLS];
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_homography_estimation(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional bool use_only_lin_sim_inliers_for_homography = 6 [default = true];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_use_only_lin_sim_inliers_for_homography(), target);
  }

  // Extension range [7, 9)
  target = _extensions_._InternalSerialize(
      7, 9, target, stream);

  cached_has_bits = _has_bits_[0];
  // optional .mediapipe.MotionEstimationOptions.HomographyBounds stable_homography_bounds = 11;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::stable_homography_bounds(this), target, stream);
  }

  // optional .mediapipe.MotionEstimationOptions.MixtureHomographyEstimation mix_homography_estimation = 12 [default = ESTIMATION_HOMOG_MIX_NONE];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      12, this->_internal_mix_homography_estimation(), target);
  }

  // optional int32 num_mixtures = 13 [default = 10];
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(13, this->_internal_num_mixtures(), target);
  }

  // optional float mixture_row_sigma = 14 [default = 0.1];
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(14, this->_internal_mixture_row_sigma(), target);
  }

  // optional float mixture_regularizer = 15 [default = 0.0001];
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(15, this->_internal_mixture_regularizer(), target);
  }

  // Extension range [16, 17)
  target = _extensions_._InternalSerialize(
      16, 17, target, stream);

  // optional int32 irls_rounds = 17 [default = 10];
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(17, this->_internal_irls_rounds(), target);
  }

  // optional float lin_sim_inlier_threshold = 20 [default = 0.003];
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(20, this->_internal_lin_sim_inlier_threshold(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional bool label_empty_frames_as_valid = 22 [default = true];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(22, this->_internal_label_empty_frames_as_valid(), target);
  }

  // optional .mediapipe.MotionEstimationOptions.MixtureModelMode mixture_model_mode = 23 [default = SKEW_ROTATION_MIXTURE];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      23, this->_internal_mixture_model_mode(), target);
  }

  // optional float feature_grid_size = 24 [default = 0.05];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(24, this->_internal_feature_grid_size(), target);
  }

  // optional float spatial_sigma = 25 [default = 0.01];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(25, this->_internal_spatial_sigma(), target);
  }

  // optional int32 temporal_irls_diameter = 26 [default = 20];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(26, this->_internal_temporal_irls_diameter(), target);
  }

  // optional float temporal_sigma = 27 [default = 5];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(27, this->_internal_temporal_sigma(), target);
  }

  // optional float feature_sigma = 28 [default = 30];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(28, this->_internal_feature_sigma(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool filter_5_taps = 29 [default = false];
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(29, this->_internal_filter_5_taps(), target);
  }

  // optional .mediapipe.MotionEstimationOptions.AffineEstimation affine_estimation = 30 [default = ESTIMATION_AFFINE_NONE];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      30, this->_internal_affine_estimation(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional float irls_motion_magnitude_fraction = 31 [default = 0.08];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(31, this->_internal_irls_motion_magnitude_fraction(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional .mediapipe.MotionEstimationOptions.TranslationBounds stable_translation_bounds = 32;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        32, _Internal::stable_translation_bounds(this), target, stream);
  }

  // optional .mediapipe.MotionEstimationOptions.SimilarityBounds stable_similarity_bounds = 33;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        33, _Internal::stable_similarity_bounds(this), target, stream);
  }

  // optional .mediapipe.MotionEstimationOptions.MixtureHomographyBounds stable_mixture_homography_bounds = 34;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        34, _Internal::stable_mixture_homography_bounds(this), target, stream);
  }

  // optional .mediapipe.MotionEstimationOptions.IRLSWeightFilter irls_weight_filter = 35 [default = IRLS_FILTER_NONE];
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      35, this->_internal_irls_weight_filter(), target);
  }

  // optional bool overlay_detection = 36 [default = false];
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(36, this->_internal_overlay_detection(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional int32 overlay_analysis_chunk_size = 37 [default = 8];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(37, this->_internal_overlay_analysis_chunk_size(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional .mediapipe.MotionEstimationOptions.OverlayDetectionOptions overlay_detection_options = 38;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        38, _Internal::overlay_detection_options(this), target, stream);
  }

  // optional bool irls_weights_preinitialized = 39 [default = false];
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(39, this->_internal_irls_weights_preinitialized(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional bool output_refined_irls_weights = 40 [default = true];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(40, this->_internal_output_refined_irls_weights(), target);
  }

  // optional float strict_coverage_scale = 41 [default = 1.333];
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(41, this->_internal_strict_coverage_scale(), target);
  }

  // optional float mixture_regularizer_levels = 42 [default = 3];
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(42, this->_internal_mixture_regularizer_levels(), target);
  }

  // optional float mixture_regularizer_base = 43 [default = 2.2];
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(43, this->_internal_mixture_regularizer_base(), target);
  }

  // optional int32 mixture_rs_analysis_level = 44 [default = 2];
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(44, this->_internal_mixture_rs_analysis_level(), target);
  }

  // optional .mediapipe.MotionEstimationOptions.HomographyIrlsWeightInitialization homography_irls_weight_initialization = 45 [default = IRLS_WEIGHT_PERIMETER_GAUSSIAN];
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      45, this->_internal_homography_irls_weight_initialization(), target);
  }

  // optional bool irls_use_l0_norm = 46 [default = true];
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(46, this->_internal_irls_use_l0_norm(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool deactivate_stable_motion_estimation = 47 [default = false];
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(47, this->_internal_deactivate_stable_motion_estimation(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional bool frame_confidence_weighting = 48 [default = true];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(48, this->_internal_frame_confidence_weighting(), target);
  }

  // optional float reset_confidence_threshold = 49 [default = 0.4];
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(49, this->_internal_reset_confidence_threshold(), target);
  }

  // optional float irls_prior_scale = 50 [default = 0.2];
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(50, this->_internal_irls_prior_scale(), target);
  }

  // optional int32 coverage_grid_size = 51 [default = 10];
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(51, this->_internal_coverage_grid_size(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool project_valid_motions_down = 52 [default = false];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(52, this->_internal_project_valid_motions_down(), target);
  }

  // optional bool homography_exact_denominator_scaling = 53 [default = false];
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(53, this->_internal_homography_exact_denominator_scaling(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional bool use_exact_homography_estimation = 54 [default = true];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(54, this->_internal_use_exact_homography_estimation(), target);
  }

  // optional bool use_highest_accuracy_for_normal_equations = 55 [default = true];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(55, this->_internal_use_highest_accuracy_for_normal_equations(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional .mediapipe.MotionEstimationOptions.IrlsOutlierInitialization irls_initialization = 56;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        56, _Internal::irls_initialization(this), target, stream);
  }

  // optional .mediapipe.MotionEstimationOptions.IrlsMaskOptions irls_mask_options = 57;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        57, _Internal::irls_mask_options(this), target, stream);
  }

  cached_has_bits = _has_bits_[1];
  // optional .mediapipe.MotionEstimationOptions.EstimationPolicy estimation_policy = 58 [default = INDEPENDENT_PARALLEL];
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      58, this->_internal_estimation_policy(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional .mediapipe.MotionEstimationOptions.JointTrackEstimationOptions joint_track_estimation = 59;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        59, _Internal::joint_track_estimation(this), target, stream);
  }

  // optional .mediapipe.MotionEstimationOptions.ShotBoundaryOptions shot_boundary_options = 60;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        60, _Internal::shot_boundary_options(this), target, stream);
  }

  // optional float homography_perspective_regularizer = 61 [default = 0];
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(61, this->_internal_homography_perspective_regularizer(), target);
  }

  // optional bool feature_density_normalization = 62 [default = false];
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(62, this->_internal_feature_density_normalization(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional int32 feature_mask_size = 63 [default = 10];
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(63, this->_internal_feature_mask_size(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional .mediapipe.MotionEstimationOptions.LongFeatureBiasOptions long_feature_bias_options = 64;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        64, _Internal::long_feature_bias_options(this), target, stream);
  }

  // optional bool domain_limited_irls_scaling = 65 [default = false];
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(65, this->_internal_domain_limited_irls_scaling(), target);
  }

  // optional .mediapipe.MotionEstimationOptions.LongFeatureInitialization long_feature_initialization = 66;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        66, _Internal::long_feature_initialization(this), target, stream);
  }

  // optional bool filter_initialized_irls_weights = 67 [default = false];
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(67, this->_internal_filter_initialized_irls_weights(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional float irls_mixture_fraction_scale = 68 [default = 1.5];
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(68, this->_internal_irls_mixture_fraction_scale(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mediapipe.MotionEstimationOptions)
  return target;
}

size_t MotionEstimationOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mediapipe.MotionEstimationOptions)
  size_t total_size = 0;

  total_size += _extensions_.ByteSize();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .mediapipe.MotionEstimationOptions.HomographyBounds stable_homography_bounds = 11;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *stable_homography_bounds_);
    }

    // optional .mediapipe.MotionEstimationOptions.TranslationBounds stable_translation_bounds = 32;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *stable_translation_bounds_);
    }

    // optional .mediapipe.MotionEstimationOptions.SimilarityBounds stable_similarity_bounds = 33;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *stable_similarity_bounds_);
    }

    // optional .mediapipe.MotionEstimationOptions.MixtureHomographyBounds stable_mixture_homography_bounds = 34;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *stable_mixture_homography_bounds_);
    }

    // optional .mediapipe.MotionEstimationOptions.OverlayDetectionOptions overlay_detection_options = 38;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *overlay_detection_options_);
    }

    // optional .mediapipe.MotionEstimationOptions.IrlsOutlierInitialization irls_initialization = 56;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *irls_initialization_);
    }

    // optional .mediapipe.MotionEstimationOptions.IrlsMaskOptions irls_mask_options = 57;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *irls_mask_options_);
    }

    // optional .mediapipe.MotionEstimationOptions.JointTrackEstimationOptions joint_track_estimation = 59;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *joint_track_estimation_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .mediapipe.MotionEstimationOptions.ShotBoundaryOptions shot_boundary_options = 60;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *shot_boundary_options_);
    }

    // optional .mediapipe.MotionEstimationOptions.LongFeatureBiasOptions long_feature_bias_options = 64;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *long_feature_bias_options_);
    }

    // optional .mediapipe.MotionEstimationOptions.LongFeatureInitialization long_feature_initialization = 66;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *long_feature_initialization_);
    }

    // optional .mediapipe.MotionEstimationOptions.MixtureHomographyEstimation mix_homography_estimation = 12 [default = ESTIMATION_HOMOG_MIX_NONE];
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_mix_homography_estimation());
    }

    // optional bool project_valid_motions_down = 52 [default = false];
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 + 1;
    }

    // optional bool estimate_similarity = 2 [deprecated = true];
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

    // optional .mediapipe.MotionEstimationOptions.AffineEstimation affine_estimation = 30 [default = ESTIMATION_AFFINE_NONE];
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_affine_estimation());
    }

    // optional .mediapipe.MotionEstimationOptions.IRLSWeightFilter irls_weight_filter = 35 [default = IRLS_FILTER_NONE];
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_irls_weight_filter());
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional bool filter_5_taps = 29 [default = false];
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 1;
    }

    // optional bool overlay_detection = 36 [default = false];
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 1;
    }

    // optional bool domain_limited_irls_scaling = 65 [default = false];
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 1;
    }

    // optional bool deactivate_stable_motion_estimation = 47 [default = false];
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 1;
    }

    // optional bool homography_exact_denominator_scaling = 53 [default = false];
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + 1;
    }

    // optional bool irls_weights_preinitialized = 39 [default = false];
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 + 1;
    }

    // optional bool filter_initialized_irls_weights = 67 [default = false];
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + 1;
    }

    // optional bool feature_density_normalization = 62 [default = false];
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional float homography_perspective_regularizer = 61 [default = 0];
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 + 4;
    }

    // optional .mediapipe.MotionEstimationOptions.LinearSimilarityEstimation linear_similarity_estimation = 3 [default = ESTIMATION_LS_IRLS];
    if (cached_has_bits & 0x02000000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_linear_similarity_estimation());
    }

    // optional .mediapipe.MotionEstimationOptions.HomographyEstimation homography_estimation = 5 [default = ESTIMATION_HOMOG_IRLS];
    if (cached_has_bits & 0x04000000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_homography_estimation());
    }

    // optional int32 num_mixtures = 13 [default = 10];
    if (cached_has_bits & 0x08000000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_num_mixtures());
    }

    // optional float mixture_row_sigma = 14 [default = 0.1];
    if (cached_has_bits & 0x10000000u) {
      total_size += 1 + 4;
    }

    // optional float mixture_regularizer = 15 [default = 0.0001];
    if (cached_has_bits & 0x20000000u) {
      total_size += 1 + 4;
    }

    // optional int32 irls_rounds = 17 [default = 10];
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_irls_rounds());
    }

    // optional float lin_sim_inlier_threshold = 20 [default = 0.003];
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 + 4;
    }

  }
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    // optional .mediapipe.MotionEstimationOptions.MixtureModelMode mixture_model_mode = 23 [default = SKEW_ROTATION_MIXTURE];
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_mixture_model_mode());
    }

    // optional float feature_grid_size = 24 [default = 0.05];
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 + 4;
    }

    // optional float spatial_sigma = 25 [default = 0.01];
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 + 4;
    }

    // optional int32 temporal_irls_diameter = 26 [default = 20];
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_temporal_irls_diameter());
    }

    // optional float temporal_sigma = 27 [default = 5];
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 + 4;
    }

    // optional float feature_sigma = 28 [default = 30];
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 + 4;
    }

    // optional bool estimate_translation_irls = 1 [default = true];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool use_exact_homography_estimation = 54 [default = true];
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool use_highest_accuracy_for_normal_equations = 55 [default = true];
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 + 1;
    }

    // optional bool use_only_lin_sim_inliers_for_homography = 6 [default = true];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional float irls_motion_magnitude_fraction = 31 [default = 0.08];
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 + 4;
    }

    // optional int32 overlay_analysis_chunk_size = 37 [default = 8];
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_overlay_analysis_chunk_size());
    }

    // optional bool label_empty_frames_as_valid = 22 [default = true];
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 + 1;
    }

    // optional bool frame_confidence_weighting = 48 [default = true];
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 1;
    }

    // optional bool output_refined_irls_weights = 40 [default = true];
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 1;
    }

    // optional bool irls_use_l0_norm = 46 [default = true];
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional float strict_coverage_scale = 41 [default = 1.333];
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 4;
    }

    // optional float mixture_regularizer_levels = 42 [default = 3];
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 4;
    }

    // optional float mixture_regularizer_base = 43 [default = 2.2];
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 4;
    }

    // optional int32 mixture_rs_analysis_level = 44 [default = 2];
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_mixture_rs_analysis_level());
    }

    // optional .mediapipe.MotionEstimationOptions.HomographyIrlsWeightInitialization homography_irls_weight_initialization = 45 [default = IRLS_WEIGHT_PERIMETER_GAUSSIAN];
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_homography_irls_weight_initialization());
    }

    // optional float reset_confidence_threshold = 49 [default = 0.4];
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 + 4;
    }

    // optional float irls_prior_scale = 50 [default = 0.2];
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + 4;
    }

    // optional int32 coverage_grid_size = 51 [default = 10];
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_coverage_grid_size());
    }

  }
  if (cached_has_bits & 0x07000000u) {
    // optional .mediapipe.MotionEstimationOptions.EstimationPolicy estimation_policy = 58 [default = INDEPENDENT_PARALLEL];
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_estimation_policy());
    }

    // optional int32 feature_mask_size = 63 [default = 10];
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_feature_mask_size());
    }

    // optional float irls_mixture_fraction_scale = 68 [default = 1.5];
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MotionEstimationOptions::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mediapipe.MotionEstimationOptions)
  GOOGLE_DCHECK_NE(&from, this);
  const MotionEstimationOptions* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<MotionEstimationOptions>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mediapipe.MotionEstimationOptions)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mediapipe.MotionEstimationOptions)
    MergeFrom(*source);
  }
}

void MotionEstimationOptions::MergeFrom(const MotionEstimationOptions& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mediapipe.MotionEstimationOptions)
  GOOGLE_DCHECK_NE(&from, this);
  _extensions_.MergeFrom(from._extensions_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_stable_homography_bounds()->::mediapipe::MotionEstimationOptions_HomographyBounds::MergeFrom(from._internal_stable_homography_bounds());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_stable_translation_bounds()->::mediapipe::MotionEstimationOptions_TranslationBounds::MergeFrom(from._internal_stable_translation_bounds());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_stable_similarity_bounds()->::mediapipe::MotionEstimationOptions_SimilarityBounds::MergeFrom(from._internal_stable_similarity_bounds());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_stable_mixture_homography_bounds()->::mediapipe::MotionEstimationOptions_MixtureHomographyBounds::MergeFrom(from._internal_stable_mixture_homography_bounds());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_overlay_detection_options()->::mediapipe::MotionEstimationOptions_OverlayDetectionOptions::MergeFrom(from._internal_overlay_detection_options());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_irls_initialization()->::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization::MergeFrom(from._internal_irls_initialization());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_irls_mask_options()->::mediapipe::MotionEstimationOptions_IrlsMaskOptions::MergeFrom(from._internal_irls_mask_options());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_mutable_joint_track_estimation()->::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions::MergeFrom(from._internal_joint_track_estimation());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _internal_mutable_shot_boundary_options()->::mediapipe::MotionEstimationOptions_ShotBoundaryOptions::MergeFrom(from._internal_shot_boundary_options());
    }
    if (cached_has_bits & 0x00000200u) {
      _internal_mutable_long_feature_bias_options()->::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions::MergeFrom(from._internal_long_feature_bias_options());
    }
    if (cached_has_bits & 0x00000400u) {
      _internal_mutable_long_feature_initialization()->::mediapipe::MotionEstimationOptions_LongFeatureInitialization::MergeFrom(from._internal_long_feature_initialization());
    }
    if (cached_has_bits & 0x00000800u) {
      mix_homography_estimation_ = from.mix_homography_estimation_;
    }
    if (cached_has_bits & 0x00001000u) {
      project_valid_motions_down_ = from.project_valid_motions_down_;
    }
    if (cached_has_bits & 0x00002000u) {
      estimate_similarity_ = from.estimate_similarity_;
    }
    if (cached_has_bits & 0x00004000u) {
      affine_estimation_ = from.affine_estimation_;
    }
    if (cached_has_bits & 0x00008000u) {
      irls_weight_filter_ = from.irls_weight_filter_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      filter_5_taps_ = from.filter_5_taps_;
    }
    if (cached_has_bits & 0x00020000u) {
      overlay_detection_ = from.overlay_detection_;
    }
    if (cached_has_bits & 0x00040000u) {
      domain_limited_irls_scaling_ = from.domain_limited_irls_scaling_;
    }
    if (cached_has_bits & 0x00080000u) {
      deactivate_stable_motion_estimation_ = from.deactivate_stable_motion_estimation_;
    }
    if (cached_has_bits & 0x00100000u) {
      homography_exact_denominator_scaling_ = from.homography_exact_denominator_scaling_;
    }
    if (cached_has_bits & 0x00200000u) {
      irls_weights_preinitialized_ = from.irls_weights_preinitialized_;
    }
    if (cached_has_bits & 0x00400000u) {
      filter_initialized_irls_weights_ = from.filter_initialized_irls_weights_;
    }
    if (cached_has_bits & 0x00800000u) {
      feature_density_normalization_ = from.feature_density_normalization_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      homography_perspective_regularizer_ = from.homography_perspective_regularizer_;
    }
    if (cached_has_bits & 0x02000000u) {
      linear_similarity_estimation_ = from.linear_similarity_estimation_;
    }
    if (cached_has_bits & 0x04000000u) {
      homography_estimation_ = from.homography_estimation_;
    }
    if (cached_has_bits & 0x08000000u) {
      num_mixtures_ = from.num_mixtures_;
    }
    if (cached_has_bits & 0x10000000u) {
      mixture_row_sigma_ = from.mixture_row_sigma_;
    }
    if (cached_has_bits & 0x20000000u) {
      mixture_regularizer_ = from.mixture_regularizer_;
    }
    if (cached_has_bits & 0x40000000u) {
      irls_rounds_ = from.irls_rounds_;
    }
    if (cached_has_bits & 0x80000000u) {
      lin_sim_inlier_threshold_ = from.lin_sim_inlier_threshold_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  cached_has_bits = from._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      mixture_model_mode_ = from.mixture_model_mode_;
    }
    if (cached_has_bits & 0x00000002u) {
      feature_grid_size_ = from.feature_grid_size_;
    }
    if (cached_has_bits & 0x00000004u) {
      spatial_sigma_ = from.spatial_sigma_;
    }
    if (cached_has_bits & 0x00000008u) {
      temporal_irls_diameter_ = from.temporal_irls_diameter_;
    }
    if (cached_has_bits & 0x00000010u) {
      temporal_sigma_ = from.temporal_sigma_;
    }
    if (cached_has_bits & 0x00000020u) {
      feature_sigma_ = from.feature_sigma_;
    }
    if (cached_has_bits & 0x00000040u) {
      estimate_translation_irls_ = from.estimate_translation_irls_;
    }
    if (cached_has_bits & 0x00000080u) {
      use_exact_homography_estimation_ = from.use_exact_homography_estimation_;
    }
    _has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      use_highest_accuracy_for_normal_equations_ = from.use_highest_accuracy_for_normal_equations_;
    }
    if (cached_has_bits & 0x00000200u) {
      use_only_lin_sim_inliers_for_homography_ = from.use_only_lin_sim_inliers_for_homography_;
    }
    if (cached_has_bits & 0x00000400u) {
      irls_motion_magnitude_fraction_ = from.irls_motion_magnitude_fraction_;
    }
    if (cached_has_bits & 0x00000800u) {
      overlay_analysis_chunk_size_ = from.overlay_analysis_chunk_size_;
    }
    if (cached_has_bits & 0x00001000u) {
      label_empty_frames_as_valid_ = from.label_empty_frames_as_valid_;
    }
    if (cached_has_bits & 0x00002000u) {
      frame_confidence_weighting_ = from.frame_confidence_weighting_;
    }
    if (cached_has_bits & 0x00004000u) {
      output_refined_irls_weights_ = from.output_refined_irls_weights_;
    }
    if (cached_has_bits & 0x00008000u) {
      irls_use_l0_norm_ = from.irls_use_l0_norm_;
    }
    _has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      strict_coverage_scale_ = from.strict_coverage_scale_;
    }
    if (cached_has_bits & 0x00020000u) {
      mixture_regularizer_levels_ = from.mixture_regularizer_levels_;
    }
    if (cached_has_bits & 0x00040000u) {
      mixture_regularizer_base_ = from.mixture_regularizer_base_;
    }
    if (cached_has_bits & 0x00080000u) {
      mixture_rs_analysis_level_ = from.mixture_rs_analysis_level_;
    }
    if (cached_has_bits & 0x00100000u) {
      homography_irls_weight_initialization_ = from.homography_irls_weight_initialization_;
    }
    if (cached_has_bits & 0x00200000u) {
      reset_confidence_threshold_ = from.reset_confidence_threshold_;
    }
    if (cached_has_bits & 0x00400000u) {
      irls_prior_scale_ = from.irls_prior_scale_;
    }
    if (cached_has_bits & 0x00800000u) {
      coverage_grid_size_ = from.coverage_grid_size_;
    }
    _has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0x07000000u) {
    if (cached_has_bits & 0x01000000u) {
      estimation_policy_ = from.estimation_policy_;
    }
    if (cached_has_bits & 0x02000000u) {
      feature_mask_size_ = from.feature_mask_size_;
    }
    if (cached_has_bits & 0x04000000u) {
      irls_mixture_fraction_scale_ = from.irls_mixture_fraction_scale_;
    }
    _has_bits_[1] |= cached_has_bits;
  }
}

void MotionEstimationOptions::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mediapipe.MotionEstimationOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MotionEstimationOptions::CopyFrom(const MotionEstimationOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mediapipe.MotionEstimationOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MotionEstimationOptions::IsInitialized() const {
  if (!_extensions_.IsInitialized()) {
    return false;
  }

  if (_internal_has_irls_mask_options()) {
    if (!irls_mask_options_->IsInitialized()) return false;
  }
  return true;
}

void MotionEstimationOptions::InternalSwap(MotionEstimationOptions* other) {
  using std::swap;
  _extensions_.InternalSwap(&other->_extensions_);
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(_has_bits_[1], other->_has_bits_[1]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MotionEstimationOptions, homography_perspective_regularizer_)
      + sizeof(MotionEstimationOptions::homography_perspective_regularizer_)
      - PROTOBUF_FIELD_OFFSET(MotionEstimationOptions, stable_homography_bounds_)>(
          reinterpret_cast<char*>(&stable_homography_bounds_),
          reinterpret_cast<char*>(&other->stable_homography_bounds_));
  swap(linear_similarity_estimation_, other->linear_similarity_estimation_);
  swap(homography_estimation_, other->homography_estimation_);
  swap(num_mixtures_, other->num_mixtures_);
  swap(mixture_row_sigma_, other->mixture_row_sigma_);
  swap(mixture_regularizer_, other->mixture_regularizer_);
  swap(irls_rounds_, other->irls_rounds_);
  swap(lin_sim_inlier_threshold_, other->lin_sim_inlier_threshold_);
  swap(mixture_model_mode_, other->mixture_model_mode_);
  swap(feature_grid_size_, other->feature_grid_size_);
  swap(spatial_sigma_, other->spatial_sigma_);
  swap(temporal_irls_diameter_, other->temporal_irls_diameter_);
  swap(temporal_sigma_, other->temporal_sigma_);
  swap(feature_sigma_, other->feature_sigma_);
  swap(estimate_translation_irls_, other->estimate_translation_irls_);
  swap(use_exact_homography_estimation_, other->use_exact_homography_estimation_);
  swap(use_highest_accuracy_for_normal_equations_, other->use_highest_accuracy_for_normal_equations_);
  swap(use_only_lin_sim_inliers_for_homography_, other->use_only_lin_sim_inliers_for_homography_);
  swap(irls_motion_magnitude_fraction_, other->irls_motion_magnitude_fraction_);
  swap(overlay_analysis_chunk_size_, other->overlay_analysis_chunk_size_);
  swap(label_empty_frames_as_valid_, other->label_empty_frames_as_valid_);
  swap(frame_confidence_weighting_, other->frame_confidence_weighting_);
  swap(output_refined_irls_weights_, other->output_refined_irls_weights_);
  swap(irls_use_l0_norm_, other->irls_use_l0_norm_);
  swap(strict_coverage_scale_, other->strict_coverage_scale_);
  swap(mixture_regularizer_levels_, other->mixture_regularizer_levels_);
  swap(mixture_regularizer_base_, other->mixture_regularizer_base_);
  swap(mixture_rs_analysis_level_, other->mixture_rs_analysis_level_);
  swap(homography_irls_weight_initialization_, other->homography_irls_weight_initialization_);
  swap(reset_confidence_threshold_, other->reset_confidence_threshold_);
  swap(irls_prior_scale_, other->irls_prior_scale_);
  swap(coverage_grid_size_, other->coverage_grid_size_);
  swap(estimation_policy_, other->estimation_policy_);
  swap(feature_mask_size_, other->feature_mask_size_);
  swap(irls_mixture_fraction_scale_, other->irls_mixture_fraction_scale_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MotionEstimationOptions::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto_getter, &descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto_once,
      file_level_metadata_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto[11]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace mediapipe
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization* Arena::CreateMaybeMessage< ::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization >(arena);
}
template<> PROTOBUF_NOINLINE ::mediapipe::MotionEstimationOptions_LongFeatureInitialization* Arena::CreateMaybeMessage< ::mediapipe::MotionEstimationOptions_LongFeatureInitialization >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mediapipe::MotionEstimationOptions_LongFeatureInitialization >(arena);
}
template<> PROTOBUF_NOINLINE ::mediapipe::MotionEstimationOptions_IrlsMaskOptions* Arena::CreateMaybeMessage< ::mediapipe::MotionEstimationOptions_IrlsMaskOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mediapipe::MotionEstimationOptions_IrlsMaskOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions* Arena::CreateMaybeMessage< ::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions* Arena::CreateMaybeMessage< ::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::mediapipe::MotionEstimationOptions_TranslationBounds* Arena::CreateMaybeMessage< ::mediapipe::MotionEstimationOptions_TranslationBounds >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mediapipe::MotionEstimationOptions_TranslationBounds >(arena);
}
template<> PROTOBUF_NOINLINE ::mediapipe::MotionEstimationOptions_SimilarityBounds* Arena::CreateMaybeMessage< ::mediapipe::MotionEstimationOptions_SimilarityBounds >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mediapipe::MotionEstimationOptions_SimilarityBounds >(arena);
}
template<> PROTOBUF_NOINLINE ::mediapipe::MotionEstimationOptions_HomographyBounds* Arena::CreateMaybeMessage< ::mediapipe::MotionEstimationOptions_HomographyBounds >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mediapipe::MotionEstimationOptions_HomographyBounds >(arena);
}
template<> PROTOBUF_NOINLINE ::mediapipe::MotionEstimationOptions_MixtureHomographyBounds* Arena::CreateMaybeMessage< ::mediapipe::MotionEstimationOptions_MixtureHomographyBounds >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mediapipe::MotionEstimationOptions_MixtureHomographyBounds >(arena);
}
template<> PROTOBUF_NOINLINE ::mediapipe::MotionEstimationOptions_OverlayDetectionOptions* Arena::CreateMaybeMessage< ::mediapipe::MotionEstimationOptions_OverlayDetectionOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mediapipe::MotionEstimationOptions_OverlayDetectionOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::mediapipe::MotionEstimationOptions_ShotBoundaryOptions* Arena::CreateMaybeMessage< ::mediapipe::MotionEstimationOptions_ShotBoundaryOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mediapipe::MotionEstimationOptions_ShotBoundaryOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::mediapipe::MotionEstimationOptions* Arena::CreateMaybeMessage< ::mediapipe::MotionEstimationOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::mediapipe::MotionEstimationOptions >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <x/google/protobuf/port_undef.inc>
