// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mediapipe/util/tracking/motion_estimation.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto

#include <limits>
#include <string>

#include <x/google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3015000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3015008 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <x/google/protobuf/port_undef.inc>
#include <x/google/protobuf/io/coded_stream.h>
#include <x/google/protobuf/arena.h>
#include <x/google/protobuf/arenastring.h>
#include <x/google/protobuf/generated_message_table_driven.h>
#include <x/google/protobuf/generated_message_util.h>
#include <x/google/protobuf/metadata_lite.h>
#include <x/google/protobuf/generated_message_reflection.h>
#include <x/google/protobuf/message.h>
#include <x/google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <x/google/protobuf/extension_set.h>  // IWYU pragma: export
#include <x/google/protobuf/generated_enum_reflection.h>
#include <x/google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <x/google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto;
namespace mediapipe {
class MotionEstimationOptions;
struct MotionEstimationOptionsDefaultTypeInternal;
extern MotionEstimationOptionsDefaultTypeInternal _MotionEstimationOptions_default_instance_;
class MotionEstimationOptions_HomographyBounds;
struct MotionEstimationOptions_HomographyBoundsDefaultTypeInternal;
extern MotionEstimationOptions_HomographyBoundsDefaultTypeInternal _MotionEstimationOptions_HomographyBounds_default_instance_;
class MotionEstimationOptions_IrlsMaskOptions;
struct MotionEstimationOptions_IrlsMaskOptionsDefaultTypeInternal;
extern MotionEstimationOptions_IrlsMaskOptionsDefaultTypeInternal _MotionEstimationOptions_IrlsMaskOptions_default_instance_;
class MotionEstimationOptions_IrlsOutlierInitialization;
struct MotionEstimationOptions_IrlsOutlierInitializationDefaultTypeInternal;
extern MotionEstimationOptions_IrlsOutlierInitializationDefaultTypeInternal _MotionEstimationOptions_IrlsOutlierInitialization_default_instance_;
class MotionEstimationOptions_JointTrackEstimationOptions;
struct MotionEstimationOptions_JointTrackEstimationOptionsDefaultTypeInternal;
extern MotionEstimationOptions_JointTrackEstimationOptionsDefaultTypeInternal _MotionEstimationOptions_JointTrackEstimationOptions_default_instance_;
class MotionEstimationOptions_LongFeatureBiasOptions;
struct MotionEstimationOptions_LongFeatureBiasOptionsDefaultTypeInternal;
extern MotionEstimationOptions_LongFeatureBiasOptionsDefaultTypeInternal _MotionEstimationOptions_LongFeatureBiasOptions_default_instance_;
class MotionEstimationOptions_LongFeatureInitialization;
struct MotionEstimationOptions_LongFeatureInitializationDefaultTypeInternal;
extern MotionEstimationOptions_LongFeatureInitializationDefaultTypeInternal _MotionEstimationOptions_LongFeatureInitialization_default_instance_;
class MotionEstimationOptions_MixtureHomographyBounds;
struct MotionEstimationOptions_MixtureHomographyBoundsDefaultTypeInternal;
extern MotionEstimationOptions_MixtureHomographyBoundsDefaultTypeInternal _MotionEstimationOptions_MixtureHomographyBounds_default_instance_;
class MotionEstimationOptions_OverlayDetectionOptions;
struct MotionEstimationOptions_OverlayDetectionOptionsDefaultTypeInternal;
extern MotionEstimationOptions_OverlayDetectionOptionsDefaultTypeInternal _MotionEstimationOptions_OverlayDetectionOptions_default_instance_;
class MotionEstimationOptions_ShotBoundaryOptions;
struct MotionEstimationOptions_ShotBoundaryOptionsDefaultTypeInternal;
extern MotionEstimationOptions_ShotBoundaryOptionsDefaultTypeInternal _MotionEstimationOptions_ShotBoundaryOptions_default_instance_;
class MotionEstimationOptions_SimilarityBounds;
struct MotionEstimationOptions_SimilarityBoundsDefaultTypeInternal;
extern MotionEstimationOptions_SimilarityBoundsDefaultTypeInternal _MotionEstimationOptions_SimilarityBounds_default_instance_;
class MotionEstimationOptions_TranslationBounds;
struct MotionEstimationOptions_TranslationBoundsDefaultTypeInternal;
extern MotionEstimationOptions_TranslationBoundsDefaultTypeInternal _MotionEstimationOptions_TranslationBounds_default_instance_;
}  // namespace mediapipe
PROTOBUF_NAMESPACE_OPEN
template<> ::mediapipe::MotionEstimationOptions* Arena::CreateMaybeMessage<::mediapipe::MotionEstimationOptions>(Arena*);
template<> ::mediapipe::MotionEstimationOptions_HomographyBounds* Arena::CreateMaybeMessage<::mediapipe::MotionEstimationOptions_HomographyBounds>(Arena*);
template<> ::mediapipe::MotionEstimationOptions_IrlsMaskOptions* Arena::CreateMaybeMessage<::mediapipe::MotionEstimationOptions_IrlsMaskOptions>(Arena*);
template<> ::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization* Arena::CreateMaybeMessage<::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization>(Arena*);
template<> ::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions* Arena::CreateMaybeMessage<::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions>(Arena*);
template<> ::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions* Arena::CreateMaybeMessage<::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions>(Arena*);
template<> ::mediapipe::MotionEstimationOptions_LongFeatureInitialization* Arena::CreateMaybeMessage<::mediapipe::MotionEstimationOptions_LongFeatureInitialization>(Arena*);
template<> ::mediapipe::MotionEstimationOptions_MixtureHomographyBounds* Arena::CreateMaybeMessage<::mediapipe::MotionEstimationOptions_MixtureHomographyBounds>(Arena*);
template<> ::mediapipe::MotionEstimationOptions_OverlayDetectionOptions* Arena::CreateMaybeMessage<::mediapipe::MotionEstimationOptions_OverlayDetectionOptions>(Arena*);
template<> ::mediapipe::MotionEstimationOptions_ShotBoundaryOptions* Arena::CreateMaybeMessage<::mediapipe::MotionEstimationOptions_ShotBoundaryOptions>(Arena*);
template<> ::mediapipe::MotionEstimationOptions_SimilarityBounds* Arena::CreateMaybeMessage<::mediapipe::MotionEstimationOptions_SimilarityBounds>(Arena*);
template<> ::mediapipe::MotionEstimationOptions_TranslationBounds* Arena::CreateMaybeMessage<::mediapipe::MotionEstimationOptions_TranslationBounds>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mediapipe {

enum MotionEstimationOptions_LinearSimilarityEstimation : int {
  MotionEstimationOptions_LinearSimilarityEstimation_ESTIMATION_LS_NONE = 0,
  MotionEstimationOptions_LinearSimilarityEstimation_ESTIMATION_LS_L2 = 1,
  MotionEstimationOptions_LinearSimilarityEstimation_ESTIMATION_LS_IRLS = 4,
  MotionEstimationOptions_LinearSimilarityEstimation_ESTIMATION_LS_L2_RANSAC = 2,
  MotionEstimationOptions_LinearSimilarityEstimation_ESTIMATION_LS_L1 = 3
};
bool MotionEstimationOptions_LinearSimilarityEstimation_IsValid(int value);
constexpr MotionEstimationOptions_LinearSimilarityEstimation MotionEstimationOptions_LinearSimilarityEstimation_LinearSimilarityEstimation_MIN = MotionEstimationOptions_LinearSimilarityEstimation_ESTIMATION_LS_NONE;
constexpr MotionEstimationOptions_LinearSimilarityEstimation MotionEstimationOptions_LinearSimilarityEstimation_LinearSimilarityEstimation_MAX = MotionEstimationOptions_LinearSimilarityEstimation_ESTIMATION_LS_IRLS;
constexpr int MotionEstimationOptions_LinearSimilarityEstimation_LinearSimilarityEstimation_ARRAYSIZE = MotionEstimationOptions_LinearSimilarityEstimation_LinearSimilarityEstimation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MotionEstimationOptions_LinearSimilarityEstimation_descriptor();
template<typename T>
inline const std::string& MotionEstimationOptions_LinearSimilarityEstimation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MotionEstimationOptions_LinearSimilarityEstimation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MotionEstimationOptions_LinearSimilarityEstimation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MotionEstimationOptions_LinearSimilarityEstimation_descriptor(), enum_t_value);
}
inline bool MotionEstimationOptions_LinearSimilarityEstimation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MotionEstimationOptions_LinearSimilarityEstimation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MotionEstimationOptions_LinearSimilarityEstimation>(
    MotionEstimationOptions_LinearSimilarityEstimation_descriptor(), name, value);
}
enum MotionEstimationOptions_AffineEstimation : int {
  MotionEstimationOptions_AffineEstimation_ESTIMATION_AFFINE_NONE = 0,
  MotionEstimationOptions_AffineEstimation_ESTIMATION_AFFINE_L2 = 1,
  MotionEstimationOptions_AffineEstimation_ESTIMATION_AFFINE_IRLS = 2
};
bool MotionEstimationOptions_AffineEstimation_IsValid(int value);
constexpr MotionEstimationOptions_AffineEstimation MotionEstimationOptions_AffineEstimation_AffineEstimation_MIN = MotionEstimationOptions_AffineEstimation_ESTIMATION_AFFINE_NONE;
constexpr MotionEstimationOptions_AffineEstimation MotionEstimationOptions_AffineEstimation_AffineEstimation_MAX = MotionEstimationOptions_AffineEstimation_ESTIMATION_AFFINE_IRLS;
constexpr int MotionEstimationOptions_AffineEstimation_AffineEstimation_ARRAYSIZE = MotionEstimationOptions_AffineEstimation_AffineEstimation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MotionEstimationOptions_AffineEstimation_descriptor();
template<typename T>
inline const std::string& MotionEstimationOptions_AffineEstimation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MotionEstimationOptions_AffineEstimation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MotionEstimationOptions_AffineEstimation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MotionEstimationOptions_AffineEstimation_descriptor(), enum_t_value);
}
inline bool MotionEstimationOptions_AffineEstimation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MotionEstimationOptions_AffineEstimation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MotionEstimationOptions_AffineEstimation>(
    MotionEstimationOptions_AffineEstimation_descriptor(), name, value);
}
enum MotionEstimationOptions_HomographyEstimation : int {
  MotionEstimationOptions_HomographyEstimation_ESTIMATION_HOMOG_NONE = 0,
  MotionEstimationOptions_HomographyEstimation_ESTIMATION_HOMOG_L2 = 1,
  MotionEstimationOptions_HomographyEstimation_ESTIMATION_HOMOG_IRLS = 2
};
bool MotionEstimationOptions_HomographyEstimation_IsValid(int value);
constexpr MotionEstimationOptions_HomographyEstimation MotionEstimationOptions_HomographyEstimation_HomographyEstimation_MIN = MotionEstimationOptions_HomographyEstimation_ESTIMATION_HOMOG_NONE;
constexpr MotionEstimationOptions_HomographyEstimation MotionEstimationOptions_HomographyEstimation_HomographyEstimation_MAX = MotionEstimationOptions_HomographyEstimation_ESTIMATION_HOMOG_IRLS;
constexpr int MotionEstimationOptions_HomographyEstimation_HomographyEstimation_ARRAYSIZE = MotionEstimationOptions_HomographyEstimation_HomographyEstimation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MotionEstimationOptions_HomographyEstimation_descriptor();
template<typename T>
inline const std::string& MotionEstimationOptions_HomographyEstimation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MotionEstimationOptions_HomographyEstimation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MotionEstimationOptions_HomographyEstimation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MotionEstimationOptions_HomographyEstimation_descriptor(), enum_t_value);
}
inline bool MotionEstimationOptions_HomographyEstimation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MotionEstimationOptions_HomographyEstimation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MotionEstimationOptions_HomographyEstimation>(
    MotionEstimationOptions_HomographyEstimation_descriptor(), name, value);
}
enum MotionEstimationOptions_MixtureHomographyEstimation : int {
  MotionEstimationOptions_MixtureHomographyEstimation_ESTIMATION_HOMOG_MIX_NONE = 0,
  MotionEstimationOptions_MixtureHomographyEstimation_ESTIMATION_HOMOG_MIX_L2 = 1,
  MotionEstimationOptions_MixtureHomographyEstimation_ESTIMATION_HOMOG_MIX_IRLS = 2
};
bool MotionEstimationOptions_MixtureHomographyEstimation_IsValid(int value);
constexpr MotionEstimationOptions_MixtureHomographyEstimation MotionEstimationOptions_MixtureHomographyEstimation_MixtureHomographyEstimation_MIN = MotionEstimationOptions_MixtureHomographyEstimation_ESTIMATION_HOMOG_MIX_NONE;
constexpr MotionEstimationOptions_MixtureHomographyEstimation MotionEstimationOptions_MixtureHomographyEstimation_MixtureHomographyEstimation_MAX = MotionEstimationOptions_MixtureHomographyEstimation_ESTIMATION_HOMOG_MIX_IRLS;
constexpr int MotionEstimationOptions_MixtureHomographyEstimation_MixtureHomographyEstimation_ARRAYSIZE = MotionEstimationOptions_MixtureHomographyEstimation_MixtureHomographyEstimation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MotionEstimationOptions_MixtureHomographyEstimation_descriptor();
template<typename T>
inline const std::string& MotionEstimationOptions_MixtureHomographyEstimation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MotionEstimationOptions_MixtureHomographyEstimation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MotionEstimationOptions_MixtureHomographyEstimation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MotionEstimationOptions_MixtureHomographyEstimation_descriptor(), enum_t_value);
}
inline bool MotionEstimationOptions_MixtureHomographyEstimation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MotionEstimationOptions_MixtureHomographyEstimation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MotionEstimationOptions_MixtureHomographyEstimation>(
    MotionEstimationOptions_MixtureHomographyEstimation_descriptor(), name, value);
}
enum MotionEstimationOptions_EstimationPolicy : int {
  MotionEstimationOptions_EstimationPolicy_INDEPENDENT_PARALLEL = 1,
  MotionEstimationOptions_EstimationPolicy_TEMPORAL_IRLS_MASK = 2,
  MotionEstimationOptions_EstimationPolicy_TEMPORAL_LONG_FEATURE_BIAS = 4,
  MotionEstimationOptions_EstimationPolicy_JOINTLY_FROM_TRACKS = 3
};
bool MotionEstimationOptions_EstimationPolicy_IsValid(int value);
constexpr MotionEstimationOptions_EstimationPolicy MotionEstimationOptions_EstimationPolicy_EstimationPolicy_MIN = MotionEstimationOptions_EstimationPolicy_INDEPENDENT_PARALLEL;
constexpr MotionEstimationOptions_EstimationPolicy MotionEstimationOptions_EstimationPolicy_EstimationPolicy_MAX = MotionEstimationOptions_EstimationPolicy_TEMPORAL_LONG_FEATURE_BIAS;
constexpr int MotionEstimationOptions_EstimationPolicy_EstimationPolicy_ARRAYSIZE = MotionEstimationOptions_EstimationPolicy_EstimationPolicy_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MotionEstimationOptions_EstimationPolicy_descriptor();
template<typename T>
inline const std::string& MotionEstimationOptions_EstimationPolicy_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MotionEstimationOptions_EstimationPolicy>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MotionEstimationOptions_EstimationPolicy_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MotionEstimationOptions_EstimationPolicy_descriptor(), enum_t_value);
}
inline bool MotionEstimationOptions_EstimationPolicy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MotionEstimationOptions_EstimationPolicy* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MotionEstimationOptions_EstimationPolicy>(
    MotionEstimationOptions_EstimationPolicy_descriptor(), name, value);
}
enum MotionEstimationOptions_MixtureModelMode : int {
  MotionEstimationOptions_MixtureModelMode_FULL_MIXTURE = 0,
  MotionEstimationOptions_MixtureModelMode_TRANSLATION_MIXTURE = 1,
  MotionEstimationOptions_MixtureModelMode_SKEW_ROTATION_MIXTURE = 2
};
bool MotionEstimationOptions_MixtureModelMode_IsValid(int value);
constexpr MotionEstimationOptions_MixtureModelMode MotionEstimationOptions_MixtureModelMode_MixtureModelMode_MIN = MotionEstimationOptions_MixtureModelMode_FULL_MIXTURE;
constexpr MotionEstimationOptions_MixtureModelMode MotionEstimationOptions_MixtureModelMode_MixtureModelMode_MAX = MotionEstimationOptions_MixtureModelMode_SKEW_ROTATION_MIXTURE;
constexpr int MotionEstimationOptions_MixtureModelMode_MixtureModelMode_ARRAYSIZE = MotionEstimationOptions_MixtureModelMode_MixtureModelMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MotionEstimationOptions_MixtureModelMode_descriptor();
template<typename T>
inline const std::string& MotionEstimationOptions_MixtureModelMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MotionEstimationOptions_MixtureModelMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MotionEstimationOptions_MixtureModelMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MotionEstimationOptions_MixtureModelMode_descriptor(), enum_t_value);
}
inline bool MotionEstimationOptions_MixtureModelMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MotionEstimationOptions_MixtureModelMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MotionEstimationOptions_MixtureModelMode>(
    MotionEstimationOptions_MixtureModelMode_descriptor(), name, value);
}
enum MotionEstimationOptions_IRLSWeightFilter : int {
  MotionEstimationOptions_IRLSWeightFilter_IRLS_FILTER_NONE = 0,
  MotionEstimationOptions_IRLSWeightFilter_IRLS_FILTER_TEXTURE = 1,
  MotionEstimationOptions_IRLSWeightFilter_IRLS_FILTER_CORNER_RESPONSE = 2
};
bool MotionEstimationOptions_IRLSWeightFilter_IsValid(int value);
constexpr MotionEstimationOptions_IRLSWeightFilter MotionEstimationOptions_IRLSWeightFilter_IRLSWeightFilter_MIN = MotionEstimationOptions_IRLSWeightFilter_IRLS_FILTER_NONE;
constexpr MotionEstimationOptions_IRLSWeightFilter MotionEstimationOptions_IRLSWeightFilter_IRLSWeightFilter_MAX = MotionEstimationOptions_IRLSWeightFilter_IRLS_FILTER_CORNER_RESPONSE;
constexpr int MotionEstimationOptions_IRLSWeightFilter_IRLSWeightFilter_ARRAYSIZE = MotionEstimationOptions_IRLSWeightFilter_IRLSWeightFilter_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MotionEstimationOptions_IRLSWeightFilter_descriptor();
template<typename T>
inline const std::string& MotionEstimationOptions_IRLSWeightFilter_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MotionEstimationOptions_IRLSWeightFilter>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MotionEstimationOptions_IRLSWeightFilter_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MotionEstimationOptions_IRLSWeightFilter_descriptor(), enum_t_value);
}
inline bool MotionEstimationOptions_IRLSWeightFilter_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MotionEstimationOptions_IRLSWeightFilter* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MotionEstimationOptions_IRLSWeightFilter>(
    MotionEstimationOptions_IRLSWeightFilter_descriptor(), name, value);
}
enum MotionEstimationOptions_HomographyIrlsWeightInitialization : int {
  MotionEstimationOptions_HomographyIrlsWeightInitialization_IRLS_WEIGHT_CONSTANT_ONE = 1,
  MotionEstimationOptions_HomographyIrlsWeightInitialization_IRLS_WEIGHT_CENTER_GAUSSIAN = 2,
  MotionEstimationOptions_HomographyIrlsWeightInitialization_IRLS_WEIGHT_PERIMETER_GAUSSIAN = 3
};
bool MotionEstimationOptions_HomographyIrlsWeightInitialization_IsValid(int value);
constexpr MotionEstimationOptions_HomographyIrlsWeightInitialization MotionEstimationOptions_HomographyIrlsWeightInitialization_HomographyIrlsWeightInitialization_MIN = MotionEstimationOptions_HomographyIrlsWeightInitialization_IRLS_WEIGHT_CONSTANT_ONE;
constexpr MotionEstimationOptions_HomographyIrlsWeightInitialization MotionEstimationOptions_HomographyIrlsWeightInitialization_HomographyIrlsWeightInitialization_MAX = MotionEstimationOptions_HomographyIrlsWeightInitialization_IRLS_WEIGHT_PERIMETER_GAUSSIAN;
constexpr int MotionEstimationOptions_HomographyIrlsWeightInitialization_HomographyIrlsWeightInitialization_ARRAYSIZE = MotionEstimationOptions_HomographyIrlsWeightInitialization_HomographyIrlsWeightInitialization_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MotionEstimationOptions_HomographyIrlsWeightInitialization_descriptor();
template<typename T>
inline const std::string& MotionEstimationOptions_HomographyIrlsWeightInitialization_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MotionEstimationOptions_HomographyIrlsWeightInitialization>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MotionEstimationOptions_HomographyIrlsWeightInitialization_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MotionEstimationOptions_HomographyIrlsWeightInitialization_descriptor(), enum_t_value);
}
inline bool MotionEstimationOptions_HomographyIrlsWeightInitialization_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MotionEstimationOptions_HomographyIrlsWeightInitialization* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MotionEstimationOptions_HomographyIrlsWeightInitialization>(
    MotionEstimationOptions_HomographyIrlsWeightInitialization_descriptor(), name, value);
}
// ===================================================================

class MotionEstimationOptions_IrlsOutlierInitialization PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.MotionEstimationOptions.IrlsOutlierInitialization) */ {
 public:
  inline MotionEstimationOptions_IrlsOutlierInitialization() : MotionEstimationOptions_IrlsOutlierInitialization(nullptr) {}
  ~MotionEstimationOptions_IrlsOutlierInitialization() override;
  explicit constexpr MotionEstimationOptions_IrlsOutlierInitialization(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MotionEstimationOptions_IrlsOutlierInitialization(const MotionEstimationOptions_IrlsOutlierInitialization& from);
  MotionEstimationOptions_IrlsOutlierInitialization(MotionEstimationOptions_IrlsOutlierInitialization&& from) noexcept
    : MotionEstimationOptions_IrlsOutlierInitialization() {
    *this = ::std::move(from);
  }

  inline MotionEstimationOptions_IrlsOutlierInitialization& operator=(const MotionEstimationOptions_IrlsOutlierInitialization& from) {
    CopyFrom(from);
    return *this;
  }
  inline MotionEstimationOptions_IrlsOutlierInitialization& operator=(MotionEstimationOptions_IrlsOutlierInitialization&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MotionEstimationOptions_IrlsOutlierInitialization& default_instance() {
    return *internal_default_instance();
  }
  static inline const MotionEstimationOptions_IrlsOutlierInitialization* internal_default_instance() {
    return reinterpret_cast<const MotionEstimationOptions_IrlsOutlierInitialization*>(
               &_MotionEstimationOptions_IrlsOutlierInitialization_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MotionEstimationOptions_IrlsOutlierInitialization& a, MotionEstimationOptions_IrlsOutlierInitialization& b) {
    a.Swap(&b);
  }
  inline void Swap(MotionEstimationOptions_IrlsOutlierInitialization* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MotionEstimationOptions_IrlsOutlierInitialization* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MotionEstimationOptions_IrlsOutlierInitialization* New() const final {
    return CreateMaybeMessage<MotionEstimationOptions_IrlsOutlierInitialization>(nullptr);
  }

  MotionEstimationOptions_IrlsOutlierInitialization* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MotionEstimationOptions_IrlsOutlierInitialization>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MotionEstimationOptions_IrlsOutlierInitialization& from);
  void MergeFrom(const MotionEstimationOptions_IrlsOutlierInitialization& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotionEstimationOptions_IrlsOutlierInitialization* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.MotionEstimationOptions.IrlsOutlierInitialization";
  }
  protected:
  explicit MotionEstimationOptions_IrlsOutlierInitialization(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActivatedFieldNumber = 1,
    kRoundsFieldNumber = 2,
    kCutoffFieldNumber = 3,
  };
  // optional bool activated = 1 [default = false];
  bool has_activated() const;
  private:
  bool _internal_has_activated() const;
  public:
  void clear_activated();
  bool activated() const;
  void set_activated(bool value);
  private:
  bool _internal_activated() const;
  void _internal_set_activated(bool value);
  public:

  // optional int32 rounds = 2 [default = 100];
  bool has_rounds() const;
  private:
  bool _internal_has_rounds() const;
  public:
  void clear_rounds();
  ::PROTOBUF_NAMESPACE_ID::int32 rounds() const;
  void set_rounds(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rounds() const;
  void _internal_set_rounds(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional float cutoff = 3 [default = 0.003];
  bool has_cutoff() const;
  private:
  bool _internal_has_cutoff() const;
  public:
  void clear_cutoff();
  float cutoff() const;
  void set_cutoff(float value);
  private:
  float _internal_cutoff() const;
  void _internal_set_cutoff(float value);
  public:

  // @@protoc_insertion_point(class_scope:mediapipe.MotionEstimationOptions.IrlsOutlierInitialization)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool activated_;
  ::PROTOBUF_NAMESPACE_ID::int32 rounds_;
  float cutoff_;
  friend struct ::TableStruct_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto;
};
// -------------------------------------------------------------------

class MotionEstimationOptions_LongFeatureInitialization PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.MotionEstimationOptions.LongFeatureInitialization) */ {
 public:
  inline MotionEstimationOptions_LongFeatureInitialization() : MotionEstimationOptions_LongFeatureInitialization(nullptr) {}
  ~MotionEstimationOptions_LongFeatureInitialization() override;
  explicit constexpr MotionEstimationOptions_LongFeatureInitialization(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MotionEstimationOptions_LongFeatureInitialization(const MotionEstimationOptions_LongFeatureInitialization& from);
  MotionEstimationOptions_LongFeatureInitialization(MotionEstimationOptions_LongFeatureInitialization&& from) noexcept
    : MotionEstimationOptions_LongFeatureInitialization() {
    *this = ::std::move(from);
  }

  inline MotionEstimationOptions_LongFeatureInitialization& operator=(const MotionEstimationOptions_LongFeatureInitialization& from) {
    CopyFrom(from);
    return *this;
  }
  inline MotionEstimationOptions_LongFeatureInitialization& operator=(MotionEstimationOptions_LongFeatureInitialization&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MotionEstimationOptions_LongFeatureInitialization& default_instance() {
    return *internal_default_instance();
  }
  static inline const MotionEstimationOptions_LongFeatureInitialization* internal_default_instance() {
    return reinterpret_cast<const MotionEstimationOptions_LongFeatureInitialization*>(
               &_MotionEstimationOptions_LongFeatureInitialization_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MotionEstimationOptions_LongFeatureInitialization& a, MotionEstimationOptions_LongFeatureInitialization& b) {
    a.Swap(&b);
  }
  inline void Swap(MotionEstimationOptions_LongFeatureInitialization* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MotionEstimationOptions_LongFeatureInitialization* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MotionEstimationOptions_LongFeatureInitialization* New() const final {
    return CreateMaybeMessage<MotionEstimationOptions_LongFeatureInitialization>(nullptr);
  }

  MotionEstimationOptions_LongFeatureInitialization* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MotionEstimationOptions_LongFeatureInitialization>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MotionEstimationOptions_LongFeatureInitialization& from);
  void MergeFrom(const MotionEstimationOptions_LongFeatureInitialization& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotionEstimationOptions_LongFeatureInitialization* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.MotionEstimationOptions.LongFeatureInitialization";
  }
  protected:
  explicit MotionEstimationOptions_LongFeatureInitialization(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActivatedFieldNumber = 1,
    kMinLengthPercentileFieldNumber = 2,
    kUpweightMultiplierFieldNumber = 3,
  };
  // optional bool activated = 1 [default = false];
  bool has_activated() const;
  private:
  bool _internal_has_activated() const;
  public:
  void clear_activated();
  bool activated() const;
  void set_activated(bool value);
  private:
  bool _internal_activated() const;
  void _internal_set_activated(bool value);
  public:

  // optional float min_length_percentile = 2 [default = 0.95];
  bool has_min_length_percentile() const;
  private:
  bool _internal_has_min_length_percentile() const;
  public:
  void clear_min_length_percentile();
  float min_length_percentile() const;
  void set_min_length_percentile(float value);
  private:
  float _internal_min_length_percentile() const;
  void _internal_set_min_length_percentile(float value);
  public:

  // optional float upweight_multiplier = 3 [default = 5];
  bool has_upweight_multiplier() const;
  private:
  bool _internal_has_upweight_multiplier() const;
  public:
  void clear_upweight_multiplier();
  float upweight_multiplier() const;
  void set_upweight_multiplier(float value);
  private:
  float _internal_upweight_multiplier() const;
  void _internal_set_upweight_multiplier(float value);
  public:

  // @@protoc_insertion_point(class_scope:mediapipe.MotionEstimationOptions.LongFeatureInitialization)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool activated_;
  float min_length_percentile_;
  float upweight_multiplier_;
  friend struct ::TableStruct_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto;
};
// -------------------------------------------------------------------

class MotionEstimationOptions_IrlsMaskOptions PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.MotionEstimationOptions.IrlsMaskOptions) */ {
 public:
  inline MotionEstimationOptions_IrlsMaskOptions() : MotionEstimationOptions_IrlsMaskOptions(nullptr) {}
  ~MotionEstimationOptions_IrlsMaskOptions() override;
  explicit constexpr MotionEstimationOptions_IrlsMaskOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MotionEstimationOptions_IrlsMaskOptions(const MotionEstimationOptions_IrlsMaskOptions& from);
  MotionEstimationOptions_IrlsMaskOptions(MotionEstimationOptions_IrlsMaskOptions&& from) noexcept
    : MotionEstimationOptions_IrlsMaskOptions() {
    *this = ::std::move(from);
  }

  inline MotionEstimationOptions_IrlsMaskOptions& operator=(const MotionEstimationOptions_IrlsMaskOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline MotionEstimationOptions_IrlsMaskOptions& operator=(MotionEstimationOptions_IrlsMaskOptions&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MotionEstimationOptions_IrlsMaskOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const MotionEstimationOptions_IrlsMaskOptions* internal_default_instance() {
    return reinterpret_cast<const MotionEstimationOptions_IrlsMaskOptions*>(
               &_MotionEstimationOptions_IrlsMaskOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MotionEstimationOptions_IrlsMaskOptions& a, MotionEstimationOptions_IrlsMaskOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(MotionEstimationOptions_IrlsMaskOptions* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MotionEstimationOptions_IrlsMaskOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MotionEstimationOptions_IrlsMaskOptions* New() const final {
    return CreateMaybeMessage<MotionEstimationOptions_IrlsMaskOptions>(nullptr);
  }

  MotionEstimationOptions_IrlsMaskOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MotionEstimationOptions_IrlsMaskOptions>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MotionEstimationOptions_IrlsMaskOptions& from);
  void MergeFrom(const MotionEstimationOptions_IrlsMaskOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotionEstimationOptions_IrlsMaskOptions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.MotionEstimationOptions.IrlsMaskOptions";
  }
  protected:
  explicit MotionEstimationOptions_IrlsMaskOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDecayFieldNumber = 2,
    kInlierScoreFieldNumber = 3,
    kBaseScoreFieldNumber = 4,
    kMinTranslationNormFieldNumber = 5,
    kTranslationBlendAlphaFieldNumber = 6,
    kTranslationPriorIncreaseFieldNumber = 7,
  };
  // optional float decay = 2 [default = 0.7];
  bool has_decay() const;
  private:
  bool _internal_has_decay() const;
  public:
  void clear_decay();
  float decay() const;
  void set_decay(float value);
  private:
  float _internal_decay() const;
  void _internal_set_decay(float value);
  public:

  // optional float inlier_score = 3 [default = 0.4];
  bool has_inlier_score() const;
  private:
  bool _internal_has_inlier_score() const;
  public:
  void clear_inlier_score();
  float inlier_score() const;
  void set_inlier_score(float value);
  private:
  float _internal_inlier_score() const;
  void _internal_set_inlier_score(float value);
  public:

  // optional float base_score = 4 [default = 0.2];
  bool has_base_score() const;
  private:
  bool _internal_has_base_score() const;
  public:
  void clear_base_score();
  float base_score() const;
  void set_base_score(float value);
  private:
  float _internal_base_score() const;
  void _internal_set_base_score(float value);
  public:

  // optional float min_translation_norm = 5 [default = 0.002];
  bool has_min_translation_norm() const;
  private:
  bool _internal_has_min_translation_norm() const;
  public:
  void clear_min_translation_norm();
  float min_translation_norm() const;
  void set_min_translation_norm(float value);
  private:
  float _internal_min_translation_norm() const;
  void _internal_set_min_translation_norm(float value);
  public:

  // optional float translation_blend_alpha = 6 [default = 0.7];
  bool has_translation_blend_alpha() const;
  private:
  bool _internal_has_translation_blend_alpha() const;
  public:
  void clear_translation_blend_alpha();
  float translation_blend_alpha() const;
  void set_translation_blend_alpha(float value);
  private:
  float _internal_translation_blend_alpha() const;
  void _internal_set_translation_blend_alpha(float value);
  public:

  // optional float translation_prior_increase = 7 [default = 0.2];
  bool has_translation_prior_increase() const;
  private:
  bool _internal_has_translation_prior_increase() const;
  public:
  void clear_translation_prior_increase();
  float translation_prior_increase() const;
  void set_translation_prior_increase(float value);
  private:
  float _internal_translation_prior_increase() const;
  void _internal_set_translation_prior_increase(float value);
  public:

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(MotionEstimationOptions_IrlsMaskOptions)
  // @@protoc_insertion_point(class_scope:mediapipe.MotionEstimationOptions.IrlsMaskOptions)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float decay_;
  float inlier_score_;
  float base_score_;
  float min_translation_norm_;
  float translation_blend_alpha_;
  float translation_prior_increase_;
  friend struct ::TableStruct_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto;
};
// -------------------------------------------------------------------

class MotionEstimationOptions_JointTrackEstimationOptions PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.MotionEstimationOptions.JointTrackEstimationOptions) */ {
 public:
  inline MotionEstimationOptions_JointTrackEstimationOptions() : MotionEstimationOptions_JointTrackEstimationOptions(nullptr) {}
  ~MotionEstimationOptions_JointTrackEstimationOptions() override;
  explicit constexpr MotionEstimationOptions_JointTrackEstimationOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MotionEstimationOptions_JointTrackEstimationOptions(const MotionEstimationOptions_JointTrackEstimationOptions& from);
  MotionEstimationOptions_JointTrackEstimationOptions(MotionEstimationOptions_JointTrackEstimationOptions&& from) noexcept
    : MotionEstimationOptions_JointTrackEstimationOptions() {
    *this = ::std::move(from);
  }

  inline MotionEstimationOptions_JointTrackEstimationOptions& operator=(const MotionEstimationOptions_JointTrackEstimationOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline MotionEstimationOptions_JointTrackEstimationOptions& operator=(MotionEstimationOptions_JointTrackEstimationOptions&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MotionEstimationOptions_JointTrackEstimationOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const MotionEstimationOptions_JointTrackEstimationOptions* internal_default_instance() {
    return reinterpret_cast<const MotionEstimationOptions_JointTrackEstimationOptions*>(
               &_MotionEstimationOptions_JointTrackEstimationOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MotionEstimationOptions_JointTrackEstimationOptions& a, MotionEstimationOptions_JointTrackEstimationOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(MotionEstimationOptions_JointTrackEstimationOptions* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MotionEstimationOptions_JointTrackEstimationOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MotionEstimationOptions_JointTrackEstimationOptions* New() const final {
    return CreateMaybeMessage<MotionEstimationOptions_JointTrackEstimationOptions>(nullptr);
  }

  MotionEstimationOptions_JointTrackEstimationOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MotionEstimationOptions_JointTrackEstimationOptions>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MotionEstimationOptions_JointTrackEstimationOptions& from);
  void MergeFrom(const MotionEstimationOptions_JointTrackEstimationOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotionEstimationOptions_JointTrackEstimationOptions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.MotionEstimationOptions.JointTrackEstimationOptions";
  }
  protected:
  explicit MotionEstimationOptions_JointTrackEstimationOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTemporalSmoothingFieldNumber = 3,
    kNumMotionModelsFieldNumber = 1,
    kMotionStrideFieldNumber = 2,
  };
  // optional bool temporal_smoothing = 3 [default = false];
  bool has_temporal_smoothing() const;
  private:
  bool _internal_has_temporal_smoothing() const;
  public:
  void clear_temporal_smoothing();
  bool temporal_smoothing() const;
  void set_temporal_smoothing(bool value);
  private:
  bool _internal_temporal_smoothing() const;
  void _internal_set_temporal_smoothing(bool value);
  public:

  // optional int32 num_motion_models = 1 [default = 3];
  bool has_num_motion_models() const;
  private:
  bool _internal_has_num_motion_models() const;
  public:
  void clear_num_motion_models();
  ::PROTOBUF_NAMESPACE_ID::int32 num_motion_models() const;
  void set_num_motion_models(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_motion_models() const;
  void _internal_set_num_motion_models(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 motion_stride = 2 [default = 15];
  bool has_motion_stride() const;
  private:
  bool _internal_has_motion_stride() const;
  public:
  void clear_motion_stride();
  ::PROTOBUF_NAMESPACE_ID::int32 motion_stride() const;
  void set_motion_stride(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_motion_stride() const;
  void _internal_set_motion_stride(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:mediapipe.MotionEstimationOptions.JointTrackEstimationOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool temporal_smoothing_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_motion_models_;
  ::PROTOBUF_NAMESPACE_ID::int32 motion_stride_;
  friend struct ::TableStruct_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto;
};
// -------------------------------------------------------------------

class MotionEstimationOptions_LongFeatureBiasOptions PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions) */ {
 public:
  inline MotionEstimationOptions_LongFeatureBiasOptions() : MotionEstimationOptions_LongFeatureBiasOptions(nullptr) {}
  ~MotionEstimationOptions_LongFeatureBiasOptions() override;
  explicit constexpr MotionEstimationOptions_LongFeatureBiasOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MotionEstimationOptions_LongFeatureBiasOptions(const MotionEstimationOptions_LongFeatureBiasOptions& from);
  MotionEstimationOptions_LongFeatureBiasOptions(MotionEstimationOptions_LongFeatureBiasOptions&& from) noexcept
    : MotionEstimationOptions_LongFeatureBiasOptions() {
    *this = ::std::move(from);
  }

  inline MotionEstimationOptions_LongFeatureBiasOptions& operator=(const MotionEstimationOptions_LongFeatureBiasOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline MotionEstimationOptions_LongFeatureBiasOptions& operator=(MotionEstimationOptions_LongFeatureBiasOptions&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MotionEstimationOptions_LongFeatureBiasOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const MotionEstimationOptions_LongFeatureBiasOptions* internal_default_instance() {
    return reinterpret_cast<const MotionEstimationOptions_LongFeatureBiasOptions*>(
               &_MotionEstimationOptions_LongFeatureBiasOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MotionEstimationOptions_LongFeatureBiasOptions& a, MotionEstimationOptions_LongFeatureBiasOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(MotionEstimationOptions_LongFeatureBiasOptions* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MotionEstimationOptions_LongFeatureBiasOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MotionEstimationOptions_LongFeatureBiasOptions* New() const final {
    return CreateMaybeMessage<MotionEstimationOptions_LongFeatureBiasOptions>(nullptr);
  }

  MotionEstimationOptions_LongFeatureBiasOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MotionEstimationOptions_LongFeatureBiasOptions>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MotionEstimationOptions_LongFeatureBiasOptions& from);
  void MergeFrom(const MotionEstimationOptions_LongFeatureBiasOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotionEstimationOptions_LongFeatureBiasOptions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.MotionEstimationOptions.LongFeatureBiasOptions";
  }
  protected:
  explicit MotionEstimationOptions_LongFeatureBiasOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeedPriorsFromBiasFieldNumber = 14,
    kTotalRoundsFieldNumber = 13,
    kInlierBiasFieldNumber = 1,
    kOutlierBiasFieldNumber = 2,
    kNumIrlsObservationsFieldNumber = 3,
    kMaxIrlsChangeRatioFieldNumber = 4,
    kInlierIrlsWeightFieldNumber = 5,
    kUseSpatialBiasFieldNumber = 6,
    kGridSizeFieldNumber = 7,
    kSpatialSigmaFieldNumber = 8,
    kColorSigmaFieldNumber = 9,
    kLongTrackThresholdFieldNumber = 10,
    kLongTrackConfidenceFractionFieldNumber = 11,
    kBiasStdevFieldNumber = 12,
  };
  // optional bool seed_priors_from_bias = 14 [default = false];
  bool has_seed_priors_from_bias() const;
  private:
  bool _internal_has_seed_priors_from_bias() const;
  public:
  void clear_seed_priors_from_bias();
  bool seed_priors_from_bias() const;
  void set_seed_priors_from_bias(bool value);
  private:
  bool _internal_seed_priors_from_bias() const;
  void _internal_set_seed_priors_from_bias(bool value);
  public:

  // optional int32 total_rounds = 13 [default = 1];
  bool has_total_rounds() const;
  private:
  bool _internal_has_total_rounds() const;
  public:
  void clear_total_rounds();
  ::PROTOBUF_NAMESPACE_ID::int32 total_rounds() const;
  void set_total_rounds(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_total_rounds() const;
  void _internal_set_total_rounds(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional float inlier_bias = 1 [default = 0.98];
  bool has_inlier_bias() const;
  private:
  bool _internal_has_inlier_bias() const;
  public:
  void clear_inlier_bias();
  float inlier_bias() const;
  void set_inlier_bias(float value);
  private:
  float _internal_inlier_bias() const;
  void _internal_set_inlier_bias(float value);
  public:

  // optional float outlier_bias = 2 [default = 0.7];
  bool has_outlier_bias() const;
  private:
  bool _internal_has_outlier_bias() const;
  public:
  void clear_outlier_bias();
  float outlier_bias() const;
  void set_outlier_bias(float value);
  private:
  float _internal_outlier_bias() const;
  void _internal_set_outlier_bias(float value);
  public:

  // optional int32 num_irls_observations = 3 [default = 10];
  bool has_num_irls_observations() const;
  private:
  bool _internal_has_num_irls_observations() const;
  public:
  void clear_num_irls_observations();
  ::PROTOBUF_NAMESPACE_ID::int32 num_irls_observations() const;
  void set_num_irls_observations(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_irls_observations() const;
  void _internal_set_num_irls_observations(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional float max_irls_change_ratio = 4 [default = 10];
  bool has_max_irls_change_ratio() const;
  private:
  bool _internal_has_max_irls_change_ratio() const;
  public:
  void clear_max_irls_change_ratio();
  float max_irls_change_ratio() const;
  void set_max_irls_change_ratio(float value);
  private:
  float _internal_max_irls_change_ratio() const;
  void _internal_set_max_irls_change_ratio(float value);
  public:

  // optional float inlier_irls_weight = 5 [default = 0.2];
  bool has_inlier_irls_weight() const;
  private:
  bool _internal_has_inlier_irls_weight() const;
  public:
  void clear_inlier_irls_weight();
  float inlier_irls_weight() const;
  void set_inlier_irls_weight(float value);
  private:
  float _internal_inlier_irls_weight() const;
  void _internal_set_inlier_irls_weight(float value);
  public:

  // optional bool use_spatial_bias = 6 [default = true];
  bool has_use_spatial_bias() const;
  private:
  bool _internal_has_use_spatial_bias() const;
  public:
  void clear_use_spatial_bias();
  bool use_spatial_bias() const;
  void set_use_spatial_bias(bool value);
  private:
  bool _internal_use_spatial_bias() const;
  void _internal_set_use_spatial_bias(bool value);
  public:

  // optional float grid_size = 7 [default = 0.04];
  bool has_grid_size() const;
  private:
  bool _internal_has_grid_size() const;
  public:
  void clear_grid_size();
  float grid_size() const;
  void set_grid_size(float value);
  private:
  float _internal_grid_size() const;
  void _internal_set_grid_size(float value);
  public:

  // optional float spatial_sigma = 8 [default = 0.02];
  bool has_spatial_sigma() const;
  private:
  bool _internal_has_spatial_sigma() const;
  public:
  void clear_spatial_sigma();
  float spatial_sigma() const;
  void set_spatial_sigma(float value);
  private:
  float _internal_spatial_sigma() const;
  void _internal_set_spatial_sigma(float value);
  public:

  // optional float color_sigma = 9 [default = 20];
  bool has_color_sigma() const;
  private:
  bool _internal_has_color_sigma() const;
  public:
  void clear_color_sigma();
  float color_sigma() const;
  void set_color_sigma(float value);
  private:
  float _internal_color_sigma() const;
  void _internal_set_color_sigma(float value);
  public:

  // optional int32 long_track_threshold = 10 [default = 30];
  bool has_long_track_threshold() const;
  private:
  bool _internal_has_long_track_threshold() const;
  public:
  void clear_long_track_threshold();
  ::PROTOBUF_NAMESPACE_ID::int32 long_track_threshold() const;
  void set_long_track_threshold(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_long_track_threshold() const;
  void _internal_set_long_track_threshold(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional float long_track_confidence_fraction = 11 [default = 0.25];
  bool has_long_track_confidence_fraction() const;
  private:
  bool _internal_has_long_track_confidence_fraction() const;
  public:
  void clear_long_track_confidence_fraction();
  float long_track_confidence_fraction() const;
  void set_long_track_confidence_fraction(float value);
  private:
  float _internal_long_track_confidence_fraction() const;
  void _internal_set_long_track_confidence_fraction(float value);
  public:

  // optional float bias_stdev = 12 [default = 1];
  bool has_bias_stdev() const;
  private:
  bool _internal_has_bias_stdev() const;
  public:
  void clear_bias_stdev();
  float bias_stdev() const;
  void set_bias_stdev(float value);
  private:
  float _internal_bias_stdev() const;
  void _internal_set_bias_stdev(float value);
  public:

  // @@protoc_insertion_point(class_scope:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool seed_priors_from_bias_;
  ::PROTOBUF_NAMESPACE_ID::int32 total_rounds_;
  float inlier_bias_;
  float outlier_bias_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_irls_observations_;
  float max_irls_change_ratio_;
  float inlier_irls_weight_;
  bool use_spatial_bias_;
  float grid_size_;
  float spatial_sigma_;
  float color_sigma_;
  ::PROTOBUF_NAMESPACE_ID::int32 long_track_threshold_;
  float long_track_confidence_fraction_;
  float bias_stdev_;
  friend struct ::TableStruct_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto;
};
// -------------------------------------------------------------------

class MotionEstimationOptions_TranslationBounds PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.MotionEstimationOptions.TranslationBounds) */ {
 public:
  inline MotionEstimationOptions_TranslationBounds() : MotionEstimationOptions_TranslationBounds(nullptr) {}
  ~MotionEstimationOptions_TranslationBounds() override;
  explicit constexpr MotionEstimationOptions_TranslationBounds(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MotionEstimationOptions_TranslationBounds(const MotionEstimationOptions_TranslationBounds& from);
  MotionEstimationOptions_TranslationBounds(MotionEstimationOptions_TranslationBounds&& from) noexcept
    : MotionEstimationOptions_TranslationBounds() {
    *this = ::std::move(from);
  }

  inline MotionEstimationOptions_TranslationBounds& operator=(const MotionEstimationOptions_TranslationBounds& from) {
    CopyFrom(from);
    return *this;
  }
  inline MotionEstimationOptions_TranslationBounds& operator=(MotionEstimationOptions_TranslationBounds&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MotionEstimationOptions_TranslationBounds& default_instance() {
    return *internal_default_instance();
  }
  static inline const MotionEstimationOptions_TranslationBounds* internal_default_instance() {
    return reinterpret_cast<const MotionEstimationOptions_TranslationBounds*>(
               &_MotionEstimationOptions_TranslationBounds_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MotionEstimationOptions_TranslationBounds& a, MotionEstimationOptions_TranslationBounds& b) {
    a.Swap(&b);
  }
  inline void Swap(MotionEstimationOptions_TranslationBounds* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MotionEstimationOptions_TranslationBounds* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MotionEstimationOptions_TranslationBounds* New() const final {
    return CreateMaybeMessage<MotionEstimationOptions_TranslationBounds>(nullptr);
  }

  MotionEstimationOptions_TranslationBounds* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MotionEstimationOptions_TranslationBounds>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MotionEstimationOptions_TranslationBounds& from);
  void MergeFrom(const MotionEstimationOptions_TranslationBounds& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotionEstimationOptions_TranslationBounds* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.MotionEstimationOptions.TranslationBounds";
  }
  protected:
  explicit MotionEstimationOptions_TranslationBounds(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxAccelerationFieldNumber = 5,
    kMinFeaturesFieldNumber = 1,
    kFracMaxMotionMagnitudeFieldNumber = 2,
    kMaxMotionStdevFieldNumber = 3,
    kMaxMotionStdevThresholdFieldNumber = 4,
  };
  // optional float max_acceleration = 5 [default = 20];
  bool has_max_acceleration() const;
  private:
  bool _internal_has_max_acceleration() const;
  public:
  void clear_max_acceleration();
  float max_acceleration() const;
  void set_max_acceleration(float value);
  private:
  float _internal_max_acceleration() const;
  void _internal_set_max_acceleration(float value);
  public:

  // optional int32 min_features = 1 [default = 3];
  bool has_min_features() const;
  private:
  bool _internal_has_min_features() const;
  public:
  void clear_min_features();
  ::PROTOBUF_NAMESPACE_ID::int32 min_features() const;
  void set_min_features(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_min_features() const;
  void _internal_set_min_features(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional float frac_max_motion_magnitude = 2 [default = 0.15];
  bool has_frac_max_motion_magnitude() const;
  private:
  bool _internal_has_frac_max_motion_magnitude() const;
  public:
  void clear_frac_max_motion_magnitude();
  float frac_max_motion_magnitude() const;
  void set_frac_max_motion_magnitude(float value);
  private:
  float _internal_frac_max_motion_magnitude() const;
  void _internal_set_frac_max_motion_magnitude(float value);
  public:

  // optional float max_motion_stdev = 3 [default = 0.065];
  bool has_max_motion_stdev() const;
  private:
  bool _internal_has_max_motion_stdev() const;
  public:
  void clear_max_motion_stdev();
  float max_motion_stdev() const;
  void set_max_motion_stdev(float value);
  private:
  float _internal_max_motion_stdev() const;
  void _internal_set_max_motion_stdev(float value);
  public:

  // optional float max_motion_stdev_threshold = 4 [default = 0.01];
  bool has_max_motion_stdev_threshold() const;
  private:
  bool _internal_has_max_motion_stdev_threshold() const;
  public:
  void clear_max_motion_stdev_threshold();
  float max_motion_stdev_threshold() const;
  void set_max_motion_stdev_threshold(float value);
  private:
  float _internal_max_motion_stdev_threshold() const;
  void _internal_set_max_motion_stdev_threshold(float value);
  public:

  // @@protoc_insertion_point(class_scope:mediapipe.MotionEstimationOptions.TranslationBounds)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float max_acceleration_;
  ::PROTOBUF_NAMESPACE_ID::int32 min_features_;
  float frac_max_motion_magnitude_;
  float max_motion_stdev_;
  float max_motion_stdev_threshold_;
  friend struct ::TableStruct_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto;
};
// -------------------------------------------------------------------

class MotionEstimationOptions_SimilarityBounds PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.MotionEstimationOptions.SimilarityBounds) */ {
 public:
  inline MotionEstimationOptions_SimilarityBounds() : MotionEstimationOptions_SimilarityBounds(nullptr) {}
  ~MotionEstimationOptions_SimilarityBounds() override;
  explicit constexpr MotionEstimationOptions_SimilarityBounds(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MotionEstimationOptions_SimilarityBounds(const MotionEstimationOptions_SimilarityBounds& from);
  MotionEstimationOptions_SimilarityBounds(MotionEstimationOptions_SimilarityBounds&& from) noexcept
    : MotionEstimationOptions_SimilarityBounds() {
    *this = ::std::move(from);
  }

  inline MotionEstimationOptions_SimilarityBounds& operator=(const MotionEstimationOptions_SimilarityBounds& from) {
    CopyFrom(from);
    return *this;
  }
  inline MotionEstimationOptions_SimilarityBounds& operator=(MotionEstimationOptions_SimilarityBounds&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MotionEstimationOptions_SimilarityBounds& default_instance() {
    return *internal_default_instance();
  }
  static inline const MotionEstimationOptions_SimilarityBounds* internal_default_instance() {
    return reinterpret_cast<const MotionEstimationOptions_SimilarityBounds*>(
               &_MotionEstimationOptions_SimilarityBounds_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MotionEstimationOptions_SimilarityBounds& a, MotionEstimationOptions_SimilarityBounds& b) {
    a.Swap(&b);
  }
  inline void Swap(MotionEstimationOptions_SimilarityBounds* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MotionEstimationOptions_SimilarityBounds* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MotionEstimationOptions_SimilarityBounds* New() const final {
    return CreateMaybeMessage<MotionEstimationOptions_SimilarityBounds>(nullptr);
  }

  MotionEstimationOptions_SimilarityBounds* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MotionEstimationOptions_SimilarityBounds>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MotionEstimationOptions_SimilarityBounds& from);
  void MergeFrom(const MotionEstimationOptions_SimilarityBounds& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotionEstimationOptions_SimilarityBounds* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.MotionEstimationOptions.SimilarityBounds";
  }
  protected:
  explicit MotionEstimationOptions_SimilarityBounds(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFracInlierThresholdFieldNumber = 8,
    kOnlyStableInputFieldNumber = 1,
    kMinInlierFractionFieldNumber = 2,
    kMinInliersFieldNumber = 3,
    kLowerScaleFieldNumber = 4,
    kUpperScaleFieldNumber = 5,
    kLimitRotationFieldNumber = 6,
    kInlierThresholdFieldNumber = 7,
    kStrictInlierThresholdFieldNumber = 9,
  };
  // optional float frac_inlier_threshold = 8 [default = 0];
  bool has_frac_inlier_threshold() const;
  private:
  bool _internal_has_frac_inlier_threshold() const;
  public:
  void clear_frac_inlier_threshold();
  float frac_inlier_threshold() const;
  void set_frac_inlier_threshold(float value);
  private:
  float _internal_frac_inlier_threshold() const;
  void _internal_set_frac_inlier_threshold(float value);
  public:

  // optional bool only_stable_input = 1 [default = true];
  bool has_only_stable_input() const;
  private:
  bool _internal_has_only_stable_input() const;
  public:
  void clear_only_stable_input();
  bool only_stable_input() const;
  void set_only_stable_input(bool value);
  private:
  bool _internal_only_stable_input() const;
  void _internal_set_only_stable_input(bool value);
  public:

  // optional float min_inlier_fraction = 2 [default = 0.2];
  bool has_min_inlier_fraction() const;
  private:
  bool _internal_has_min_inlier_fraction() const;
  public:
  void clear_min_inlier_fraction();
  float min_inlier_fraction() const;
  void set_min_inlier_fraction(float value);
  private:
  float _internal_min_inlier_fraction() const;
  void _internal_set_min_inlier_fraction(float value);
  public:

  // optional float min_inliers = 3 [default = 30];
  bool has_min_inliers() const;
  private:
  bool _internal_has_min_inliers() const;
  public:
  void clear_min_inliers();
  float min_inliers() const;
  void set_min_inliers(float value);
  private:
  float _internal_min_inliers() const;
  void _internal_set_min_inliers(float value);
  public:

  // optional float lower_scale = 4 [default = 0.8];
  bool has_lower_scale() const;
  private:
  bool _internal_has_lower_scale() const;
  public:
  void clear_lower_scale();
  float lower_scale() const;
  void set_lower_scale(float value);
  private:
  float _internal_lower_scale() const;
  void _internal_set_lower_scale(float value);
  public:

  // optional float upper_scale = 5 [default = 1.25];
  bool has_upper_scale() const;
  private:
  bool _internal_has_upper_scale() const;
  public:
  void clear_upper_scale();
  float upper_scale() const;
  void set_upper_scale(float value);
  private:
  float _internal_upper_scale() const;
  void _internal_set_upper_scale(float value);
  public:

  // optional float limit_rotation = 6 [default = 0.25];
  bool has_limit_rotation() const;
  private:
  bool _internal_has_limit_rotation() const;
  public:
  void clear_limit_rotation();
  float limit_rotation() const;
  void set_limit_rotation(float value);
  private:
  float _internal_limit_rotation() const;
  void _internal_set_limit_rotation(float value);
  public:

  // optional float inlier_threshold = 7 [default = 4];
  bool has_inlier_threshold() const;
  private:
  bool _internal_has_inlier_threshold() const;
  public:
  void clear_inlier_threshold();
  float inlier_threshold() const;
  void set_inlier_threshold(float value);
  private:
  float _internal_inlier_threshold() const;
  void _internal_set_inlier_threshold(float value);
  public:

  // optional float strict_inlier_threshold = 9 [default = 0.5];
  bool has_strict_inlier_threshold() const;
  private:
  bool _internal_has_strict_inlier_threshold() const;
  public:
  void clear_strict_inlier_threshold();
  float strict_inlier_threshold() const;
  void set_strict_inlier_threshold(float value);
  private:
  float _internal_strict_inlier_threshold() const;
  void _internal_set_strict_inlier_threshold(float value);
  public:

  // @@protoc_insertion_point(class_scope:mediapipe.MotionEstimationOptions.SimilarityBounds)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float frac_inlier_threshold_;
  bool only_stable_input_;
  float min_inlier_fraction_;
  float min_inliers_;
  float lower_scale_;
  float upper_scale_;
  float limit_rotation_;
  float inlier_threshold_;
  float strict_inlier_threshold_;
  friend struct ::TableStruct_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto;
};
// -------------------------------------------------------------------

class MotionEstimationOptions_HomographyBounds PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.MotionEstimationOptions.HomographyBounds) */ {
 public:
  inline MotionEstimationOptions_HomographyBounds() : MotionEstimationOptions_HomographyBounds(nullptr) {}
  ~MotionEstimationOptions_HomographyBounds() override;
  explicit constexpr MotionEstimationOptions_HomographyBounds(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MotionEstimationOptions_HomographyBounds(const MotionEstimationOptions_HomographyBounds& from);
  MotionEstimationOptions_HomographyBounds(MotionEstimationOptions_HomographyBounds&& from) noexcept
    : MotionEstimationOptions_HomographyBounds() {
    *this = ::std::move(from);
  }

  inline MotionEstimationOptions_HomographyBounds& operator=(const MotionEstimationOptions_HomographyBounds& from) {
    CopyFrom(from);
    return *this;
  }
  inline MotionEstimationOptions_HomographyBounds& operator=(MotionEstimationOptions_HomographyBounds&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MotionEstimationOptions_HomographyBounds& default_instance() {
    return *internal_default_instance();
  }
  static inline const MotionEstimationOptions_HomographyBounds* internal_default_instance() {
    return reinterpret_cast<const MotionEstimationOptions_HomographyBounds*>(
               &_MotionEstimationOptions_HomographyBounds_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MotionEstimationOptions_HomographyBounds& a, MotionEstimationOptions_HomographyBounds& b) {
    a.Swap(&b);
  }
  inline void Swap(MotionEstimationOptions_HomographyBounds* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MotionEstimationOptions_HomographyBounds* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MotionEstimationOptions_HomographyBounds* New() const final {
    return CreateMaybeMessage<MotionEstimationOptions_HomographyBounds>(nullptr);
  }

  MotionEstimationOptions_HomographyBounds* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MotionEstimationOptions_HomographyBounds>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MotionEstimationOptions_HomographyBounds& from);
  void MergeFrom(const MotionEstimationOptions_HomographyBounds& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotionEstimationOptions_HomographyBounds* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.MotionEstimationOptions.HomographyBounds";
  }
  protected:
  explicit MotionEstimationOptions_HomographyBounds(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFracRegistrationThresholdFieldNumber = 8,
    kFracInlierThresholdFieldNumber = 7,
    kLowerScaleFieldNumber = 1,
    kUpperScaleFieldNumber = 2,
    kLimitRotationFieldNumber = 3,
    kLimitPerspectiveFieldNumber = 4,
    kRegistrationThresholdFieldNumber = 5,
    kMinInlierCoverageFieldNumber = 6,
  };
  // optional float frac_registration_threshold = 8 [default = 0];
  bool has_frac_registration_threshold() const;
  private:
  bool _internal_has_frac_registration_threshold() const;
  public:
  void clear_frac_registration_threshold();
  float frac_registration_threshold() const;
  void set_frac_registration_threshold(float value);
  private:
  float _internal_frac_registration_threshold() const;
  void _internal_set_frac_registration_threshold(float value);
  public:

  // optional float frac_inlier_threshold = 7 [default = 0.002];
  bool has_frac_inlier_threshold() const;
  private:
  bool _internal_has_frac_inlier_threshold() const;
  public:
  void clear_frac_inlier_threshold();
  float frac_inlier_threshold() const;
  void set_frac_inlier_threshold(float value);
  private:
  float _internal_frac_inlier_threshold() const;
  void _internal_set_frac_inlier_threshold(float value);
  public:

  // optional float lower_scale = 1 [default = 0.8];
  bool has_lower_scale() const;
  private:
  bool _internal_has_lower_scale() const;
  public:
  void clear_lower_scale();
  float lower_scale() const;
  void set_lower_scale(float value);
  private:
  float _internal_lower_scale() const;
  void _internal_set_lower_scale(float value);
  public:

  // optional float upper_scale = 2 [default = 1.25];
  bool has_upper_scale() const;
  private:
  bool _internal_has_upper_scale() const;
  public:
  void clear_upper_scale();
  float upper_scale() const;
  void set_upper_scale(float value);
  private:
  float _internal_upper_scale() const;
  void _internal_set_upper_scale(float value);
  public:

  // optional float limit_rotation = 3 [default = 0.25];
  bool has_limit_rotation() const;
  private:
  bool _internal_has_limit_rotation() const;
  public:
  void clear_limit_rotation();
  float limit_rotation() const;
  void set_limit_rotation(float value);
  private:
  float _internal_limit_rotation() const;
  void _internal_set_limit_rotation(float value);
  public:

  // optional float limit_perspective = 4 [default = 0.0004];
  bool has_limit_perspective() const;
  private:
  bool _internal_has_limit_perspective() const;
  public:
  void clear_limit_perspective();
  float limit_perspective() const;
  void set_limit_perspective(float value);
  private:
  float _internal_limit_perspective() const;
  void _internal_set_limit_perspective(float value);
  public:

  // optional float registration_threshold = 5 [default = 0.1];
  bool has_registration_threshold() const;
  private:
  bool _internal_has_registration_threshold() const;
  public:
  void clear_registration_threshold();
  float registration_threshold() const;
  void set_registration_threshold(float value);
  private:
  float _internal_registration_threshold() const;
  void _internal_set_registration_threshold(float value);
  public:

  // optional float min_inlier_coverage = 6 [default = 0.3];
  bool has_min_inlier_coverage() const;
  private:
  bool _internal_has_min_inlier_coverage() const;
  public:
  void clear_min_inlier_coverage();
  float min_inlier_coverage() const;
  void set_min_inlier_coverage(float value);
  private:
  float _internal_min_inlier_coverage() const;
  void _internal_set_min_inlier_coverage(float value);
  public:

  // @@protoc_insertion_point(class_scope:mediapipe.MotionEstimationOptions.HomographyBounds)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float frac_registration_threshold_;
  float frac_inlier_threshold_;
  float lower_scale_;
  float upper_scale_;
  float limit_rotation_;
  float limit_perspective_;
  float registration_threshold_;
  float min_inlier_coverage_;
  friend struct ::TableStruct_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto;
};
// -------------------------------------------------------------------

class MotionEstimationOptions_MixtureHomographyBounds PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.MotionEstimationOptions.MixtureHomographyBounds) */ {
 public:
  inline MotionEstimationOptions_MixtureHomographyBounds() : MotionEstimationOptions_MixtureHomographyBounds(nullptr) {}
  ~MotionEstimationOptions_MixtureHomographyBounds() override;
  explicit constexpr MotionEstimationOptions_MixtureHomographyBounds(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MotionEstimationOptions_MixtureHomographyBounds(const MotionEstimationOptions_MixtureHomographyBounds& from);
  MotionEstimationOptions_MixtureHomographyBounds(MotionEstimationOptions_MixtureHomographyBounds&& from) noexcept
    : MotionEstimationOptions_MixtureHomographyBounds() {
    *this = ::std::move(from);
  }

  inline MotionEstimationOptions_MixtureHomographyBounds& operator=(const MotionEstimationOptions_MixtureHomographyBounds& from) {
    CopyFrom(from);
    return *this;
  }
  inline MotionEstimationOptions_MixtureHomographyBounds& operator=(MotionEstimationOptions_MixtureHomographyBounds&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MotionEstimationOptions_MixtureHomographyBounds& default_instance() {
    return *internal_default_instance();
  }
  static inline const MotionEstimationOptions_MixtureHomographyBounds* internal_default_instance() {
    return reinterpret_cast<const MotionEstimationOptions_MixtureHomographyBounds*>(
               &_MotionEstimationOptions_MixtureHomographyBounds_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MotionEstimationOptions_MixtureHomographyBounds& a, MotionEstimationOptions_MixtureHomographyBounds& b) {
    a.Swap(&b);
  }
  inline void Swap(MotionEstimationOptions_MixtureHomographyBounds* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MotionEstimationOptions_MixtureHomographyBounds* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MotionEstimationOptions_MixtureHomographyBounds* New() const final {
    return CreateMaybeMessage<MotionEstimationOptions_MixtureHomographyBounds>(nullptr);
  }

  MotionEstimationOptions_MixtureHomographyBounds* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MotionEstimationOptions_MixtureHomographyBounds>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MotionEstimationOptions_MixtureHomographyBounds& from);
  void MergeFrom(const MotionEstimationOptions_MixtureHomographyBounds& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotionEstimationOptions_MixtureHomographyBounds* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.MotionEstimationOptions.MixtureHomographyBounds";
  }
  protected:
  explicit MotionEstimationOptions_MixtureHomographyBounds(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinInlierCoverageFieldNumber = 1,
    kMaxAdjacentOutlierBlocksFieldNumber = 2,
    kMaxAdjacentEmptyBlocksFieldNumber = 3,
    kFracInlierThresholdFieldNumber = 7,
  };
  // optional float min_inlier_coverage = 1 [default = 0.4];
  bool has_min_inlier_coverage() const;
  private:
  bool _internal_has_min_inlier_coverage() const;
  public:
  void clear_min_inlier_coverage();
  float min_inlier_coverage() const;
  void set_min_inlier_coverage(float value);
  private:
  float _internal_min_inlier_coverage() const;
  void _internal_set_min_inlier_coverage(float value);
  public:

  // optional int32 max_adjacent_outlier_blocks = 2 [default = 5];
  bool has_max_adjacent_outlier_blocks() const;
  private:
  bool _internal_has_max_adjacent_outlier_blocks() const;
  public:
  void clear_max_adjacent_outlier_blocks();
  ::PROTOBUF_NAMESPACE_ID::int32 max_adjacent_outlier_blocks() const;
  void set_max_adjacent_outlier_blocks(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_max_adjacent_outlier_blocks() const;
  void _internal_set_max_adjacent_outlier_blocks(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 max_adjacent_empty_blocks = 3 [default = 3];
  bool has_max_adjacent_empty_blocks() const;
  private:
  bool _internal_has_max_adjacent_empty_blocks() const;
  public:
  void clear_max_adjacent_empty_blocks();
  ::PROTOBUF_NAMESPACE_ID::int32 max_adjacent_empty_blocks() const;
  void set_max_adjacent_empty_blocks(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_max_adjacent_empty_blocks() const;
  void _internal_set_max_adjacent_empty_blocks(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional float frac_inlier_threshold = 7 [default = 0.0025];
  bool has_frac_inlier_threshold() const;
  private:
  bool _internal_has_frac_inlier_threshold() const;
  public:
  void clear_frac_inlier_threshold();
  float frac_inlier_threshold() const;
  void set_frac_inlier_threshold(float value);
  private:
  float _internal_frac_inlier_threshold() const;
  void _internal_set_frac_inlier_threshold(float value);
  public:

  // @@protoc_insertion_point(class_scope:mediapipe.MotionEstimationOptions.MixtureHomographyBounds)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float min_inlier_coverage_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_adjacent_outlier_blocks_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_adjacent_empty_blocks_;
  float frac_inlier_threshold_;
  friend struct ::TableStruct_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto;
};
// -------------------------------------------------------------------

class MotionEstimationOptions_OverlayDetectionOptions PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.MotionEstimationOptions.OverlayDetectionOptions) */ {
 public:
  inline MotionEstimationOptions_OverlayDetectionOptions() : MotionEstimationOptions_OverlayDetectionOptions(nullptr) {}
  ~MotionEstimationOptions_OverlayDetectionOptions() override;
  explicit constexpr MotionEstimationOptions_OverlayDetectionOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MotionEstimationOptions_OverlayDetectionOptions(const MotionEstimationOptions_OverlayDetectionOptions& from);
  MotionEstimationOptions_OverlayDetectionOptions(MotionEstimationOptions_OverlayDetectionOptions&& from) noexcept
    : MotionEstimationOptions_OverlayDetectionOptions() {
    *this = ::std::move(from);
  }

  inline MotionEstimationOptions_OverlayDetectionOptions& operator=(const MotionEstimationOptions_OverlayDetectionOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline MotionEstimationOptions_OverlayDetectionOptions& operator=(MotionEstimationOptions_OverlayDetectionOptions&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MotionEstimationOptions_OverlayDetectionOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const MotionEstimationOptions_OverlayDetectionOptions* internal_default_instance() {
    return reinterpret_cast<const MotionEstimationOptions_OverlayDetectionOptions*>(
               &_MotionEstimationOptions_OverlayDetectionOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MotionEstimationOptions_OverlayDetectionOptions& a, MotionEstimationOptions_OverlayDetectionOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(MotionEstimationOptions_OverlayDetectionOptions* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MotionEstimationOptions_OverlayDetectionOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MotionEstimationOptions_OverlayDetectionOptions* New() const final {
    return CreateMaybeMessage<MotionEstimationOptions_OverlayDetectionOptions>(nullptr);
  }

  MotionEstimationOptions_OverlayDetectionOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MotionEstimationOptions_OverlayDetectionOptions>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MotionEstimationOptions_OverlayDetectionOptions& from);
  void MergeFrom(const MotionEstimationOptions_OverlayDetectionOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotionEstimationOptions_OverlayDetectionOptions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.MotionEstimationOptions.OverlayDetectionOptions";
  }
  protected:
  explicit MotionEstimationOptions_OverlayDetectionOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOverlayMinFeaturesFieldNumber = 7,
    kAnalysisMaskSizeFieldNumber = 1,
    kStrictNearZeroMotionFieldNumber = 2,
    kStrictMaxTranslationRatioFieldNumber = 3,
    kLooseNearZeroMotionFieldNumber = 4,
    kStrictMinTexturednessFieldNumber = 5,
    kOverlayMinRatioFieldNumber = 6,
  };
  // optional float overlay_min_features = 7 [default = 10];
  bool has_overlay_min_features() const;
  private:
  bool _internal_has_overlay_min_features() const;
  public:
  void clear_overlay_min_features();
  float overlay_min_features() const;
  void set_overlay_min_features(float value);
  private:
  float _internal_overlay_min_features() const;
  void _internal_set_overlay_min_features(float value);
  public:

  // optional int32 analysis_mask_size = 1 [default = 10];
  bool has_analysis_mask_size() const;
  private:
  bool _internal_has_analysis_mask_size() const;
  public:
  void clear_analysis_mask_size();
  ::PROTOBUF_NAMESPACE_ID::int32 analysis_mask_size() const;
  void set_analysis_mask_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_analysis_mask_size() const;
  void _internal_set_analysis_mask_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional float strict_near_zero_motion = 2 [default = 0.2];
  bool has_strict_near_zero_motion() const;
  private:
  bool _internal_has_strict_near_zero_motion() const;
  public:
  void clear_strict_near_zero_motion();
  float strict_near_zero_motion() const;
  void set_strict_near_zero_motion(float value);
  private:
  float _internal_strict_near_zero_motion() const;
  void _internal_set_strict_near_zero_motion(float value);
  public:

  // optional float strict_max_translation_ratio = 3 [default = 0.2];
  bool has_strict_max_translation_ratio() const;
  private:
  bool _internal_has_strict_max_translation_ratio() const;
  public:
  void clear_strict_max_translation_ratio();
  float strict_max_translation_ratio() const;
  void set_strict_max_translation_ratio(float value);
  private:
  float _internal_strict_max_translation_ratio() const;
  void _internal_set_strict_max_translation_ratio(float value);
  public:

  // optional float loose_near_zero_motion = 4 [default = 1];
  bool has_loose_near_zero_motion() const;
  private:
  bool _internal_has_loose_near_zero_motion() const;
  public:
  void clear_loose_near_zero_motion();
  float loose_near_zero_motion() const;
  void set_loose_near_zero_motion(float value);
  private:
  float _internal_loose_near_zero_motion() const;
  void _internal_set_loose_near_zero_motion(float value);
  public:

  // optional float strict_min_texturedness = 5 [default = 0.1];
  bool has_strict_min_texturedness() const;
  private:
  bool _internal_has_strict_min_texturedness() const;
  public:
  void clear_strict_min_texturedness();
  float strict_min_texturedness() const;
  void set_strict_min_texturedness(float value);
  private:
  float _internal_strict_min_texturedness() const;
  void _internal_set_strict_min_texturedness(float value);
  public:

  // optional float overlay_min_ratio = 6 [default = 0.3];
  bool has_overlay_min_ratio() const;
  private:
  bool _internal_has_overlay_min_ratio() const;
  public:
  void clear_overlay_min_ratio();
  float overlay_min_ratio() const;
  void set_overlay_min_ratio(float value);
  private:
  float _internal_overlay_min_ratio() const;
  void _internal_set_overlay_min_ratio(float value);
  public:

  // @@protoc_insertion_point(class_scope:mediapipe.MotionEstimationOptions.OverlayDetectionOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float overlay_min_features_;
  ::PROTOBUF_NAMESPACE_ID::int32 analysis_mask_size_;
  float strict_near_zero_motion_;
  float strict_max_translation_ratio_;
  float loose_near_zero_motion_;
  float strict_min_texturedness_;
  float overlay_min_ratio_;
  friend struct ::TableStruct_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto;
};
// -------------------------------------------------------------------

class MotionEstimationOptions_ShotBoundaryOptions PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.MotionEstimationOptions.ShotBoundaryOptions) */ {
 public:
  inline MotionEstimationOptions_ShotBoundaryOptions() : MotionEstimationOptions_ShotBoundaryOptions(nullptr) {}
  ~MotionEstimationOptions_ShotBoundaryOptions() override;
  explicit constexpr MotionEstimationOptions_ShotBoundaryOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MotionEstimationOptions_ShotBoundaryOptions(const MotionEstimationOptions_ShotBoundaryOptions& from);
  MotionEstimationOptions_ShotBoundaryOptions(MotionEstimationOptions_ShotBoundaryOptions&& from) noexcept
    : MotionEstimationOptions_ShotBoundaryOptions() {
    *this = ::std::move(from);
  }

  inline MotionEstimationOptions_ShotBoundaryOptions& operator=(const MotionEstimationOptions_ShotBoundaryOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline MotionEstimationOptions_ShotBoundaryOptions& operator=(MotionEstimationOptions_ShotBoundaryOptions&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MotionEstimationOptions_ShotBoundaryOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const MotionEstimationOptions_ShotBoundaryOptions* internal_default_instance() {
    return reinterpret_cast<const MotionEstimationOptions_ShotBoundaryOptions*>(
               &_MotionEstimationOptions_ShotBoundaryOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(MotionEstimationOptions_ShotBoundaryOptions& a, MotionEstimationOptions_ShotBoundaryOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(MotionEstimationOptions_ShotBoundaryOptions* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MotionEstimationOptions_ShotBoundaryOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MotionEstimationOptions_ShotBoundaryOptions* New() const final {
    return CreateMaybeMessage<MotionEstimationOptions_ShotBoundaryOptions>(nullptr);
  }

  MotionEstimationOptions_ShotBoundaryOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MotionEstimationOptions_ShotBoundaryOptions>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MotionEstimationOptions_ShotBoundaryOptions& from);
  void MergeFrom(const MotionEstimationOptions_ShotBoundaryOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotionEstimationOptions_ShotBoundaryOptions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.MotionEstimationOptions.ShotBoundaryOptions";
  }
  protected:
  explicit MotionEstimationOptions_ShotBoundaryOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMotionConsistencyThresholdFieldNumber = 1,
    kAppearanceConsistencyThresholdFieldNumber = 2,
  };
  // optional float motion_consistency_threshold = 1 [default = 0.02];
  bool has_motion_consistency_threshold() const;
  private:
  bool _internal_has_motion_consistency_threshold() const;
  public:
  void clear_motion_consistency_threshold();
  float motion_consistency_threshold() const;
  void set_motion_consistency_threshold(float value);
  private:
  float _internal_motion_consistency_threshold() const;
  void _internal_set_motion_consistency_threshold(float value);
  public:

  // optional float appearance_consistency_threshold = 2 [default = 0.075];
  bool has_appearance_consistency_threshold() const;
  private:
  bool _internal_has_appearance_consistency_threshold() const;
  public:
  void clear_appearance_consistency_threshold();
  float appearance_consistency_threshold() const;
  void set_appearance_consistency_threshold(float value);
  private:
  float _internal_appearance_consistency_threshold() const;
  void _internal_set_appearance_consistency_threshold(float value);
  public:

  // @@protoc_insertion_point(class_scope:mediapipe.MotionEstimationOptions.ShotBoundaryOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float motion_consistency_threshold_;
  float appearance_consistency_threshold_;
  friend struct ::TableStruct_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto;
};
// -------------------------------------------------------------------

class MotionEstimationOptions PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mediapipe.MotionEstimationOptions) */ {
 public:
  inline MotionEstimationOptions() : MotionEstimationOptions(nullptr) {}
  ~MotionEstimationOptions() override;
  explicit constexpr MotionEstimationOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MotionEstimationOptions(const MotionEstimationOptions& from);
  MotionEstimationOptions(MotionEstimationOptions&& from) noexcept
    : MotionEstimationOptions() {
    *this = ::std::move(from);
  }

  inline MotionEstimationOptions& operator=(const MotionEstimationOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline MotionEstimationOptions& operator=(MotionEstimationOptions&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MotionEstimationOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const MotionEstimationOptions* internal_default_instance() {
    return reinterpret_cast<const MotionEstimationOptions*>(
               &_MotionEstimationOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(MotionEstimationOptions& a, MotionEstimationOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(MotionEstimationOptions* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MotionEstimationOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MotionEstimationOptions* New() const final {
    return CreateMaybeMessage<MotionEstimationOptions>(nullptr);
  }

  MotionEstimationOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MotionEstimationOptions>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MotionEstimationOptions& from);
  void MergeFrom(const MotionEstimationOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotionEstimationOptions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mediapipe.MotionEstimationOptions";
  }
  protected:
  explicit MotionEstimationOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MotionEstimationOptions_IrlsOutlierInitialization IrlsOutlierInitialization;
  typedef MotionEstimationOptions_LongFeatureInitialization LongFeatureInitialization;
  typedef MotionEstimationOptions_IrlsMaskOptions IrlsMaskOptions;
  typedef MotionEstimationOptions_JointTrackEstimationOptions JointTrackEstimationOptions;
  typedef MotionEstimationOptions_LongFeatureBiasOptions LongFeatureBiasOptions;
  typedef MotionEstimationOptions_TranslationBounds TranslationBounds;
  typedef MotionEstimationOptions_SimilarityBounds SimilarityBounds;
  typedef MotionEstimationOptions_HomographyBounds HomographyBounds;
  typedef MotionEstimationOptions_MixtureHomographyBounds MixtureHomographyBounds;
  typedef MotionEstimationOptions_OverlayDetectionOptions OverlayDetectionOptions;
  typedef MotionEstimationOptions_ShotBoundaryOptions ShotBoundaryOptions;

  typedef MotionEstimationOptions_LinearSimilarityEstimation LinearSimilarityEstimation;
  static constexpr LinearSimilarityEstimation ESTIMATION_LS_NONE =
    MotionEstimationOptions_LinearSimilarityEstimation_ESTIMATION_LS_NONE;
  static constexpr LinearSimilarityEstimation ESTIMATION_LS_L2 =
    MotionEstimationOptions_LinearSimilarityEstimation_ESTIMATION_LS_L2;
  static constexpr LinearSimilarityEstimation ESTIMATION_LS_IRLS =
    MotionEstimationOptions_LinearSimilarityEstimation_ESTIMATION_LS_IRLS;
  static constexpr LinearSimilarityEstimation ESTIMATION_LS_L2_RANSAC =
    MotionEstimationOptions_LinearSimilarityEstimation_ESTIMATION_LS_L2_RANSAC;
  static constexpr LinearSimilarityEstimation ESTIMATION_LS_L1 =
    MotionEstimationOptions_LinearSimilarityEstimation_ESTIMATION_LS_L1;
  static inline bool LinearSimilarityEstimation_IsValid(int value) {
    return MotionEstimationOptions_LinearSimilarityEstimation_IsValid(value);
  }
  static constexpr LinearSimilarityEstimation LinearSimilarityEstimation_MIN =
    MotionEstimationOptions_LinearSimilarityEstimation_LinearSimilarityEstimation_MIN;
  static constexpr LinearSimilarityEstimation LinearSimilarityEstimation_MAX =
    MotionEstimationOptions_LinearSimilarityEstimation_LinearSimilarityEstimation_MAX;
  static constexpr int LinearSimilarityEstimation_ARRAYSIZE =
    MotionEstimationOptions_LinearSimilarityEstimation_LinearSimilarityEstimation_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LinearSimilarityEstimation_descriptor() {
    return MotionEstimationOptions_LinearSimilarityEstimation_descriptor();
  }
  template<typename T>
  static inline const std::string& LinearSimilarityEstimation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LinearSimilarityEstimation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LinearSimilarityEstimation_Name.");
    return MotionEstimationOptions_LinearSimilarityEstimation_Name(enum_t_value);
  }
  static inline bool LinearSimilarityEstimation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LinearSimilarityEstimation* value) {
    return MotionEstimationOptions_LinearSimilarityEstimation_Parse(name, value);
  }

  typedef MotionEstimationOptions_AffineEstimation AffineEstimation;
  static constexpr AffineEstimation ESTIMATION_AFFINE_NONE =
    MotionEstimationOptions_AffineEstimation_ESTIMATION_AFFINE_NONE;
  static constexpr AffineEstimation ESTIMATION_AFFINE_L2 =
    MotionEstimationOptions_AffineEstimation_ESTIMATION_AFFINE_L2;
  static constexpr AffineEstimation ESTIMATION_AFFINE_IRLS =
    MotionEstimationOptions_AffineEstimation_ESTIMATION_AFFINE_IRLS;
  static inline bool AffineEstimation_IsValid(int value) {
    return MotionEstimationOptions_AffineEstimation_IsValid(value);
  }
  static constexpr AffineEstimation AffineEstimation_MIN =
    MotionEstimationOptions_AffineEstimation_AffineEstimation_MIN;
  static constexpr AffineEstimation AffineEstimation_MAX =
    MotionEstimationOptions_AffineEstimation_AffineEstimation_MAX;
  static constexpr int AffineEstimation_ARRAYSIZE =
    MotionEstimationOptions_AffineEstimation_AffineEstimation_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AffineEstimation_descriptor() {
    return MotionEstimationOptions_AffineEstimation_descriptor();
  }
  template<typename T>
  static inline const std::string& AffineEstimation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AffineEstimation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AffineEstimation_Name.");
    return MotionEstimationOptions_AffineEstimation_Name(enum_t_value);
  }
  static inline bool AffineEstimation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AffineEstimation* value) {
    return MotionEstimationOptions_AffineEstimation_Parse(name, value);
  }

  typedef MotionEstimationOptions_HomographyEstimation HomographyEstimation;
  static constexpr HomographyEstimation ESTIMATION_HOMOG_NONE =
    MotionEstimationOptions_HomographyEstimation_ESTIMATION_HOMOG_NONE;
  static constexpr HomographyEstimation ESTIMATION_HOMOG_L2 =
    MotionEstimationOptions_HomographyEstimation_ESTIMATION_HOMOG_L2;
  static constexpr HomographyEstimation ESTIMATION_HOMOG_IRLS =
    MotionEstimationOptions_HomographyEstimation_ESTIMATION_HOMOG_IRLS;
  static inline bool HomographyEstimation_IsValid(int value) {
    return MotionEstimationOptions_HomographyEstimation_IsValid(value);
  }
  static constexpr HomographyEstimation HomographyEstimation_MIN =
    MotionEstimationOptions_HomographyEstimation_HomographyEstimation_MIN;
  static constexpr HomographyEstimation HomographyEstimation_MAX =
    MotionEstimationOptions_HomographyEstimation_HomographyEstimation_MAX;
  static constexpr int HomographyEstimation_ARRAYSIZE =
    MotionEstimationOptions_HomographyEstimation_HomographyEstimation_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  HomographyEstimation_descriptor() {
    return MotionEstimationOptions_HomographyEstimation_descriptor();
  }
  template<typename T>
  static inline const std::string& HomographyEstimation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, HomographyEstimation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function HomographyEstimation_Name.");
    return MotionEstimationOptions_HomographyEstimation_Name(enum_t_value);
  }
  static inline bool HomographyEstimation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      HomographyEstimation* value) {
    return MotionEstimationOptions_HomographyEstimation_Parse(name, value);
  }

  typedef MotionEstimationOptions_MixtureHomographyEstimation MixtureHomographyEstimation;
  static constexpr MixtureHomographyEstimation ESTIMATION_HOMOG_MIX_NONE =
    MotionEstimationOptions_MixtureHomographyEstimation_ESTIMATION_HOMOG_MIX_NONE;
  static constexpr MixtureHomographyEstimation ESTIMATION_HOMOG_MIX_L2 =
    MotionEstimationOptions_MixtureHomographyEstimation_ESTIMATION_HOMOG_MIX_L2;
  static constexpr MixtureHomographyEstimation ESTIMATION_HOMOG_MIX_IRLS =
    MotionEstimationOptions_MixtureHomographyEstimation_ESTIMATION_HOMOG_MIX_IRLS;
  static inline bool MixtureHomographyEstimation_IsValid(int value) {
    return MotionEstimationOptions_MixtureHomographyEstimation_IsValid(value);
  }
  static constexpr MixtureHomographyEstimation MixtureHomographyEstimation_MIN =
    MotionEstimationOptions_MixtureHomographyEstimation_MixtureHomographyEstimation_MIN;
  static constexpr MixtureHomographyEstimation MixtureHomographyEstimation_MAX =
    MotionEstimationOptions_MixtureHomographyEstimation_MixtureHomographyEstimation_MAX;
  static constexpr int MixtureHomographyEstimation_ARRAYSIZE =
    MotionEstimationOptions_MixtureHomographyEstimation_MixtureHomographyEstimation_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MixtureHomographyEstimation_descriptor() {
    return MotionEstimationOptions_MixtureHomographyEstimation_descriptor();
  }
  template<typename T>
  static inline const std::string& MixtureHomographyEstimation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MixtureHomographyEstimation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MixtureHomographyEstimation_Name.");
    return MotionEstimationOptions_MixtureHomographyEstimation_Name(enum_t_value);
  }
  static inline bool MixtureHomographyEstimation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MixtureHomographyEstimation* value) {
    return MotionEstimationOptions_MixtureHomographyEstimation_Parse(name, value);
  }

  typedef MotionEstimationOptions_EstimationPolicy EstimationPolicy;
  static constexpr EstimationPolicy INDEPENDENT_PARALLEL =
    MotionEstimationOptions_EstimationPolicy_INDEPENDENT_PARALLEL;
  static constexpr EstimationPolicy TEMPORAL_IRLS_MASK =
    MotionEstimationOptions_EstimationPolicy_TEMPORAL_IRLS_MASK;
  static constexpr EstimationPolicy TEMPORAL_LONG_FEATURE_BIAS =
    MotionEstimationOptions_EstimationPolicy_TEMPORAL_LONG_FEATURE_BIAS;
  static constexpr EstimationPolicy JOINTLY_FROM_TRACKS =
    MotionEstimationOptions_EstimationPolicy_JOINTLY_FROM_TRACKS;
  static inline bool EstimationPolicy_IsValid(int value) {
    return MotionEstimationOptions_EstimationPolicy_IsValid(value);
  }
  static constexpr EstimationPolicy EstimationPolicy_MIN =
    MotionEstimationOptions_EstimationPolicy_EstimationPolicy_MIN;
  static constexpr EstimationPolicy EstimationPolicy_MAX =
    MotionEstimationOptions_EstimationPolicy_EstimationPolicy_MAX;
  static constexpr int EstimationPolicy_ARRAYSIZE =
    MotionEstimationOptions_EstimationPolicy_EstimationPolicy_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EstimationPolicy_descriptor() {
    return MotionEstimationOptions_EstimationPolicy_descriptor();
  }
  template<typename T>
  static inline const std::string& EstimationPolicy_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EstimationPolicy>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EstimationPolicy_Name.");
    return MotionEstimationOptions_EstimationPolicy_Name(enum_t_value);
  }
  static inline bool EstimationPolicy_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EstimationPolicy* value) {
    return MotionEstimationOptions_EstimationPolicy_Parse(name, value);
  }

  typedef MotionEstimationOptions_MixtureModelMode MixtureModelMode;
  static constexpr MixtureModelMode FULL_MIXTURE =
    MotionEstimationOptions_MixtureModelMode_FULL_MIXTURE;
  static constexpr MixtureModelMode TRANSLATION_MIXTURE =
    MotionEstimationOptions_MixtureModelMode_TRANSLATION_MIXTURE;
  static constexpr MixtureModelMode SKEW_ROTATION_MIXTURE =
    MotionEstimationOptions_MixtureModelMode_SKEW_ROTATION_MIXTURE;
  static inline bool MixtureModelMode_IsValid(int value) {
    return MotionEstimationOptions_MixtureModelMode_IsValid(value);
  }
  static constexpr MixtureModelMode MixtureModelMode_MIN =
    MotionEstimationOptions_MixtureModelMode_MixtureModelMode_MIN;
  static constexpr MixtureModelMode MixtureModelMode_MAX =
    MotionEstimationOptions_MixtureModelMode_MixtureModelMode_MAX;
  static constexpr int MixtureModelMode_ARRAYSIZE =
    MotionEstimationOptions_MixtureModelMode_MixtureModelMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MixtureModelMode_descriptor() {
    return MotionEstimationOptions_MixtureModelMode_descriptor();
  }
  template<typename T>
  static inline const std::string& MixtureModelMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MixtureModelMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MixtureModelMode_Name.");
    return MotionEstimationOptions_MixtureModelMode_Name(enum_t_value);
  }
  static inline bool MixtureModelMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MixtureModelMode* value) {
    return MotionEstimationOptions_MixtureModelMode_Parse(name, value);
  }

  typedef MotionEstimationOptions_IRLSWeightFilter IRLSWeightFilter;
  static constexpr IRLSWeightFilter IRLS_FILTER_NONE =
    MotionEstimationOptions_IRLSWeightFilter_IRLS_FILTER_NONE;
  static constexpr IRLSWeightFilter IRLS_FILTER_TEXTURE =
    MotionEstimationOptions_IRLSWeightFilter_IRLS_FILTER_TEXTURE;
  static constexpr IRLSWeightFilter IRLS_FILTER_CORNER_RESPONSE =
    MotionEstimationOptions_IRLSWeightFilter_IRLS_FILTER_CORNER_RESPONSE;
  static inline bool IRLSWeightFilter_IsValid(int value) {
    return MotionEstimationOptions_IRLSWeightFilter_IsValid(value);
  }
  static constexpr IRLSWeightFilter IRLSWeightFilter_MIN =
    MotionEstimationOptions_IRLSWeightFilter_IRLSWeightFilter_MIN;
  static constexpr IRLSWeightFilter IRLSWeightFilter_MAX =
    MotionEstimationOptions_IRLSWeightFilter_IRLSWeightFilter_MAX;
  static constexpr int IRLSWeightFilter_ARRAYSIZE =
    MotionEstimationOptions_IRLSWeightFilter_IRLSWeightFilter_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  IRLSWeightFilter_descriptor() {
    return MotionEstimationOptions_IRLSWeightFilter_descriptor();
  }
  template<typename T>
  static inline const std::string& IRLSWeightFilter_Name(T enum_t_value) {
    static_assert(::std::is_same<T, IRLSWeightFilter>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function IRLSWeightFilter_Name.");
    return MotionEstimationOptions_IRLSWeightFilter_Name(enum_t_value);
  }
  static inline bool IRLSWeightFilter_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      IRLSWeightFilter* value) {
    return MotionEstimationOptions_IRLSWeightFilter_Parse(name, value);
  }

  typedef MotionEstimationOptions_HomographyIrlsWeightInitialization HomographyIrlsWeightInitialization;
  static constexpr HomographyIrlsWeightInitialization IRLS_WEIGHT_CONSTANT_ONE =
    MotionEstimationOptions_HomographyIrlsWeightInitialization_IRLS_WEIGHT_CONSTANT_ONE;
  static constexpr HomographyIrlsWeightInitialization IRLS_WEIGHT_CENTER_GAUSSIAN =
    MotionEstimationOptions_HomographyIrlsWeightInitialization_IRLS_WEIGHT_CENTER_GAUSSIAN;
  static constexpr HomographyIrlsWeightInitialization IRLS_WEIGHT_PERIMETER_GAUSSIAN =
    MotionEstimationOptions_HomographyIrlsWeightInitialization_IRLS_WEIGHT_PERIMETER_GAUSSIAN;
  static inline bool HomographyIrlsWeightInitialization_IsValid(int value) {
    return MotionEstimationOptions_HomographyIrlsWeightInitialization_IsValid(value);
  }
  static constexpr HomographyIrlsWeightInitialization HomographyIrlsWeightInitialization_MIN =
    MotionEstimationOptions_HomographyIrlsWeightInitialization_HomographyIrlsWeightInitialization_MIN;
  static constexpr HomographyIrlsWeightInitialization HomographyIrlsWeightInitialization_MAX =
    MotionEstimationOptions_HomographyIrlsWeightInitialization_HomographyIrlsWeightInitialization_MAX;
  static constexpr int HomographyIrlsWeightInitialization_ARRAYSIZE =
    MotionEstimationOptions_HomographyIrlsWeightInitialization_HomographyIrlsWeightInitialization_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  HomographyIrlsWeightInitialization_descriptor() {
    return MotionEstimationOptions_HomographyIrlsWeightInitialization_descriptor();
  }
  template<typename T>
  static inline const std::string& HomographyIrlsWeightInitialization_Name(T enum_t_value) {
    static_assert(::std::is_same<T, HomographyIrlsWeightInitialization>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function HomographyIrlsWeightInitialization_Name.");
    return MotionEstimationOptions_HomographyIrlsWeightInitialization_Name(enum_t_value);
  }
  static inline bool HomographyIrlsWeightInitialization_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      HomographyIrlsWeightInitialization* value) {
    return MotionEstimationOptions_HomographyIrlsWeightInitialization_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStableHomographyBoundsFieldNumber = 11,
    kStableTranslationBoundsFieldNumber = 32,
    kStableSimilarityBoundsFieldNumber = 33,
    kStableMixtureHomographyBoundsFieldNumber = 34,
    kOverlayDetectionOptionsFieldNumber = 38,
    kIrlsInitializationFieldNumber = 56,
    kIrlsMaskOptionsFieldNumber = 57,
    kJointTrackEstimationFieldNumber = 59,
    kShotBoundaryOptionsFieldNumber = 60,
    kLongFeatureBiasOptionsFieldNumber = 64,
    kLongFeatureInitializationFieldNumber = 66,
    kMixHomographyEstimationFieldNumber = 12,
    kProjectValidMotionsDownFieldNumber = 52,
    kEstimateSimilarityFieldNumber = 2,
    kAffineEstimationFieldNumber = 30,
    kIrlsWeightFilterFieldNumber = 35,
    kFilter5TapsFieldNumber = 29,
    kOverlayDetectionFieldNumber = 36,
    kDomainLimitedIrlsScalingFieldNumber = 65,
    kDeactivateStableMotionEstimationFieldNumber = 47,
    kHomographyExactDenominatorScalingFieldNumber = 53,
    kIrlsWeightsPreinitializedFieldNumber = 39,
    kFilterInitializedIrlsWeightsFieldNumber = 67,
    kFeatureDensityNormalizationFieldNumber = 62,
    kHomographyPerspectiveRegularizerFieldNumber = 61,
    kLinearSimilarityEstimationFieldNumber = 3,
    kHomographyEstimationFieldNumber = 5,
    kNumMixturesFieldNumber = 13,
    kMixtureRowSigmaFieldNumber = 14,
    kMixtureRegularizerFieldNumber = 15,
    kIrlsRoundsFieldNumber = 17,
    kLinSimInlierThresholdFieldNumber = 20,
    kMixtureModelModeFieldNumber = 23,
    kFeatureGridSizeFieldNumber = 24,
    kSpatialSigmaFieldNumber = 25,
    kTemporalIrlsDiameterFieldNumber = 26,
    kTemporalSigmaFieldNumber = 27,
    kFeatureSigmaFieldNumber = 28,
    kEstimateTranslationIrlsFieldNumber = 1,
    kUseExactHomographyEstimationFieldNumber = 54,
    kUseHighestAccuracyForNormalEquationsFieldNumber = 55,
    kUseOnlyLinSimInliersForHomographyFieldNumber = 6,
    kIrlsMotionMagnitudeFractionFieldNumber = 31,
    kOverlayAnalysisChunkSizeFieldNumber = 37,
    kLabelEmptyFramesAsValidFieldNumber = 22,
    kFrameConfidenceWeightingFieldNumber = 48,
    kOutputRefinedIrlsWeightsFieldNumber = 40,
    kIrlsUseL0NormFieldNumber = 46,
    kStrictCoverageScaleFieldNumber = 41,
    kMixtureRegularizerLevelsFieldNumber = 42,
    kMixtureRegularizerBaseFieldNumber = 43,
    kMixtureRsAnalysisLevelFieldNumber = 44,
    kHomographyIrlsWeightInitializationFieldNumber = 45,
    kResetConfidenceThresholdFieldNumber = 49,
    kIrlsPriorScaleFieldNumber = 50,
    kCoverageGridSizeFieldNumber = 51,
    kEstimationPolicyFieldNumber = 58,
    kFeatureMaskSizeFieldNumber = 63,
    kIrlsMixtureFractionScaleFieldNumber = 68,
  };
  // optional .mediapipe.MotionEstimationOptions.HomographyBounds stable_homography_bounds = 11;
  bool has_stable_homography_bounds() const;
  private:
  bool _internal_has_stable_homography_bounds() const;
  public:
  void clear_stable_homography_bounds();
  const ::mediapipe::MotionEstimationOptions_HomographyBounds& stable_homography_bounds() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::mediapipe::MotionEstimationOptions_HomographyBounds* release_stable_homography_bounds();
  ::mediapipe::MotionEstimationOptions_HomographyBounds* mutable_stable_homography_bounds();
  void set_allocated_stable_homography_bounds(::mediapipe::MotionEstimationOptions_HomographyBounds* stable_homography_bounds);
  private:
  const ::mediapipe::MotionEstimationOptions_HomographyBounds& _internal_stable_homography_bounds() const;
  ::mediapipe::MotionEstimationOptions_HomographyBounds* _internal_mutable_stable_homography_bounds();
  public:
  void unsafe_arena_set_allocated_stable_homography_bounds(
      ::mediapipe::MotionEstimationOptions_HomographyBounds* stable_homography_bounds);
  ::mediapipe::MotionEstimationOptions_HomographyBounds* unsafe_arena_release_stable_homography_bounds();

  // optional .mediapipe.MotionEstimationOptions.TranslationBounds stable_translation_bounds = 32;
  bool has_stable_translation_bounds() const;
  private:
  bool _internal_has_stable_translation_bounds() const;
  public:
  void clear_stable_translation_bounds();
  const ::mediapipe::MotionEstimationOptions_TranslationBounds& stable_translation_bounds() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::mediapipe::MotionEstimationOptions_TranslationBounds* release_stable_translation_bounds();
  ::mediapipe::MotionEstimationOptions_TranslationBounds* mutable_stable_translation_bounds();
  void set_allocated_stable_translation_bounds(::mediapipe::MotionEstimationOptions_TranslationBounds* stable_translation_bounds);
  private:
  const ::mediapipe::MotionEstimationOptions_TranslationBounds& _internal_stable_translation_bounds() const;
  ::mediapipe::MotionEstimationOptions_TranslationBounds* _internal_mutable_stable_translation_bounds();
  public:
  void unsafe_arena_set_allocated_stable_translation_bounds(
      ::mediapipe::MotionEstimationOptions_TranslationBounds* stable_translation_bounds);
  ::mediapipe::MotionEstimationOptions_TranslationBounds* unsafe_arena_release_stable_translation_bounds();

  // optional .mediapipe.MotionEstimationOptions.SimilarityBounds stable_similarity_bounds = 33;
  bool has_stable_similarity_bounds() const;
  private:
  bool _internal_has_stable_similarity_bounds() const;
  public:
  void clear_stable_similarity_bounds();
  const ::mediapipe::MotionEstimationOptions_SimilarityBounds& stable_similarity_bounds() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::mediapipe::MotionEstimationOptions_SimilarityBounds* release_stable_similarity_bounds();
  ::mediapipe::MotionEstimationOptions_SimilarityBounds* mutable_stable_similarity_bounds();
  void set_allocated_stable_similarity_bounds(::mediapipe::MotionEstimationOptions_SimilarityBounds* stable_similarity_bounds);
  private:
  const ::mediapipe::MotionEstimationOptions_SimilarityBounds& _internal_stable_similarity_bounds() const;
  ::mediapipe::MotionEstimationOptions_SimilarityBounds* _internal_mutable_stable_similarity_bounds();
  public:
  void unsafe_arena_set_allocated_stable_similarity_bounds(
      ::mediapipe::MotionEstimationOptions_SimilarityBounds* stable_similarity_bounds);
  ::mediapipe::MotionEstimationOptions_SimilarityBounds* unsafe_arena_release_stable_similarity_bounds();

  // optional .mediapipe.MotionEstimationOptions.MixtureHomographyBounds stable_mixture_homography_bounds = 34;
  bool has_stable_mixture_homography_bounds() const;
  private:
  bool _internal_has_stable_mixture_homography_bounds() const;
  public:
  void clear_stable_mixture_homography_bounds();
  const ::mediapipe::MotionEstimationOptions_MixtureHomographyBounds& stable_mixture_homography_bounds() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::mediapipe::MotionEstimationOptions_MixtureHomographyBounds* release_stable_mixture_homography_bounds();
  ::mediapipe::MotionEstimationOptions_MixtureHomographyBounds* mutable_stable_mixture_homography_bounds();
  void set_allocated_stable_mixture_homography_bounds(::mediapipe::MotionEstimationOptions_MixtureHomographyBounds* stable_mixture_homography_bounds);
  private:
  const ::mediapipe::MotionEstimationOptions_MixtureHomographyBounds& _internal_stable_mixture_homography_bounds() const;
  ::mediapipe::MotionEstimationOptions_MixtureHomographyBounds* _internal_mutable_stable_mixture_homography_bounds();
  public:
  void unsafe_arena_set_allocated_stable_mixture_homography_bounds(
      ::mediapipe::MotionEstimationOptions_MixtureHomographyBounds* stable_mixture_homography_bounds);
  ::mediapipe::MotionEstimationOptions_MixtureHomographyBounds* unsafe_arena_release_stable_mixture_homography_bounds();

  // optional .mediapipe.MotionEstimationOptions.OverlayDetectionOptions overlay_detection_options = 38;
  bool has_overlay_detection_options() const;
  private:
  bool _internal_has_overlay_detection_options() const;
  public:
  void clear_overlay_detection_options();
  const ::mediapipe::MotionEstimationOptions_OverlayDetectionOptions& overlay_detection_options() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::mediapipe::MotionEstimationOptions_OverlayDetectionOptions* release_overlay_detection_options();
  ::mediapipe::MotionEstimationOptions_OverlayDetectionOptions* mutable_overlay_detection_options();
  void set_allocated_overlay_detection_options(::mediapipe::MotionEstimationOptions_OverlayDetectionOptions* overlay_detection_options);
  private:
  const ::mediapipe::MotionEstimationOptions_OverlayDetectionOptions& _internal_overlay_detection_options() const;
  ::mediapipe::MotionEstimationOptions_OverlayDetectionOptions* _internal_mutable_overlay_detection_options();
  public:
  void unsafe_arena_set_allocated_overlay_detection_options(
      ::mediapipe::MotionEstimationOptions_OverlayDetectionOptions* overlay_detection_options);
  ::mediapipe::MotionEstimationOptions_OverlayDetectionOptions* unsafe_arena_release_overlay_detection_options();

  // optional .mediapipe.MotionEstimationOptions.IrlsOutlierInitialization irls_initialization = 56;
  bool has_irls_initialization() const;
  private:
  bool _internal_has_irls_initialization() const;
  public:
  void clear_irls_initialization();
  const ::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization& irls_initialization() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization* release_irls_initialization();
  ::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization* mutable_irls_initialization();
  void set_allocated_irls_initialization(::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization* irls_initialization);
  private:
  const ::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization& _internal_irls_initialization() const;
  ::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization* _internal_mutable_irls_initialization();
  public:
  void unsafe_arena_set_allocated_irls_initialization(
      ::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization* irls_initialization);
  ::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization* unsafe_arena_release_irls_initialization();

  // optional .mediapipe.MotionEstimationOptions.IrlsMaskOptions irls_mask_options = 57;
  bool has_irls_mask_options() const;
  private:
  bool _internal_has_irls_mask_options() const;
  public:
  void clear_irls_mask_options();
  const ::mediapipe::MotionEstimationOptions_IrlsMaskOptions& irls_mask_options() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::mediapipe::MotionEstimationOptions_IrlsMaskOptions* release_irls_mask_options();
  ::mediapipe::MotionEstimationOptions_IrlsMaskOptions* mutable_irls_mask_options();
  void set_allocated_irls_mask_options(::mediapipe::MotionEstimationOptions_IrlsMaskOptions* irls_mask_options);
  private:
  const ::mediapipe::MotionEstimationOptions_IrlsMaskOptions& _internal_irls_mask_options() const;
  ::mediapipe::MotionEstimationOptions_IrlsMaskOptions* _internal_mutable_irls_mask_options();
  public:
  void unsafe_arena_set_allocated_irls_mask_options(
      ::mediapipe::MotionEstimationOptions_IrlsMaskOptions* irls_mask_options);
  ::mediapipe::MotionEstimationOptions_IrlsMaskOptions* unsafe_arena_release_irls_mask_options();

  // optional .mediapipe.MotionEstimationOptions.JointTrackEstimationOptions joint_track_estimation = 59;
  bool has_joint_track_estimation() const;
  private:
  bool _internal_has_joint_track_estimation() const;
  public:
  void clear_joint_track_estimation();
  const ::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions& joint_track_estimation() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions* release_joint_track_estimation();
  ::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions* mutable_joint_track_estimation();
  void set_allocated_joint_track_estimation(::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions* joint_track_estimation);
  private:
  const ::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions& _internal_joint_track_estimation() const;
  ::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions* _internal_mutable_joint_track_estimation();
  public:
  void unsafe_arena_set_allocated_joint_track_estimation(
      ::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions* joint_track_estimation);
  ::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions* unsafe_arena_release_joint_track_estimation();

  // optional .mediapipe.MotionEstimationOptions.ShotBoundaryOptions shot_boundary_options = 60;
  bool has_shot_boundary_options() const;
  private:
  bool _internal_has_shot_boundary_options() const;
  public:
  void clear_shot_boundary_options();
  const ::mediapipe::MotionEstimationOptions_ShotBoundaryOptions& shot_boundary_options() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::mediapipe::MotionEstimationOptions_ShotBoundaryOptions* release_shot_boundary_options();
  ::mediapipe::MotionEstimationOptions_ShotBoundaryOptions* mutable_shot_boundary_options();
  void set_allocated_shot_boundary_options(::mediapipe::MotionEstimationOptions_ShotBoundaryOptions* shot_boundary_options);
  private:
  const ::mediapipe::MotionEstimationOptions_ShotBoundaryOptions& _internal_shot_boundary_options() const;
  ::mediapipe::MotionEstimationOptions_ShotBoundaryOptions* _internal_mutable_shot_boundary_options();
  public:
  void unsafe_arena_set_allocated_shot_boundary_options(
      ::mediapipe::MotionEstimationOptions_ShotBoundaryOptions* shot_boundary_options);
  ::mediapipe::MotionEstimationOptions_ShotBoundaryOptions* unsafe_arena_release_shot_boundary_options();

  // optional .mediapipe.MotionEstimationOptions.LongFeatureBiasOptions long_feature_bias_options = 64;
  bool has_long_feature_bias_options() const;
  private:
  bool _internal_has_long_feature_bias_options() const;
  public:
  void clear_long_feature_bias_options();
  const ::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions& long_feature_bias_options() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions* release_long_feature_bias_options();
  ::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions* mutable_long_feature_bias_options();
  void set_allocated_long_feature_bias_options(::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions* long_feature_bias_options);
  private:
  const ::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions& _internal_long_feature_bias_options() const;
  ::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions* _internal_mutable_long_feature_bias_options();
  public:
  void unsafe_arena_set_allocated_long_feature_bias_options(
      ::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions* long_feature_bias_options);
  ::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions* unsafe_arena_release_long_feature_bias_options();

  // optional .mediapipe.MotionEstimationOptions.LongFeatureInitialization long_feature_initialization = 66;
  bool has_long_feature_initialization() const;
  private:
  bool _internal_has_long_feature_initialization() const;
  public:
  void clear_long_feature_initialization();
  const ::mediapipe::MotionEstimationOptions_LongFeatureInitialization& long_feature_initialization() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::mediapipe::MotionEstimationOptions_LongFeatureInitialization* release_long_feature_initialization();
  ::mediapipe::MotionEstimationOptions_LongFeatureInitialization* mutable_long_feature_initialization();
  void set_allocated_long_feature_initialization(::mediapipe::MotionEstimationOptions_LongFeatureInitialization* long_feature_initialization);
  private:
  const ::mediapipe::MotionEstimationOptions_LongFeatureInitialization& _internal_long_feature_initialization() const;
  ::mediapipe::MotionEstimationOptions_LongFeatureInitialization* _internal_mutable_long_feature_initialization();
  public:
  void unsafe_arena_set_allocated_long_feature_initialization(
      ::mediapipe::MotionEstimationOptions_LongFeatureInitialization* long_feature_initialization);
  ::mediapipe::MotionEstimationOptions_LongFeatureInitialization* unsafe_arena_release_long_feature_initialization();

  // optional .mediapipe.MotionEstimationOptions.MixtureHomographyEstimation mix_homography_estimation = 12 [default = ESTIMATION_HOMOG_MIX_NONE];
  bool has_mix_homography_estimation() const;
  private:
  bool _internal_has_mix_homography_estimation() const;
  public:
  void clear_mix_homography_estimation();
  ::mediapipe::MotionEstimationOptions_MixtureHomographyEstimation mix_homography_estimation() const;
  void set_mix_homography_estimation(::mediapipe::MotionEstimationOptions_MixtureHomographyEstimation value);
  private:
  ::mediapipe::MotionEstimationOptions_MixtureHomographyEstimation _internal_mix_homography_estimation() const;
  void _internal_set_mix_homography_estimation(::mediapipe::MotionEstimationOptions_MixtureHomographyEstimation value);
  public:

  // optional bool project_valid_motions_down = 52 [default = false];
  bool has_project_valid_motions_down() const;
  private:
  bool _internal_has_project_valid_motions_down() const;
  public:
  void clear_project_valid_motions_down();
  bool project_valid_motions_down() const;
  void set_project_valid_motions_down(bool value);
  private:
  bool _internal_project_valid_motions_down() const;
  void _internal_set_project_valid_motions_down(bool value);
  public:

  // optional bool estimate_similarity = 2 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_estimate_similarity() const;
  private:
  bool _internal_has_estimate_similarity() const;
  public:
  PROTOBUF_DEPRECATED void clear_estimate_similarity();
  PROTOBUF_DEPRECATED bool estimate_similarity() const;
  PROTOBUF_DEPRECATED void set_estimate_similarity(bool value);
  private:
  bool _internal_estimate_similarity() const;
  void _internal_set_estimate_similarity(bool value);
  public:

  // optional .mediapipe.MotionEstimationOptions.AffineEstimation affine_estimation = 30 [default = ESTIMATION_AFFINE_NONE];
  bool has_affine_estimation() const;
  private:
  bool _internal_has_affine_estimation() const;
  public:
  void clear_affine_estimation();
  ::mediapipe::MotionEstimationOptions_AffineEstimation affine_estimation() const;
  void set_affine_estimation(::mediapipe::MotionEstimationOptions_AffineEstimation value);
  private:
  ::mediapipe::MotionEstimationOptions_AffineEstimation _internal_affine_estimation() const;
  void _internal_set_affine_estimation(::mediapipe::MotionEstimationOptions_AffineEstimation value);
  public:

  // optional .mediapipe.MotionEstimationOptions.IRLSWeightFilter irls_weight_filter = 35 [default = IRLS_FILTER_NONE];
  bool has_irls_weight_filter() const;
  private:
  bool _internal_has_irls_weight_filter() const;
  public:
  void clear_irls_weight_filter();
  ::mediapipe::MotionEstimationOptions_IRLSWeightFilter irls_weight_filter() const;
  void set_irls_weight_filter(::mediapipe::MotionEstimationOptions_IRLSWeightFilter value);
  private:
  ::mediapipe::MotionEstimationOptions_IRLSWeightFilter _internal_irls_weight_filter() const;
  void _internal_set_irls_weight_filter(::mediapipe::MotionEstimationOptions_IRLSWeightFilter value);
  public:

  // optional bool filter_5_taps = 29 [default = false];
  bool has_filter_5_taps() const;
  private:
  bool _internal_has_filter_5_taps() const;
  public:
  void clear_filter_5_taps();
  bool filter_5_taps() const;
  void set_filter_5_taps(bool value);
  private:
  bool _internal_filter_5_taps() const;
  void _internal_set_filter_5_taps(bool value);
  public:

  // optional bool overlay_detection = 36 [default = false];
  bool has_overlay_detection() const;
  private:
  bool _internal_has_overlay_detection() const;
  public:
  void clear_overlay_detection();
  bool overlay_detection() const;
  void set_overlay_detection(bool value);
  private:
  bool _internal_overlay_detection() const;
  void _internal_set_overlay_detection(bool value);
  public:

  // optional bool domain_limited_irls_scaling = 65 [default = false];
  bool has_domain_limited_irls_scaling() const;
  private:
  bool _internal_has_domain_limited_irls_scaling() const;
  public:
  void clear_domain_limited_irls_scaling();
  bool domain_limited_irls_scaling() const;
  void set_domain_limited_irls_scaling(bool value);
  private:
  bool _internal_domain_limited_irls_scaling() const;
  void _internal_set_domain_limited_irls_scaling(bool value);
  public:

  // optional bool deactivate_stable_motion_estimation = 47 [default = false];
  bool has_deactivate_stable_motion_estimation() const;
  private:
  bool _internal_has_deactivate_stable_motion_estimation() const;
  public:
  void clear_deactivate_stable_motion_estimation();
  bool deactivate_stable_motion_estimation() const;
  void set_deactivate_stable_motion_estimation(bool value);
  private:
  bool _internal_deactivate_stable_motion_estimation() const;
  void _internal_set_deactivate_stable_motion_estimation(bool value);
  public:

  // optional bool homography_exact_denominator_scaling = 53 [default = false];
  bool has_homography_exact_denominator_scaling() const;
  private:
  bool _internal_has_homography_exact_denominator_scaling() const;
  public:
  void clear_homography_exact_denominator_scaling();
  bool homography_exact_denominator_scaling() const;
  void set_homography_exact_denominator_scaling(bool value);
  private:
  bool _internal_homography_exact_denominator_scaling() const;
  void _internal_set_homography_exact_denominator_scaling(bool value);
  public:

  // optional bool irls_weights_preinitialized = 39 [default = false];
  bool has_irls_weights_preinitialized() const;
  private:
  bool _internal_has_irls_weights_preinitialized() const;
  public:
  void clear_irls_weights_preinitialized();
  bool irls_weights_preinitialized() const;
  void set_irls_weights_preinitialized(bool value);
  private:
  bool _internal_irls_weights_preinitialized() const;
  void _internal_set_irls_weights_preinitialized(bool value);
  public:

  // optional bool filter_initialized_irls_weights = 67 [default = false];
  bool has_filter_initialized_irls_weights() const;
  private:
  bool _internal_has_filter_initialized_irls_weights() const;
  public:
  void clear_filter_initialized_irls_weights();
  bool filter_initialized_irls_weights() const;
  void set_filter_initialized_irls_weights(bool value);
  private:
  bool _internal_filter_initialized_irls_weights() const;
  void _internal_set_filter_initialized_irls_weights(bool value);
  public:

  // optional bool feature_density_normalization = 62 [default = false];
  bool has_feature_density_normalization() const;
  private:
  bool _internal_has_feature_density_normalization() const;
  public:
  void clear_feature_density_normalization();
  bool feature_density_normalization() const;
  void set_feature_density_normalization(bool value);
  private:
  bool _internal_feature_density_normalization() const;
  void _internal_set_feature_density_normalization(bool value);
  public:

  // optional float homography_perspective_regularizer = 61 [default = 0];
  bool has_homography_perspective_regularizer() const;
  private:
  bool _internal_has_homography_perspective_regularizer() const;
  public:
  void clear_homography_perspective_regularizer();
  float homography_perspective_regularizer() const;
  void set_homography_perspective_regularizer(float value);
  private:
  float _internal_homography_perspective_regularizer() const;
  void _internal_set_homography_perspective_regularizer(float value);
  public:

  // optional .mediapipe.MotionEstimationOptions.LinearSimilarityEstimation linear_similarity_estimation = 3 [default = ESTIMATION_LS_IRLS];
  bool has_linear_similarity_estimation() const;
  private:
  bool _internal_has_linear_similarity_estimation() const;
  public:
  void clear_linear_similarity_estimation();
  ::mediapipe::MotionEstimationOptions_LinearSimilarityEstimation linear_similarity_estimation() const;
  void set_linear_similarity_estimation(::mediapipe::MotionEstimationOptions_LinearSimilarityEstimation value);
  private:
  ::mediapipe::MotionEstimationOptions_LinearSimilarityEstimation _internal_linear_similarity_estimation() const;
  void _internal_set_linear_similarity_estimation(::mediapipe::MotionEstimationOptions_LinearSimilarityEstimation value);
  public:

  // optional .mediapipe.MotionEstimationOptions.HomographyEstimation homography_estimation = 5 [default = ESTIMATION_HOMOG_IRLS];
  bool has_homography_estimation() const;
  private:
  bool _internal_has_homography_estimation() const;
  public:
  void clear_homography_estimation();
  ::mediapipe::MotionEstimationOptions_HomographyEstimation homography_estimation() const;
  void set_homography_estimation(::mediapipe::MotionEstimationOptions_HomographyEstimation value);
  private:
  ::mediapipe::MotionEstimationOptions_HomographyEstimation _internal_homography_estimation() const;
  void _internal_set_homography_estimation(::mediapipe::MotionEstimationOptions_HomographyEstimation value);
  public:

  // optional int32 num_mixtures = 13 [default = 10];
  bool has_num_mixtures() const;
  private:
  bool _internal_has_num_mixtures() const;
  public:
  void clear_num_mixtures();
  ::PROTOBUF_NAMESPACE_ID::int32 num_mixtures() const;
  void set_num_mixtures(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_mixtures() const;
  void _internal_set_num_mixtures(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional float mixture_row_sigma = 14 [default = 0.1];
  bool has_mixture_row_sigma() const;
  private:
  bool _internal_has_mixture_row_sigma() const;
  public:
  void clear_mixture_row_sigma();
  float mixture_row_sigma() const;
  void set_mixture_row_sigma(float value);
  private:
  float _internal_mixture_row_sigma() const;
  void _internal_set_mixture_row_sigma(float value);
  public:

  // optional float mixture_regularizer = 15 [default = 0.0001];
  bool has_mixture_regularizer() const;
  private:
  bool _internal_has_mixture_regularizer() const;
  public:
  void clear_mixture_regularizer();
  float mixture_regularizer() const;
  void set_mixture_regularizer(float value);
  private:
  float _internal_mixture_regularizer() const;
  void _internal_set_mixture_regularizer(float value);
  public:

  // optional int32 irls_rounds = 17 [default = 10];
  bool has_irls_rounds() const;
  private:
  bool _internal_has_irls_rounds() const;
  public:
  void clear_irls_rounds();
  ::PROTOBUF_NAMESPACE_ID::int32 irls_rounds() const;
  void set_irls_rounds(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_irls_rounds() const;
  void _internal_set_irls_rounds(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional float lin_sim_inlier_threshold = 20 [default = 0.003];
  bool has_lin_sim_inlier_threshold() const;
  private:
  bool _internal_has_lin_sim_inlier_threshold() const;
  public:
  void clear_lin_sim_inlier_threshold();
  float lin_sim_inlier_threshold() const;
  void set_lin_sim_inlier_threshold(float value);
  private:
  float _internal_lin_sim_inlier_threshold() const;
  void _internal_set_lin_sim_inlier_threshold(float value);
  public:

  // optional .mediapipe.MotionEstimationOptions.MixtureModelMode mixture_model_mode = 23 [default = SKEW_ROTATION_MIXTURE];
  bool has_mixture_model_mode() const;
  private:
  bool _internal_has_mixture_model_mode() const;
  public:
  void clear_mixture_model_mode();
  ::mediapipe::MotionEstimationOptions_MixtureModelMode mixture_model_mode() const;
  void set_mixture_model_mode(::mediapipe::MotionEstimationOptions_MixtureModelMode value);
  private:
  ::mediapipe::MotionEstimationOptions_MixtureModelMode _internal_mixture_model_mode() const;
  void _internal_set_mixture_model_mode(::mediapipe::MotionEstimationOptions_MixtureModelMode value);
  public:

  // optional float feature_grid_size = 24 [default = 0.05];
  bool has_feature_grid_size() const;
  private:
  bool _internal_has_feature_grid_size() const;
  public:
  void clear_feature_grid_size();
  float feature_grid_size() const;
  void set_feature_grid_size(float value);
  private:
  float _internal_feature_grid_size() const;
  void _internal_set_feature_grid_size(float value);
  public:

  // optional float spatial_sigma = 25 [default = 0.01];
  bool has_spatial_sigma() const;
  private:
  bool _internal_has_spatial_sigma() const;
  public:
  void clear_spatial_sigma();
  float spatial_sigma() const;
  void set_spatial_sigma(float value);
  private:
  float _internal_spatial_sigma() const;
  void _internal_set_spatial_sigma(float value);
  public:

  // optional int32 temporal_irls_diameter = 26 [default = 20];
  bool has_temporal_irls_diameter() const;
  private:
  bool _internal_has_temporal_irls_diameter() const;
  public:
  void clear_temporal_irls_diameter();
  ::PROTOBUF_NAMESPACE_ID::int32 temporal_irls_diameter() const;
  void set_temporal_irls_diameter(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_temporal_irls_diameter() const;
  void _internal_set_temporal_irls_diameter(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional float temporal_sigma = 27 [default = 5];
  bool has_temporal_sigma() const;
  private:
  bool _internal_has_temporal_sigma() const;
  public:
  void clear_temporal_sigma();
  float temporal_sigma() const;
  void set_temporal_sigma(float value);
  private:
  float _internal_temporal_sigma() const;
  void _internal_set_temporal_sigma(float value);
  public:

  // optional float feature_sigma = 28 [default = 30];
  bool has_feature_sigma() const;
  private:
  bool _internal_has_feature_sigma() const;
  public:
  void clear_feature_sigma();
  float feature_sigma() const;
  void set_feature_sigma(float value);
  private:
  float _internal_feature_sigma() const;
  void _internal_set_feature_sigma(float value);
  public:

  // optional bool estimate_translation_irls = 1 [default = true];
  bool has_estimate_translation_irls() const;
  private:
  bool _internal_has_estimate_translation_irls() const;
  public:
  void clear_estimate_translation_irls();
  bool estimate_translation_irls() const;
  void set_estimate_translation_irls(bool value);
  private:
  bool _internal_estimate_translation_irls() const;
  void _internal_set_estimate_translation_irls(bool value);
  public:

  // optional bool use_exact_homography_estimation = 54 [default = true];
  bool has_use_exact_homography_estimation() const;
  private:
  bool _internal_has_use_exact_homography_estimation() const;
  public:
  void clear_use_exact_homography_estimation();
  bool use_exact_homography_estimation() const;
  void set_use_exact_homography_estimation(bool value);
  private:
  bool _internal_use_exact_homography_estimation() const;
  void _internal_set_use_exact_homography_estimation(bool value);
  public:

  // optional bool use_highest_accuracy_for_normal_equations = 55 [default = true];
  bool has_use_highest_accuracy_for_normal_equations() const;
  private:
  bool _internal_has_use_highest_accuracy_for_normal_equations() const;
  public:
  void clear_use_highest_accuracy_for_normal_equations();
  bool use_highest_accuracy_for_normal_equations() const;
  void set_use_highest_accuracy_for_normal_equations(bool value);
  private:
  bool _internal_use_highest_accuracy_for_normal_equations() const;
  void _internal_set_use_highest_accuracy_for_normal_equations(bool value);
  public:

  // optional bool use_only_lin_sim_inliers_for_homography = 6 [default = true];
  bool has_use_only_lin_sim_inliers_for_homography() const;
  private:
  bool _internal_has_use_only_lin_sim_inliers_for_homography() const;
  public:
  void clear_use_only_lin_sim_inliers_for_homography();
  bool use_only_lin_sim_inliers_for_homography() const;
  void set_use_only_lin_sim_inliers_for_homography(bool value);
  private:
  bool _internal_use_only_lin_sim_inliers_for_homography() const;
  void _internal_set_use_only_lin_sim_inliers_for_homography(bool value);
  public:

  // optional float irls_motion_magnitude_fraction = 31 [default = 0.08];
  bool has_irls_motion_magnitude_fraction() const;
  private:
  bool _internal_has_irls_motion_magnitude_fraction() const;
  public:
  void clear_irls_motion_magnitude_fraction();
  float irls_motion_magnitude_fraction() const;
  void set_irls_motion_magnitude_fraction(float value);
  private:
  float _internal_irls_motion_magnitude_fraction() const;
  void _internal_set_irls_motion_magnitude_fraction(float value);
  public:

  // optional int32 overlay_analysis_chunk_size = 37 [default = 8];
  bool has_overlay_analysis_chunk_size() const;
  private:
  bool _internal_has_overlay_analysis_chunk_size() const;
  public:
  void clear_overlay_analysis_chunk_size();
  ::PROTOBUF_NAMESPACE_ID::int32 overlay_analysis_chunk_size() const;
  void set_overlay_analysis_chunk_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_overlay_analysis_chunk_size() const;
  void _internal_set_overlay_analysis_chunk_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool label_empty_frames_as_valid = 22 [default = true];
  bool has_label_empty_frames_as_valid() const;
  private:
  bool _internal_has_label_empty_frames_as_valid() const;
  public:
  void clear_label_empty_frames_as_valid();
  bool label_empty_frames_as_valid() const;
  void set_label_empty_frames_as_valid(bool value);
  private:
  bool _internal_label_empty_frames_as_valid() const;
  void _internal_set_label_empty_frames_as_valid(bool value);
  public:

  // optional bool frame_confidence_weighting = 48 [default = true];
  bool has_frame_confidence_weighting() const;
  private:
  bool _internal_has_frame_confidence_weighting() const;
  public:
  void clear_frame_confidence_weighting();
  bool frame_confidence_weighting() const;
  void set_frame_confidence_weighting(bool value);
  private:
  bool _internal_frame_confidence_weighting() const;
  void _internal_set_frame_confidence_weighting(bool value);
  public:

  // optional bool output_refined_irls_weights = 40 [default = true];
  bool has_output_refined_irls_weights() const;
  private:
  bool _internal_has_output_refined_irls_weights() const;
  public:
  void clear_output_refined_irls_weights();
  bool output_refined_irls_weights() const;
  void set_output_refined_irls_weights(bool value);
  private:
  bool _internal_output_refined_irls_weights() const;
  void _internal_set_output_refined_irls_weights(bool value);
  public:

  // optional bool irls_use_l0_norm = 46 [default = true];
  bool has_irls_use_l0_norm() const;
  private:
  bool _internal_has_irls_use_l0_norm() const;
  public:
  void clear_irls_use_l0_norm();
  bool irls_use_l0_norm() const;
  void set_irls_use_l0_norm(bool value);
  private:
  bool _internal_irls_use_l0_norm() const;
  void _internal_set_irls_use_l0_norm(bool value);
  public:

  // optional float strict_coverage_scale = 41 [default = 1.333];
  bool has_strict_coverage_scale() const;
  private:
  bool _internal_has_strict_coverage_scale() const;
  public:
  void clear_strict_coverage_scale();
  float strict_coverage_scale() const;
  void set_strict_coverage_scale(float value);
  private:
  float _internal_strict_coverage_scale() const;
  void _internal_set_strict_coverage_scale(float value);
  public:

  // optional float mixture_regularizer_levels = 42 [default = 3];
  bool has_mixture_regularizer_levels() const;
  private:
  bool _internal_has_mixture_regularizer_levels() const;
  public:
  void clear_mixture_regularizer_levels();
  float mixture_regularizer_levels() const;
  void set_mixture_regularizer_levels(float value);
  private:
  float _internal_mixture_regularizer_levels() const;
  void _internal_set_mixture_regularizer_levels(float value);
  public:

  // optional float mixture_regularizer_base = 43 [default = 2.2];
  bool has_mixture_regularizer_base() const;
  private:
  bool _internal_has_mixture_regularizer_base() const;
  public:
  void clear_mixture_regularizer_base();
  float mixture_regularizer_base() const;
  void set_mixture_regularizer_base(float value);
  private:
  float _internal_mixture_regularizer_base() const;
  void _internal_set_mixture_regularizer_base(float value);
  public:

  // optional int32 mixture_rs_analysis_level = 44 [default = 2];
  bool has_mixture_rs_analysis_level() const;
  private:
  bool _internal_has_mixture_rs_analysis_level() const;
  public:
  void clear_mixture_rs_analysis_level();
  ::PROTOBUF_NAMESPACE_ID::int32 mixture_rs_analysis_level() const;
  void set_mixture_rs_analysis_level(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_mixture_rs_analysis_level() const;
  void _internal_set_mixture_rs_analysis_level(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional .mediapipe.MotionEstimationOptions.HomographyIrlsWeightInitialization homography_irls_weight_initialization = 45 [default = IRLS_WEIGHT_PERIMETER_GAUSSIAN];
  bool has_homography_irls_weight_initialization() const;
  private:
  bool _internal_has_homography_irls_weight_initialization() const;
  public:
  void clear_homography_irls_weight_initialization();
  ::mediapipe::MotionEstimationOptions_HomographyIrlsWeightInitialization homography_irls_weight_initialization() const;
  void set_homography_irls_weight_initialization(::mediapipe::MotionEstimationOptions_HomographyIrlsWeightInitialization value);
  private:
  ::mediapipe::MotionEstimationOptions_HomographyIrlsWeightInitialization _internal_homography_irls_weight_initialization() const;
  void _internal_set_homography_irls_weight_initialization(::mediapipe::MotionEstimationOptions_HomographyIrlsWeightInitialization value);
  public:

  // optional float reset_confidence_threshold = 49 [default = 0.4];
  bool has_reset_confidence_threshold() const;
  private:
  bool _internal_has_reset_confidence_threshold() const;
  public:
  void clear_reset_confidence_threshold();
  float reset_confidence_threshold() const;
  void set_reset_confidence_threshold(float value);
  private:
  float _internal_reset_confidence_threshold() const;
  void _internal_set_reset_confidence_threshold(float value);
  public:

  // optional float irls_prior_scale = 50 [default = 0.2];
  bool has_irls_prior_scale() const;
  private:
  bool _internal_has_irls_prior_scale() const;
  public:
  void clear_irls_prior_scale();
  float irls_prior_scale() const;
  void set_irls_prior_scale(float value);
  private:
  float _internal_irls_prior_scale() const;
  void _internal_set_irls_prior_scale(float value);
  public:

  // optional int32 coverage_grid_size = 51 [default = 10];
  bool has_coverage_grid_size() const;
  private:
  bool _internal_has_coverage_grid_size() const;
  public:
  void clear_coverage_grid_size();
  ::PROTOBUF_NAMESPACE_ID::int32 coverage_grid_size() const;
  void set_coverage_grid_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_coverage_grid_size() const;
  void _internal_set_coverage_grid_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional .mediapipe.MotionEstimationOptions.EstimationPolicy estimation_policy = 58 [default = INDEPENDENT_PARALLEL];
  bool has_estimation_policy() const;
  private:
  bool _internal_has_estimation_policy() const;
  public:
  void clear_estimation_policy();
  ::mediapipe::MotionEstimationOptions_EstimationPolicy estimation_policy() const;
  void set_estimation_policy(::mediapipe::MotionEstimationOptions_EstimationPolicy value);
  private:
  ::mediapipe::MotionEstimationOptions_EstimationPolicy _internal_estimation_policy() const;
  void _internal_set_estimation_policy(::mediapipe::MotionEstimationOptions_EstimationPolicy value);
  public:

  // optional int32 feature_mask_size = 63 [default = 10];
  bool has_feature_mask_size() const;
  private:
  bool _internal_has_feature_mask_size() const;
  public:
  void clear_feature_mask_size();
  ::PROTOBUF_NAMESPACE_ID::int32 feature_mask_size() const;
  void set_feature_mask_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_feature_mask_size() const;
  void _internal_set_feature_mask_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional float irls_mixture_fraction_scale = 68 [default = 1.5];
  bool has_irls_mixture_fraction_scale() const;
  private:
  bool _internal_has_irls_mixture_fraction_scale() const;
  public:
  void clear_irls_mixture_fraction_scale();
  float irls_mixture_fraction_scale() const;
  void set_irls_mixture_fraction_scale(float value);
  private:
  float _internal_irls_mixture_fraction_scale() const;
  void _internal_set_irls_mixture_fraction_scale(float value);
  public:

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(MotionEstimationOptions)
  // @@protoc_insertion_point(class_scope:mediapipe.MotionEstimationOptions)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::mediapipe::MotionEstimationOptions_HomographyBounds* stable_homography_bounds_;
  ::mediapipe::MotionEstimationOptions_TranslationBounds* stable_translation_bounds_;
  ::mediapipe::MotionEstimationOptions_SimilarityBounds* stable_similarity_bounds_;
  ::mediapipe::MotionEstimationOptions_MixtureHomographyBounds* stable_mixture_homography_bounds_;
  ::mediapipe::MotionEstimationOptions_OverlayDetectionOptions* overlay_detection_options_;
  ::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization* irls_initialization_;
  ::mediapipe::MotionEstimationOptions_IrlsMaskOptions* irls_mask_options_;
  ::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions* joint_track_estimation_;
  ::mediapipe::MotionEstimationOptions_ShotBoundaryOptions* shot_boundary_options_;
  ::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions* long_feature_bias_options_;
  ::mediapipe::MotionEstimationOptions_LongFeatureInitialization* long_feature_initialization_;
  int mix_homography_estimation_;
  bool project_valid_motions_down_;
  bool estimate_similarity_;
  int affine_estimation_;
  int irls_weight_filter_;
  bool filter_5_taps_;
  bool overlay_detection_;
  bool domain_limited_irls_scaling_;
  bool deactivate_stable_motion_estimation_;
  bool homography_exact_denominator_scaling_;
  bool irls_weights_preinitialized_;
  bool filter_initialized_irls_weights_;
  bool feature_density_normalization_;
  float homography_perspective_regularizer_;
  int linear_similarity_estimation_;
  int homography_estimation_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_mixtures_;
  float mixture_row_sigma_;
  float mixture_regularizer_;
  ::PROTOBUF_NAMESPACE_ID::int32 irls_rounds_;
  float lin_sim_inlier_threshold_;
  int mixture_model_mode_;
  float feature_grid_size_;
  float spatial_sigma_;
  ::PROTOBUF_NAMESPACE_ID::int32 temporal_irls_diameter_;
  float temporal_sigma_;
  float feature_sigma_;
  bool estimate_translation_irls_;
  bool use_exact_homography_estimation_;
  bool use_highest_accuracy_for_normal_equations_;
  bool use_only_lin_sim_inliers_for_homography_;
  float irls_motion_magnitude_fraction_;
  ::PROTOBUF_NAMESPACE_ID::int32 overlay_analysis_chunk_size_;
  bool label_empty_frames_as_valid_;
  bool frame_confidence_weighting_;
  bool output_refined_irls_weights_;
  bool irls_use_l0_norm_;
  float strict_coverage_scale_;
  float mixture_regularizer_levels_;
  float mixture_regularizer_base_;
  ::PROTOBUF_NAMESPACE_ID::int32 mixture_rs_analysis_level_;
  int homography_irls_weight_initialization_;
  float reset_confidence_threshold_;
  float irls_prior_scale_;
  ::PROTOBUF_NAMESPACE_ID::int32 coverage_grid_size_;
  int estimation_policy_;
  ::PROTOBUF_NAMESPACE_ID::int32 feature_mask_size_;
  float irls_mixture_fraction_scale_;
  friend struct ::TableStruct_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MotionEstimationOptions_IrlsOutlierInitialization

// optional bool activated = 1 [default = false];
inline bool MotionEstimationOptions_IrlsOutlierInitialization::_internal_has_activated() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MotionEstimationOptions_IrlsOutlierInitialization::has_activated() const {
  return _internal_has_activated();
}
inline void MotionEstimationOptions_IrlsOutlierInitialization::clear_activated() {
  activated_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool MotionEstimationOptions_IrlsOutlierInitialization::_internal_activated() const {
  return activated_;
}
inline bool MotionEstimationOptions_IrlsOutlierInitialization::activated() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.IrlsOutlierInitialization.activated)
  return _internal_activated();
}
inline void MotionEstimationOptions_IrlsOutlierInitialization::_internal_set_activated(bool value) {
  _has_bits_[0] |= 0x00000001u;
  activated_ = value;
}
inline void MotionEstimationOptions_IrlsOutlierInitialization::set_activated(bool value) {
  _internal_set_activated(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.IrlsOutlierInitialization.activated)
}

// optional int32 rounds = 2 [default = 100];
inline bool MotionEstimationOptions_IrlsOutlierInitialization::_internal_has_rounds() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MotionEstimationOptions_IrlsOutlierInitialization::has_rounds() const {
  return _internal_has_rounds();
}
inline void MotionEstimationOptions_IrlsOutlierInitialization::clear_rounds() {
  rounds_ = 100;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MotionEstimationOptions_IrlsOutlierInitialization::_internal_rounds() const {
  return rounds_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MotionEstimationOptions_IrlsOutlierInitialization::rounds() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.IrlsOutlierInitialization.rounds)
  return _internal_rounds();
}
inline void MotionEstimationOptions_IrlsOutlierInitialization::_internal_set_rounds(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  rounds_ = value;
}
inline void MotionEstimationOptions_IrlsOutlierInitialization::set_rounds(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rounds(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.IrlsOutlierInitialization.rounds)
}

// optional float cutoff = 3 [default = 0.003];
inline bool MotionEstimationOptions_IrlsOutlierInitialization::_internal_has_cutoff() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MotionEstimationOptions_IrlsOutlierInitialization::has_cutoff() const {
  return _internal_has_cutoff();
}
inline void MotionEstimationOptions_IrlsOutlierInitialization::clear_cutoff() {
  cutoff_ = 0.003f;
  _has_bits_[0] &= ~0x00000004u;
}
inline float MotionEstimationOptions_IrlsOutlierInitialization::_internal_cutoff() const {
  return cutoff_;
}
inline float MotionEstimationOptions_IrlsOutlierInitialization::cutoff() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.IrlsOutlierInitialization.cutoff)
  return _internal_cutoff();
}
inline void MotionEstimationOptions_IrlsOutlierInitialization::_internal_set_cutoff(float value) {
  _has_bits_[0] |= 0x00000004u;
  cutoff_ = value;
}
inline void MotionEstimationOptions_IrlsOutlierInitialization::set_cutoff(float value) {
  _internal_set_cutoff(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.IrlsOutlierInitialization.cutoff)
}

// -------------------------------------------------------------------

// MotionEstimationOptions_LongFeatureInitialization

// optional bool activated = 1 [default = false];
inline bool MotionEstimationOptions_LongFeatureInitialization::_internal_has_activated() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MotionEstimationOptions_LongFeatureInitialization::has_activated() const {
  return _internal_has_activated();
}
inline void MotionEstimationOptions_LongFeatureInitialization::clear_activated() {
  activated_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool MotionEstimationOptions_LongFeatureInitialization::_internal_activated() const {
  return activated_;
}
inline bool MotionEstimationOptions_LongFeatureInitialization::activated() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.LongFeatureInitialization.activated)
  return _internal_activated();
}
inline void MotionEstimationOptions_LongFeatureInitialization::_internal_set_activated(bool value) {
  _has_bits_[0] |= 0x00000001u;
  activated_ = value;
}
inline void MotionEstimationOptions_LongFeatureInitialization::set_activated(bool value) {
  _internal_set_activated(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.LongFeatureInitialization.activated)
}

// optional float min_length_percentile = 2 [default = 0.95];
inline bool MotionEstimationOptions_LongFeatureInitialization::_internal_has_min_length_percentile() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MotionEstimationOptions_LongFeatureInitialization::has_min_length_percentile() const {
  return _internal_has_min_length_percentile();
}
inline void MotionEstimationOptions_LongFeatureInitialization::clear_min_length_percentile() {
  min_length_percentile_ = 0.95f;
  _has_bits_[0] &= ~0x00000002u;
}
inline float MotionEstimationOptions_LongFeatureInitialization::_internal_min_length_percentile() const {
  return min_length_percentile_;
}
inline float MotionEstimationOptions_LongFeatureInitialization::min_length_percentile() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.LongFeatureInitialization.min_length_percentile)
  return _internal_min_length_percentile();
}
inline void MotionEstimationOptions_LongFeatureInitialization::_internal_set_min_length_percentile(float value) {
  _has_bits_[0] |= 0x00000002u;
  min_length_percentile_ = value;
}
inline void MotionEstimationOptions_LongFeatureInitialization::set_min_length_percentile(float value) {
  _internal_set_min_length_percentile(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.LongFeatureInitialization.min_length_percentile)
}

// optional float upweight_multiplier = 3 [default = 5];
inline bool MotionEstimationOptions_LongFeatureInitialization::_internal_has_upweight_multiplier() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MotionEstimationOptions_LongFeatureInitialization::has_upweight_multiplier() const {
  return _internal_has_upweight_multiplier();
}
inline void MotionEstimationOptions_LongFeatureInitialization::clear_upweight_multiplier() {
  upweight_multiplier_ = 5;
  _has_bits_[0] &= ~0x00000004u;
}
inline float MotionEstimationOptions_LongFeatureInitialization::_internal_upweight_multiplier() const {
  return upweight_multiplier_;
}
inline float MotionEstimationOptions_LongFeatureInitialization::upweight_multiplier() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.LongFeatureInitialization.upweight_multiplier)
  return _internal_upweight_multiplier();
}
inline void MotionEstimationOptions_LongFeatureInitialization::_internal_set_upweight_multiplier(float value) {
  _has_bits_[0] |= 0x00000004u;
  upweight_multiplier_ = value;
}
inline void MotionEstimationOptions_LongFeatureInitialization::set_upweight_multiplier(float value) {
  _internal_set_upweight_multiplier(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.LongFeatureInitialization.upweight_multiplier)
}

// -------------------------------------------------------------------

// MotionEstimationOptions_IrlsMaskOptions

// optional float decay = 2 [default = 0.7];
inline bool MotionEstimationOptions_IrlsMaskOptions::_internal_has_decay() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MotionEstimationOptions_IrlsMaskOptions::has_decay() const {
  return _internal_has_decay();
}
inline void MotionEstimationOptions_IrlsMaskOptions::clear_decay() {
  decay_ = 0.7f;
  _has_bits_[0] &= ~0x00000001u;
}
inline float MotionEstimationOptions_IrlsMaskOptions::_internal_decay() const {
  return decay_;
}
inline float MotionEstimationOptions_IrlsMaskOptions::decay() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.IrlsMaskOptions.decay)
  return _internal_decay();
}
inline void MotionEstimationOptions_IrlsMaskOptions::_internal_set_decay(float value) {
  _has_bits_[0] |= 0x00000001u;
  decay_ = value;
}
inline void MotionEstimationOptions_IrlsMaskOptions::set_decay(float value) {
  _internal_set_decay(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.IrlsMaskOptions.decay)
}

// optional float inlier_score = 3 [default = 0.4];
inline bool MotionEstimationOptions_IrlsMaskOptions::_internal_has_inlier_score() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MotionEstimationOptions_IrlsMaskOptions::has_inlier_score() const {
  return _internal_has_inlier_score();
}
inline void MotionEstimationOptions_IrlsMaskOptions::clear_inlier_score() {
  inlier_score_ = 0.4f;
  _has_bits_[0] &= ~0x00000002u;
}
inline float MotionEstimationOptions_IrlsMaskOptions::_internal_inlier_score() const {
  return inlier_score_;
}
inline float MotionEstimationOptions_IrlsMaskOptions::inlier_score() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.IrlsMaskOptions.inlier_score)
  return _internal_inlier_score();
}
inline void MotionEstimationOptions_IrlsMaskOptions::_internal_set_inlier_score(float value) {
  _has_bits_[0] |= 0x00000002u;
  inlier_score_ = value;
}
inline void MotionEstimationOptions_IrlsMaskOptions::set_inlier_score(float value) {
  _internal_set_inlier_score(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.IrlsMaskOptions.inlier_score)
}

// optional float base_score = 4 [default = 0.2];
inline bool MotionEstimationOptions_IrlsMaskOptions::_internal_has_base_score() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MotionEstimationOptions_IrlsMaskOptions::has_base_score() const {
  return _internal_has_base_score();
}
inline void MotionEstimationOptions_IrlsMaskOptions::clear_base_score() {
  base_score_ = 0.2f;
  _has_bits_[0] &= ~0x00000004u;
}
inline float MotionEstimationOptions_IrlsMaskOptions::_internal_base_score() const {
  return base_score_;
}
inline float MotionEstimationOptions_IrlsMaskOptions::base_score() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.IrlsMaskOptions.base_score)
  return _internal_base_score();
}
inline void MotionEstimationOptions_IrlsMaskOptions::_internal_set_base_score(float value) {
  _has_bits_[0] |= 0x00000004u;
  base_score_ = value;
}
inline void MotionEstimationOptions_IrlsMaskOptions::set_base_score(float value) {
  _internal_set_base_score(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.IrlsMaskOptions.base_score)
}

// optional float min_translation_norm = 5 [default = 0.002];
inline bool MotionEstimationOptions_IrlsMaskOptions::_internal_has_min_translation_norm() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MotionEstimationOptions_IrlsMaskOptions::has_min_translation_norm() const {
  return _internal_has_min_translation_norm();
}
inline void MotionEstimationOptions_IrlsMaskOptions::clear_min_translation_norm() {
  min_translation_norm_ = 0.002f;
  _has_bits_[0] &= ~0x00000008u;
}
inline float MotionEstimationOptions_IrlsMaskOptions::_internal_min_translation_norm() const {
  return min_translation_norm_;
}
inline float MotionEstimationOptions_IrlsMaskOptions::min_translation_norm() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.IrlsMaskOptions.min_translation_norm)
  return _internal_min_translation_norm();
}
inline void MotionEstimationOptions_IrlsMaskOptions::_internal_set_min_translation_norm(float value) {
  _has_bits_[0] |= 0x00000008u;
  min_translation_norm_ = value;
}
inline void MotionEstimationOptions_IrlsMaskOptions::set_min_translation_norm(float value) {
  _internal_set_min_translation_norm(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.IrlsMaskOptions.min_translation_norm)
}

// optional float translation_blend_alpha = 6 [default = 0.7];
inline bool MotionEstimationOptions_IrlsMaskOptions::_internal_has_translation_blend_alpha() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MotionEstimationOptions_IrlsMaskOptions::has_translation_blend_alpha() const {
  return _internal_has_translation_blend_alpha();
}
inline void MotionEstimationOptions_IrlsMaskOptions::clear_translation_blend_alpha() {
  translation_blend_alpha_ = 0.7f;
  _has_bits_[0] &= ~0x00000010u;
}
inline float MotionEstimationOptions_IrlsMaskOptions::_internal_translation_blend_alpha() const {
  return translation_blend_alpha_;
}
inline float MotionEstimationOptions_IrlsMaskOptions::translation_blend_alpha() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.IrlsMaskOptions.translation_blend_alpha)
  return _internal_translation_blend_alpha();
}
inline void MotionEstimationOptions_IrlsMaskOptions::_internal_set_translation_blend_alpha(float value) {
  _has_bits_[0] |= 0x00000010u;
  translation_blend_alpha_ = value;
}
inline void MotionEstimationOptions_IrlsMaskOptions::set_translation_blend_alpha(float value) {
  _internal_set_translation_blend_alpha(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.IrlsMaskOptions.translation_blend_alpha)
}

// optional float translation_prior_increase = 7 [default = 0.2];
inline bool MotionEstimationOptions_IrlsMaskOptions::_internal_has_translation_prior_increase() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MotionEstimationOptions_IrlsMaskOptions::has_translation_prior_increase() const {
  return _internal_has_translation_prior_increase();
}
inline void MotionEstimationOptions_IrlsMaskOptions::clear_translation_prior_increase() {
  translation_prior_increase_ = 0.2f;
  _has_bits_[0] &= ~0x00000020u;
}
inline float MotionEstimationOptions_IrlsMaskOptions::_internal_translation_prior_increase() const {
  return translation_prior_increase_;
}
inline float MotionEstimationOptions_IrlsMaskOptions::translation_prior_increase() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.IrlsMaskOptions.translation_prior_increase)
  return _internal_translation_prior_increase();
}
inline void MotionEstimationOptions_IrlsMaskOptions::_internal_set_translation_prior_increase(float value) {
  _has_bits_[0] |= 0x00000020u;
  translation_prior_increase_ = value;
}
inline void MotionEstimationOptions_IrlsMaskOptions::set_translation_prior_increase(float value) {
  _internal_set_translation_prior_increase(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.IrlsMaskOptions.translation_prior_increase)
}

// -------------------------------------------------------------------

// MotionEstimationOptions_JointTrackEstimationOptions

// optional int32 num_motion_models = 1 [default = 3];
inline bool MotionEstimationOptions_JointTrackEstimationOptions::_internal_has_num_motion_models() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MotionEstimationOptions_JointTrackEstimationOptions::has_num_motion_models() const {
  return _internal_has_num_motion_models();
}
inline void MotionEstimationOptions_JointTrackEstimationOptions::clear_num_motion_models() {
  num_motion_models_ = 3;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MotionEstimationOptions_JointTrackEstimationOptions::_internal_num_motion_models() const {
  return num_motion_models_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MotionEstimationOptions_JointTrackEstimationOptions::num_motion_models() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.JointTrackEstimationOptions.num_motion_models)
  return _internal_num_motion_models();
}
inline void MotionEstimationOptions_JointTrackEstimationOptions::_internal_set_num_motion_models(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  num_motion_models_ = value;
}
inline void MotionEstimationOptions_JointTrackEstimationOptions::set_num_motion_models(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_motion_models(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.JointTrackEstimationOptions.num_motion_models)
}

// optional int32 motion_stride = 2 [default = 15];
inline bool MotionEstimationOptions_JointTrackEstimationOptions::_internal_has_motion_stride() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MotionEstimationOptions_JointTrackEstimationOptions::has_motion_stride() const {
  return _internal_has_motion_stride();
}
inline void MotionEstimationOptions_JointTrackEstimationOptions::clear_motion_stride() {
  motion_stride_ = 15;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MotionEstimationOptions_JointTrackEstimationOptions::_internal_motion_stride() const {
  return motion_stride_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MotionEstimationOptions_JointTrackEstimationOptions::motion_stride() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.JointTrackEstimationOptions.motion_stride)
  return _internal_motion_stride();
}
inline void MotionEstimationOptions_JointTrackEstimationOptions::_internal_set_motion_stride(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  motion_stride_ = value;
}
inline void MotionEstimationOptions_JointTrackEstimationOptions::set_motion_stride(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_motion_stride(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.JointTrackEstimationOptions.motion_stride)
}

// optional bool temporal_smoothing = 3 [default = false];
inline bool MotionEstimationOptions_JointTrackEstimationOptions::_internal_has_temporal_smoothing() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MotionEstimationOptions_JointTrackEstimationOptions::has_temporal_smoothing() const {
  return _internal_has_temporal_smoothing();
}
inline void MotionEstimationOptions_JointTrackEstimationOptions::clear_temporal_smoothing() {
  temporal_smoothing_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool MotionEstimationOptions_JointTrackEstimationOptions::_internal_temporal_smoothing() const {
  return temporal_smoothing_;
}
inline bool MotionEstimationOptions_JointTrackEstimationOptions::temporal_smoothing() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.JointTrackEstimationOptions.temporal_smoothing)
  return _internal_temporal_smoothing();
}
inline void MotionEstimationOptions_JointTrackEstimationOptions::_internal_set_temporal_smoothing(bool value) {
  _has_bits_[0] |= 0x00000001u;
  temporal_smoothing_ = value;
}
inline void MotionEstimationOptions_JointTrackEstimationOptions::set_temporal_smoothing(bool value) {
  _internal_set_temporal_smoothing(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.JointTrackEstimationOptions.temporal_smoothing)
}

// -------------------------------------------------------------------

// MotionEstimationOptions_LongFeatureBiasOptions

// optional int32 total_rounds = 13 [default = 1];
inline bool MotionEstimationOptions_LongFeatureBiasOptions::_internal_has_total_rounds() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MotionEstimationOptions_LongFeatureBiasOptions::has_total_rounds() const {
  return _internal_has_total_rounds();
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::clear_total_rounds() {
  total_rounds_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MotionEstimationOptions_LongFeatureBiasOptions::_internal_total_rounds() const {
  return total_rounds_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MotionEstimationOptions_LongFeatureBiasOptions::total_rounds() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions.total_rounds)
  return _internal_total_rounds();
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::_internal_set_total_rounds(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  total_rounds_ = value;
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::set_total_rounds(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_total_rounds(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions.total_rounds)
}

// optional float inlier_bias = 1 [default = 0.98];
inline bool MotionEstimationOptions_LongFeatureBiasOptions::_internal_has_inlier_bias() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MotionEstimationOptions_LongFeatureBiasOptions::has_inlier_bias() const {
  return _internal_has_inlier_bias();
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::clear_inlier_bias() {
  inlier_bias_ = 0.98f;
  _has_bits_[0] &= ~0x00000004u;
}
inline float MotionEstimationOptions_LongFeatureBiasOptions::_internal_inlier_bias() const {
  return inlier_bias_;
}
inline float MotionEstimationOptions_LongFeatureBiasOptions::inlier_bias() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions.inlier_bias)
  return _internal_inlier_bias();
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::_internal_set_inlier_bias(float value) {
  _has_bits_[0] |= 0x00000004u;
  inlier_bias_ = value;
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::set_inlier_bias(float value) {
  _internal_set_inlier_bias(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions.inlier_bias)
}

// optional float outlier_bias = 2 [default = 0.7];
inline bool MotionEstimationOptions_LongFeatureBiasOptions::_internal_has_outlier_bias() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MotionEstimationOptions_LongFeatureBiasOptions::has_outlier_bias() const {
  return _internal_has_outlier_bias();
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::clear_outlier_bias() {
  outlier_bias_ = 0.7f;
  _has_bits_[0] &= ~0x00000008u;
}
inline float MotionEstimationOptions_LongFeatureBiasOptions::_internal_outlier_bias() const {
  return outlier_bias_;
}
inline float MotionEstimationOptions_LongFeatureBiasOptions::outlier_bias() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions.outlier_bias)
  return _internal_outlier_bias();
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::_internal_set_outlier_bias(float value) {
  _has_bits_[0] |= 0x00000008u;
  outlier_bias_ = value;
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::set_outlier_bias(float value) {
  _internal_set_outlier_bias(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions.outlier_bias)
}

// optional int32 num_irls_observations = 3 [default = 10];
inline bool MotionEstimationOptions_LongFeatureBiasOptions::_internal_has_num_irls_observations() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MotionEstimationOptions_LongFeatureBiasOptions::has_num_irls_observations() const {
  return _internal_has_num_irls_observations();
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::clear_num_irls_observations() {
  num_irls_observations_ = 10;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MotionEstimationOptions_LongFeatureBiasOptions::_internal_num_irls_observations() const {
  return num_irls_observations_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MotionEstimationOptions_LongFeatureBiasOptions::num_irls_observations() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions.num_irls_observations)
  return _internal_num_irls_observations();
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::_internal_set_num_irls_observations(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  num_irls_observations_ = value;
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::set_num_irls_observations(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_irls_observations(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions.num_irls_observations)
}

// optional float max_irls_change_ratio = 4 [default = 10];
inline bool MotionEstimationOptions_LongFeatureBiasOptions::_internal_has_max_irls_change_ratio() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MotionEstimationOptions_LongFeatureBiasOptions::has_max_irls_change_ratio() const {
  return _internal_has_max_irls_change_ratio();
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::clear_max_irls_change_ratio() {
  max_irls_change_ratio_ = 10;
  _has_bits_[0] &= ~0x00000020u;
}
inline float MotionEstimationOptions_LongFeatureBiasOptions::_internal_max_irls_change_ratio() const {
  return max_irls_change_ratio_;
}
inline float MotionEstimationOptions_LongFeatureBiasOptions::max_irls_change_ratio() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions.max_irls_change_ratio)
  return _internal_max_irls_change_ratio();
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::_internal_set_max_irls_change_ratio(float value) {
  _has_bits_[0] |= 0x00000020u;
  max_irls_change_ratio_ = value;
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::set_max_irls_change_ratio(float value) {
  _internal_set_max_irls_change_ratio(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions.max_irls_change_ratio)
}

// optional float inlier_irls_weight = 5 [default = 0.2];
inline bool MotionEstimationOptions_LongFeatureBiasOptions::_internal_has_inlier_irls_weight() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool MotionEstimationOptions_LongFeatureBiasOptions::has_inlier_irls_weight() const {
  return _internal_has_inlier_irls_weight();
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::clear_inlier_irls_weight() {
  inlier_irls_weight_ = 0.2f;
  _has_bits_[0] &= ~0x00000040u;
}
inline float MotionEstimationOptions_LongFeatureBiasOptions::_internal_inlier_irls_weight() const {
  return inlier_irls_weight_;
}
inline float MotionEstimationOptions_LongFeatureBiasOptions::inlier_irls_weight() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions.inlier_irls_weight)
  return _internal_inlier_irls_weight();
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::_internal_set_inlier_irls_weight(float value) {
  _has_bits_[0] |= 0x00000040u;
  inlier_irls_weight_ = value;
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::set_inlier_irls_weight(float value) {
  _internal_set_inlier_irls_weight(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions.inlier_irls_weight)
}

// optional float bias_stdev = 12 [default = 1];
inline bool MotionEstimationOptions_LongFeatureBiasOptions::_internal_has_bias_stdev() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool MotionEstimationOptions_LongFeatureBiasOptions::has_bias_stdev() const {
  return _internal_has_bias_stdev();
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::clear_bias_stdev() {
  bias_stdev_ = 1;
  _has_bits_[0] &= ~0x00002000u;
}
inline float MotionEstimationOptions_LongFeatureBiasOptions::_internal_bias_stdev() const {
  return bias_stdev_;
}
inline float MotionEstimationOptions_LongFeatureBiasOptions::bias_stdev() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions.bias_stdev)
  return _internal_bias_stdev();
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::_internal_set_bias_stdev(float value) {
  _has_bits_[0] |= 0x00002000u;
  bias_stdev_ = value;
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::set_bias_stdev(float value) {
  _internal_set_bias_stdev(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions.bias_stdev)
}

// optional bool use_spatial_bias = 6 [default = true];
inline bool MotionEstimationOptions_LongFeatureBiasOptions::_internal_has_use_spatial_bias() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool MotionEstimationOptions_LongFeatureBiasOptions::has_use_spatial_bias() const {
  return _internal_has_use_spatial_bias();
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::clear_use_spatial_bias() {
  use_spatial_bias_ = true;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool MotionEstimationOptions_LongFeatureBiasOptions::_internal_use_spatial_bias() const {
  return use_spatial_bias_;
}
inline bool MotionEstimationOptions_LongFeatureBiasOptions::use_spatial_bias() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions.use_spatial_bias)
  return _internal_use_spatial_bias();
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::_internal_set_use_spatial_bias(bool value) {
  _has_bits_[0] |= 0x00000080u;
  use_spatial_bias_ = value;
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::set_use_spatial_bias(bool value) {
  _internal_set_use_spatial_bias(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions.use_spatial_bias)
}

// optional float grid_size = 7 [default = 0.04];
inline bool MotionEstimationOptions_LongFeatureBiasOptions::_internal_has_grid_size() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool MotionEstimationOptions_LongFeatureBiasOptions::has_grid_size() const {
  return _internal_has_grid_size();
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::clear_grid_size() {
  grid_size_ = 0.04f;
  _has_bits_[0] &= ~0x00000100u;
}
inline float MotionEstimationOptions_LongFeatureBiasOptions::_internal_grid_size() const {
  return grid_size_;
}
inline float MotionEstimationOptions_LongFeatureBiasOptions::grid_size() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions.grid_size)
  return _internal_grid_size();
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::_internal_set_grid_size(float value) {
  _has_bits_[0] |= 0x00000100u;
  grid_size_ = value;
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::set_grid_size(float value) {
  _internal_set_grid_size(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions.grid_size)
}

// optional float spatial_sigma = 8 [default = 0.02];
inline bool MotionEstimationOptions_LongFeatureBiasOptions::_internal_has_spatial_sigma() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool MotionEstimationOptions_LongFeatureBiasOptions::has_spatial_sigma() const {
  return _internal_has_spatial_sigma();
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::clear_spatial_sigma() {
  spatial_sigma_ = 0.02f;
  _has_bits_[0] &= ~0x00000200u;
}
inline float MotionEstimationOptions_LongFeatureBiasOptions::_internal_spatial_sigma() const {
  return spatial_sigma_;
}
inline float MotionEstimationOptions_LongFeatureBiasOptions::spatial_sigma() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions.spatial_sigma)
  return _internal_spatial_sigma();
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::_internal_set_spatial_sigma(float value) {
  _has_bits_[0] |= 0x00000200u;
  spatial_sigma_ = value;
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::set_spatial_sigma(float value) {
  _internal_set_spatial_sigma(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions.spatial_sigma)
}

// optional float color_sigma = 9 [default = 20];
inline bool MotionEstimationOptions_LongFeatureBiasOptions::_internal_has_color_sigma() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool MotionEstimationOptions_LongFeatureBiasOptions::has_color_sigma() const {
  return _internal_has_color_sigma();
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::clear_color_sigma() {
  color_sigma_ = 20;
  _has_bits_[0] &= ~0x00000400u;
}
inline float MotionEstimationOptions_LongFeatureBiasOptions::_internal_color_sigma() const {
  return color_sigma_;
}
inline float MotionEstimationOptions_LongFeatureBiasOptions::color_sigma() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions.color_sigma)
  return _internal_color_sigma();
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::_internal_set_color_sigma(float value) {
  _has_bits_[0] |= 0x00000400u;
  color_sigma_ = value;
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::set_color_sigma(float value) {
  _internal_set_color_sigma(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions.color_sigma)
}

// optional int32 long_track_threshold = 10 [default = 30];
inline bool MotionEstimationOptions_LongFeatureBiasOptions::_internal_has_long_track_threshold() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool MotionEstimationOptions_LongFeatureBiasOptions::has_long_track_threshold() const {
  return _internal_has_long_track_threshold();
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::clear_long_track_threshold() {
  long_track_threshold_ = 30;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MotionEstimationOptions_LongFeatureBiasOptions::_internal_long_track_threshold() const {
  return long_track_threshold_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MotionEstimationOptions_LongFeatureBiasOptions::long_track_threshold() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions.long_track_threshold)
  return _internal_long_track_threshold();
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::_internal_set_long_track_threshold(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000800u;
  long_track_threshold_ = value;
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::set_long_track_threshold(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_long_track_threshold(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions.long_track_threshold)
}

// optional float long_track_confidence_fraction = 11 [default = 0.25];
inline bool MotionEstimationOptions_LongFeatureBiasOptions::_internal_has_long_track_confidence_fraction() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool MotionEstimationOptions_LongFeatureBiasOptions::has_long_track_confidence_fraction() const {
  return _internal_has_long_track_confidence_fraction();
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::clear_long_track_confidence_fraction() {
  long_track_confidence_fraction_ = 0.25f;
  _has_bits_[0] &= ~0x00001000u;
}
inline float MotionEstimationOptions_LongFeatureBiasOptions::_internal_long_track_confidence_fraction() const {
  return long_track_confidence_fraction_;
}
inline float MotionEstimationOptions_LongFeatureBiasOptions::long_track_confidence_fraction() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions.long_track_confidence_fraction)
  return _internal_long_track_confidence_fraction();
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::_internal_set_long_track_confidence_fraction(float value) {
  _has_bits_[0] |= 0x00001000u;
  long_track_confidence_fraction_ = value;
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::set_long_track_confidence_fraction(float value) {
  _internal_set_long_track_confidence_fraction(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions.long_track_confidence_fraction)
}

// optional bool seed_priors_from_bias = 14 [default = false];
inline bool MotionEstimationOptions_LongFeatureBiasOptions::_internal_has_seed_priors_from_bias() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MotionEstimationOptions_LongFeatureBiasOptions::has_seed_priors_from_bias() const {
  return _internal_has_seed_priors_from_bias();
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::clear_seed_priors_from_bias() {
  seed_priors_from_bias_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool MotionEstimationOptions_LongFeatureBiasOptions::_internal_seed_priors_from_bias() const {
  return seed_priors_from_bias_;
}
inline bool MotionEstimationOptions_LongFeatureBiasOptions::seed_priors_from_bias() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions.seed_priors_from_bias)
  return _internal_seed_priors_from_bias();
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::_internal_set_seed_priors_from_bias(bool value) {
  _has_bits_[0] |= 0x00000001u;
  seed_priors_from_bias_ = value;
}
inline void MotionEstimationOptions_LongFeatureBiasOptions::set_seed_priors_from_bias(bool value) {
  _internal_set_seed_priors_from_bias(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.LongFeatureBiasOptions.seed_priors_from_bias)
}

// -------------------------------------------------------------------

// MotionEstimationOptions_TranslationBounds

// optional int32 min_features = 1 [default = 3];
inline bool MotionEstimationOptions_TranslationBounds::_internal_has_min_features() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MotionEstimationOptions_TranslationBounds::has_min_features() const {
  return _internal_has_min_features();
}
inline void MotionEstimationOptions_TranslationBounds::clear_min_features() {
  min_features_ = 3;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MotionEstimationOptions_TranslationBounds::_internal_min_features() const {
  return min_features_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MotionEstimationOptions_TranslationBounds::min_features() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.TranslationBounds.min_features)
  return _internal_min_features();
}
inline void MotionEstimationOptions_TranslationBounds::_internal_set_min_features(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  min_features_ = value;
}
inline void MotionEstimationOptions_TranslationBounds::set_min_features(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_min_features(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.TranslationBounds.min_features)
}

// optional float frac_max_motion_magnitude = 2 [default = 0.15];
inline bool MotionEstimationOptions_TranslationBounds::_internal_has_frac_max_motion_magnitude() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MotionEstimationOptions_TranslationBounds::has_frac_max_motion_magnitude() const {
  return _internal_has_frac_max_motion_magnitude();
}
inline void MotionEstimationOptions_TranslationBounds::clear_frac_max_motion_magnitude() {
  frac_max_motion_magnitude_ = 0.15f;
  _has_bits_[0] &= ~0x00000004u;
}
inline float MotionEstimationOptions_TranslationBounds::_internal_frac_max_motion_magnitude() const {
  return frac_max_motion_magnitude_;
}
inline float MotionEstimationOptions_TranslationBounds::frac_max_motion_magnitude() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.TranslationBounds.frac_max_motion_magnitude)
  return _internal_frac_max_motion_magnitude();
}
inline void MotionEstimationOptions_TranslationBounds::_internal_set_frac_max_motion_magnitude(float value) {
  _has_bits_[0] |= 0x00000004u;
  frac_max_motion_magnitude_ = value;
}
inline void MotionEstimationOptions_TranslationBounds::set_frac_max_motion_magnitude(float value) {
  _internal_set_frac_max_motion_magnitude(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.TranslationBounds.frac_max_motion_magnitude)
}

// optional float max_motion_stdev_threshold = 4 [default = 0.01];
inline bool MotionEstimationOptions_TranslationBounds::_internal_has_max_motion_stdev_threshold() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MotionEstimationOptions_TranslationBounds::has_max_motion_stdev_threshold() const {
  return _internal_has_max_motion_stdev_threshold();
}
inline void MotionEstimationOptions_TranslationBounds::clear_max_motion_stdev_threshold() {
  max_motion_stdev_threshold_ = 0.01f;
  _has_bits_[0] &= ~0x00000010u;
}
inline float MotionEstimationOptions_TranslationBounds::_internal_max_motion_stdev_threshold() const {
  return max_motion_stdev_threshold_;
}
inline float MotionEstimationOptions_TranslationBounds::max_motion_stdev_threshold() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.TranslationBounds.max_motion_stdev_threshold)
  return _internal_max_motion_stdev_threshold();
}
inline void MotionEstimationOptions_TranslationBounds::_internal_set_max_motion_stdev_threshold(float value) {
  _has_bits_[0] |= 0x00000010u;
  max_motion_stdev_threshold_ = value;
}
inline void MotionEstimationOptions_TranslationBounds::set_max_motion_stdev_threshold(float value) {
  _internal_set_max_motion_stdev_threshold(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.TranslationBounds.max_motion_stdev_threshold)
}

// optional float max_motion_stdev = 3 [default = 0.065];
inline bool MotionEstimationOptions_TranslationBounds::_internal_has_max_motion_stdev() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MotionEstimationOptions_TranslationBounds::has_max_motion_stdev() const {
  return _internal_has_max_motion_stdev();
}
inline void MotionEstimationOptions_TranslationBounds::clear_max_motion_stdev() {
  max_motion_stdev_ = 0.065f;
  _has_bits_[0] &= ~0x00000008u;
}
inline float MotionEstimationOptions_TranslationBounds::_internal_max_motion_stdev() const {
  return max_motion_stdev_;
}
inline float MotionEstimationOptions_TranslationBounds::max_motion_stdev() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.TranslationBounds.max_motion_stdev)
  return _internal_max_motion_stdev();
}
inline void MotionEstimationOptions_TranslationBounds::_internal_set_max_motion_stdev(float value) {
  _has_bits_[0] |= 0x00000008u;
  max_motion_stdev_ = value;
}
inline void MotionEstimationOptions_TranslationBounds::set_max_motion_stdev(float value) {
  _internal_set_max_motion_stdev(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.TranslationBounds.max_motion_stdev)
}

// optional float max_acceleration = 5 [default = 20];
inline bool MotionEstimationOptions_TranslationBounds::_internal_has_max_acceleration() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MotionEstimationOptions_TranslationBounds::has_max_acceleration() const {
  return _internal_has_max_acceleration();
}
inline void MotionEstimationOptions_TranslationBounds::clear_max_acceleration() {
  max_acceleration_ = 20;
  _has_bits_[0] &= ~0x00000001u;
}
inline float MotionEstimationOptions_TranslationBounds::_internal_max_acceleration() const {
  return max_acceleration_;
}
inline float MotionEstimationOptions_TranslationBounds::max_acceleration() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.TranslationBounds.max_acceleration)
  return _internal_max_acceleration();
}
inline void MotionEstimationOptions_TranslationBounds::_internal_set_max_acceleration(float value) {
  _has_bits_[0] |= 0x00000001u;
  max_acceleration_ = value;
}
inline void MotionEstimationOptions_TranslationBounds::set_max_acceleration(float value) {
  _internal_set_max_acceleration(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.TranslationBounds.max_acceleration)
}

// -------------------------------------------------------------------

// MotionEstimationOptions_SimilarityBounds

// optional bool only_stable_input = 1 [default = true];
inline bool MotionEstimationOptions_SimilarityBounds::_internal_has_only_stable_input() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MotionEstimationOptions_SimilarityBounds::has_only_stable_input() const {
  return _internal_has_only_stable_input();
}
inline void MotionEstimationOptions_SimilarityBounds::clear_only_stable_input() {
  only_stable_input_ = true;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool MotionEstimationOptions_SimilarityBounds::_internal_only_stable_input() const {
  return only_stable_input_;
}
inline bool MotionEstimationOptions_SimilarityBounds::only_stable_input() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.SimilarityBounds.only_stable_input)
  return _internal_only_stable_input();
}
inline void MotionEstimationOptions_SimilarityBounds::_internal_set_only_stable_input(bool value) {
  _has_bits_[0] |= 0x00000002u;
  only_stable_input_ = value;
}
inline void MotionEstimationOptions_SimilarityBounds::set_only_stable_input(bool value) {
  _internal_set_only_stable_input(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.SimilarityBounds.only_stable_input)
}

// optional float min_inlier_fraction = 2 [default = 0.2];
inline bool MotionEstimationOptions_SimilarityBounds::_internal_has_min_inlier_fraction() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MotionEstimationOptions_SimilarityBounds::has_min_inlier_fraction() const {
  return _internal_has_min_inlier_fraction();
}
inline void MotionEstimationOptions_SimilarityBounds::clear_min_inlier_fraction() {
  min_inlier_fraction_ = 0.2f;
  _has_bits_[0] &= ~0x00000004u;
}
inline float MotionEstimationOptions_SimilarityBounds::_internal_min_inlier_fraction() const {
  return min_inlier_fraction_;
}
inline float MotionEstimationOptions_SimilarityBounds::min_inlier_fraction() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.SimilarityBounds.min_inlier_fraction)
  return _internal_min_inlier_fraction();
}
inline void MotionEstimationOptions_SimilarityBounds::_internal_set_min_inlier_fraction(float value) {
  _has_bits_[0] |= 0x00000004u;
  min_inlier_fraction_ = value;
}
inline void MotionEstimationOptions_SimilarityBounds::set_min_inlier_fraction(float value) {
  _internal_set_min_inlier_fraction(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.SimilarityBounds.min_inlier_fraction)
}

// optional float min_inliers = 3 [default = 30];
inline bool MotionEstimationOptions_SimilarityBounds::_internal_has_min_inliers() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MotionEstimationOptions_SimilarityBounds::has_min_inliers() const {
  return _internal_has_min_inliers();
}
inline void MotionEstimationOptions_SimilarityBounds::clear_min_inliers() {
  min_inliers_ = 30;
  _has_bits_[0] &= ~0x00000008u;
}
inline float MotionEstimationOptions_SimilarityBounds::_internal_min_inliers() const {
  return min_inliers_;
}
inline float MotionEstimationOptions_SimilarityBounds::min_inliers() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.SimilarityBounds.min_inliers)
  return _internal_min_inliers();
}
inline void MotionEstimationOptions_SimilarityBounds::_internal_set_min_inliers(float value) {
  _has_bits_[0] |= 0x00000008u;
  min_inliers_ = value;
}
inline void MotionEstimationOptions_SimilarityBounds::set_min_inliers(float value) {
  _internal_set_min_inliers(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.SimilarityBounds.min_inliers)
}

// optional float lower_scale = 4 [default = 0.8];
inline bool MotionEstimationOptions_SimilarityBounds::_internal_has_lower_scale() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MotionEstimationOptions_SimilarityBounds::has_lower_scale() const {
  return _internal_has_lower_scale();
}
inline void MotionEstimationOptions_SimilarityBounds::clear_lower_scale() {
  lower_scale_ = 0.8f;
  _has_bits_[0] &= ~0x00000010u;
}
inline float MotionEstimationOptions_SimilarityBounds::_internal_lower_scale() const {
  return lower_scale_;
}
inline float MotionEstimationOptions_SimilarityBounds::lower_scale() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.SimilarityBounds.lower_scale)
  return _internal_lower_scale();
}
inline void MotionEstimationOptions_SimilarityBounds::_internal_set_lower_scale(float value) {
  _has_bits_[0] |= 0x00000010u;
  lower_scale_ = value;
}
inline void MotionEstimationOptions_SimilarityBounds::set_lower_scale(float value) {
  _internal_set_lower_scale(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.SimilarityBounds.lower_scale)
}

// optional float upper_scale = 5 [default = 1.25];
inline bool MotionEstimationOptions_SimilarityBounds::_internal_has_upper_scale() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MotionEstimationOptions_SimilarityBounds::has_upper_scale() const {
  return _internal_has_upper_scale();
}
inline void MotionEstimationOptions_SimilarityBounds::clear_upper_scale() {
  upper_scale_ = 1.25f;
  _has_bits_[0] &= ~0x00000020u;
}
inline float MotionEstimationOptions_SimilarityBounds::_internal_upper_scale() const {
  return upper_scale_;
}
inline float MotionEstimationOptions_SimilarityBounds::upper_scale() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.SimilarityBounds.upper_scale)
  return _internal_upper_scale();
}
inline void MotionEstimationOptions_SimilarityBounds::_internal_set_upper_scale(float value) {
  _has_bits_[0] |= 0x00000020u;
  upper_scale_ = value;
}
inline void MotionEstimationOptions_SimilarityBounds::set_upper_scale(float value) {
  _internal_set_upper_scale(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.SimilarityBounds.upper_scale)
}

// optional float limit_rotation = 6 [default = 0.25];
inline bool MotionEstimationOptions_SimilarityBounds::_internal_has_limit_rotation() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool MotionEstimationOptions_SimilarityBounds::has_limit_rotation() const {
  return _internal_has_limit_rotation();
}
inline void MotionEstimationOptions_SimilarityBounds::clear_limit_rotation() {
  limit_rotation_ = 0.25f;
  _has_bits_[0] &= ~0x00000040u;
}
inline float MotionEstimationOptions_SimilarityBounds::_internal_limit_rotation() const {
  return limit_rotation_;
}
inline float MotionEstimationOptions_SimilarityBounds::limit_rotation() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.SimilarityBounds.limit_rotation)
  return _internal_limit_rotation();
}
inline void MotionEstimationOptions_SimilarityBounds::_internal_set_limit_rotation(float value) {
  _has_bits_[0] |= 0x00000040u;
  limit_rotation_ = value;
}
inline void MotionEstimationOptions_SimilarityBounds::set_limit_rotation(float value) {
  _internal_set_limit_rotation(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.SimilarityBounds.limit_rotation)
}

// optional float inlier_threshold = 7 [default = 4];
inline bool MotionEstimationOptions_SimilarityBounds::_internal_has_inlier_threshold() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool MotionEstimationOptions_SimilarityBounds::has_inlier_threshold() const {
  return _internal_has_inlier_threshold();
}
inline void MotionEstimationOptions_SimilarityBounds::clear_inlier_threshold() {
  inlier_threshold_ = 4;
  _has_bits_[0] &= ~0x00000080u;
}
inline float MotionEstimationOptions_SimilarityBounds::_internal_inlier_threshold() const {
  return inlier_threshold_;
}
inline float MotionEstimationOptions_SimilarityBounds::inlier_threshold() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.SimilarityBounds.inlier_threshold)
  return _internal_inlier_threshold();
}
inline void MotionEstimationOptions_SimilarityBounds::_internal_set_inlier_threshold(float value) {
  _has_bits_[0] |= 0x00000080u;
  inlier_threshold_ = value;
}
inline void MotionEstimationOptions_SimilarityBounds::set_inlier_threshold(float value) {
  _internal_set_inlier_threshold(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.SimilarityBounds.inlier_threshold)
}

// optional float frac_inlier_threshold = 8 [default = 0];
inline bool MotionEstimationOptions_SimilarityBounds::_internal_has_frac_inlier_threshold() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MotionEstimationOptions_SimilarityBounds::has_frac_inlier_threshold() const {
  return _internal_has_frac_inlier_threshold();
}
inline void MotionEstimationOptions_SimilarityBounds::clear_frac_inlier_threshold() {
  frac_inlier_threshold_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float MotionEstimationOptions_SimilarityBounds::_internal_frac_inlier_threshold() const {
  return frac_inlier_threshold_;
}
inline float MotionEstimationOptions_SimilarityBounds::frac_inlier_threshold() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.SimilarityBounds.frac_inlier_threshold)
  return _internal_frac_inlier_threshold();
}
inline void MotionEstimationOptions_SimilarityBounds::_internal_set_frac_inlier_threshold(float value) {
  _has_bits_[0] |= 0x00000001u;
  frac_inlier_threshold_ = value;
}
inline void MotionEstimationOptions_SimilarityBounds::set_frac_inlier_threshold(float value) {
  _internal_set_frac_inlier_threshold(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.SimilarityBounds.frac_inlier_threshold)
}

// optional float strict_inlier_threshold = 9 [default = 0.5];
inline bool MotionEstimationOptions_SimilarityBounds::_internal_has_strict_inlier_threshold() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool MotionEstimationOptions_SimilarityBounds::has_strict_inlier_threshold() const {
  return _internal_has_strict_inlier_threshold();
}
inline void MotionEstimationOptions_SimilarityBounds::clear_strict_inlier_threshold() {
  strict_inlier_threshold_ = 0.5f;
  _has_bits_[0] &= ~0x00000100u;
}
inline float MotionEstimationOptions_SimilarityBounds::_internal_strict_inlier_threshold() const {
  return strict_inlier_threshold_;
}
inline float MotionEstimationOptions_SimilarityBounds::strict_inlier_threshold() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.SimilarityBounds.strict_inlier_threshold)
  return _internal_strict_inlier_threshold();
}
inline void MotionEstimationOptions_SimilarityBounds::_internal_set_strict_inlier_threshold(float value) {
  _has_bits_[0] |= 0x00000100u;
  strict_inlier_threshold_ = value;
}
inline void MotionEstimationOptions_SimilarityBounds::set_strict_inlier_threshold(float value) {
  _internal_set_strict_inlier_threshold(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.SimilarityBounds.strict_inlier_threshold)
}

// -------------------------------------------------------------------

// MotionEstimationOptions_HomographyBounds

// optional float lower_scale = 1 [default = 0.8];
inline bool MotionEstimationOptions_HomographyBounds::_internal_has_lower_scale() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MotionEstimationOptions_HomographyBounds::has_lower_scale() const {
  return _internal_has_lower_scale();
}
inline void MotionEstimationOptions_HomographyBounds::clear_lower_scale() {
  lower_scale_ = 0.8f;
  _has_bits_[0] &= ~0x00000004u;
}
inline float MotionEstimationOptions_HomographyBounds::_internal_lower_scale() const {
  return lower_scale_;
}
inline float MotionEstimationOptions_HomographyBounds::lower_scale() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.HomographyBounds.lower_scale)
  return _internal_lower_scale();
}
inline void MotionEstimationOptions_HomographyBounds::_internal_set_lower_scale(float value) {
  _has_bits_[0] |= 0x00000004u;
  lower_scale_ = value;
}
inline void MotionEstimationOptions_HomographyBounds::set_lower_scale(float value) {
  _internal_set_lower_scale(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.HomographyBounds.lower_scale)
}

// optional float upper_scale = 2 [default = 1.25];
inline bool MotionEstimationOptions_HomographyBounds::_internal_has_upper_scale() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MotionEstimationOptions_HomographyBounds::has_upper_scale() const {
  return _internal_has_upper_scale();
}
inline void MotionEstimationOptions_HomographyBounds::clear_upper_scale() {
  upper_scale_ = 1.25f;
  _has_bits_[0] &= ~0x00000008u;
}
inline float MotionEstimationOptions_HomographyBounds::_internal_upper_scale() const {
  return upper_scale_;
}
inline float MotionEstimationOptions_HomographyBounds::upper_scale() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.HomographyBounds.upper_scale)
  return _internal_upper_scale();
}
inline void MotionEstimationOptions_HomographyBounds::_internal_set_upper_scale(float value) {
  _has_bits_[0] |= 0x00000008u;
  upper_scale_ = value;
}
inline void MotionEstimationOptions_HomographyBounds::set_upper_scale(float value) {
  _internal_set_upper_scale(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.HomographyBounds.upper_scale)
}

// optional float limit_rotation = 3 [default = 0.25];
inline bool MotionEstimationOptions_HomographyBounds::_internal_has_limit_rotation() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MotionEstimationOptions_HomographyBounds::has_limit_rotation() const {
  return _internal_has_limit_rotation();
}
inline void MotionEstimationOptions_HomographyBounds::clear_limit_rotation() {
  limit_rotation_ = 0.25f;
  _has_bits_[0] &= ~0x00000010u;
}
inline float MotionEstimationOptions_HomographyBounds::_internal_limit_rotation() const {
  return limit_rotation_;
}
inline float MotionEstimationOptions_HomographyBounds::limit_rotation() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.HomographyBounds.limit_rotation)
  return _internal_limit_rotation();
}
inline void MotionEstimationOptions_HomographyBounds::_internal_set_limit_rotation(float value) {
  _has_bits_[0] |= 0x00000010u;
  limit_rotation_ = value;
}
inline void MotionEstimationOptions_HomographyBounds::set_limit_rotation(float value) {
  _internal_set_limit_rotation(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.HomographyBounds.limit_rotation)
}

// optional float limit_perspective = 4 [default = 0.0004];
inline bool MotionEstimationOptions_HomographyBounds::_internal_has_limit_perspective() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MotionEstimationOptions_HomographyBounds::has_limit_perspective() const {
  return _internal_has_limit_perspective();
}
inline void MotionEstimationOptions_HomographyBounds::clear_limit_perspective() {
  limit_perspective_ = 0.0004f;
  _has_bits_[0] &= ~0x00000020u;
}
inline float MotionEstimationOptions_HomographyBounds::_internal_limit_perspective() const {
  return limit_perspective_;
}
inline float MotionEstimationOptions_HomographyBounds::limit_perspective() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.HomographyBounds.limit_perspective)
  return _internal_limit_perspective();
}
inline void MotionEstimationOptions_HomographyBounds::_internal_set_limit_perspective(float value) {
  _has_bits_[0] |= 0x00000020u;
  limit_perspective_ = value;
}
inline void MotionEstimationOptions_HomographyBounds::set_limit_perspective(float value) {
  _internal_set_limit_perspective(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.HomographyBounds.limit_perspective)
}

// optional float registration_threshold = 5 [default = 0.1];
inline bool MotionEstimationOptions_HomographyBounds::_internal_has_registration_threshold() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool MotionEstimationOptions_HomographyBounds::has_registration_threshold() const {
  return _internal_has_registration_threshold();
}
inline void MotionEstimationOptions_HomographyBounds::clear_registration_threshold() {
  registration_threshold_ = 0.1f;
  _has_bits_[0] &= ~0x00000040u;
}
inline float MotionEstimationOptions_HomographyBounds::_internal_registration_threshold() const {
  return registration_threshold_;
}
inline float MotionEstimationOptions_HomographyBounds::registration_threshold() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.HomographyBounds.registration_threshold)
  return _internal_registration_threshold();
}
inline void MotionEstimationOptions_HomographyBounds::_internal_set_registration_threshold(float value) {
  _has_bits_[0] |= 0x00000040u;
  registration_threshold_ = value;
}
inline void MotionEstimationOptions_HomographyBounds::set_registration_threshold(float value) {
  _internal_set_registration_threshold(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.HomographyBounds.registration_threshold)
}

// optional float frac_registration_threshold = 8 [default = 0];
inline bool MotionEstimationOptions_HomographyBounds::_internal_has_frac_registration_threshold() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MotionEstimationOptions_HomographyBounds::has_frac_registration_threshold() const {
  return _internal_has_frac_registration_threshold();
}
inline void MotionEstimationOptions_HomographyBounds::clear_frac_registration_threshold() {
  frac_registration_threshold_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float MotionEstimationOptions_HomographyBounds::_internal_frac_registration_threshold() const {
  return frac_registration_threshold_;
}
inline float MotionEstimationOptions_HomographyBounds::frac_registration_threshold() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.HomographyBounds.frac_registration_threshold)
  return _internal_frac_registration_threshold();
}
inline void MotionEstimationOptions_HomographyBounds::_internal_set_frac_registration_threshold(float value) {
  _has_bits_[0] |= 0x00000001u;
  frac_registration_threshold_ = value;
}
inline void MotionEstimationOptions_HomographyBounds::set_frac_registration_threshold(float value) {
  _internal_set_frac_registration_threshold(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.HomographyBounds.frac_registration_threshold)
}

// optional float min_inlier_coverage = 6 [default = 0.3];
inline bool MotionEstimationOptions_HomographyBounds::_internal_has_min_inlier_coverage() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool MotionEstimationOptions_HomographyBounds::has_min_inlier_coverage() const {
  return _internal_has_min_inlier_coverage();
}
inline void MotionEstimationOptions_HomographyBounds::clear_min_inlier_coverage() {
  min_inlier_coverage_ = 0.3f;
  _has_bits_[0] &= ~0x00000080u;
}
inline float MotionEstimationOptions_HomographyBounds::_internal_min_inlier_coverage() const {
  return min_inlier_coverage_;
}
inline float MotionEstimationOptions_HomographyBounds::min_inlier_coverage() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.HomographyBounds.min_inlier_coverage)
  return _internal_min_inlier_coverage();
}
inline void MotionEstimationOptions_HomographyBounds::_internal_set_min_inlier_coverage(float value) {
  _has_bits_[0] |= 0x00000080u;
  min_inlier_coverage_ = value;
}
inline void MotionEstimationOptions_HomographyBounds::set_min_inlier_coverage(float value) {
  _internal_set_min_inlier_coverage(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.HomographyBounds.min_inlier_coverage)
}

// optional float frac_inlier_threshold = 7 [default = 0.002];
inline bool MotionEstimationOptions_HomographyBounds::_internal_has_frac_inlier_threshold() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MotionEstimationOptions_HomographyBounds::has_frac_inlier_threshold() const {
  return _internal_has_frac_inlier_threshold();
}
inline void MotionEstimationOptions_HomographyBounds::clear_frac_inlier_threshold() {
  frac_inlier_threshold_ = 0.002f;
  _has_bits_[0] &= ~0x00000002u;
}
inline float MotionEstimationOptions_HomographyBounds::_internal_frac_inlier_threshold() const {
  return frac_inlier_threshold_;
}
inline float MotionEstimationOptions_HomographyBounds::frac_inlier_threshold() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.HomographyBounds.frac_inlier_threshold)
  return _internal_frac_inlier_threshold();
}
inline void MotionEstimationOptions_HomographyBounds::_internal_set_frac_inlier_threshold(float value) {
  _has_bits_[0] |= 0x00000002u;
  frac_inlier_threshold_ = value;
}
inline void MotionEstimationOptions_HomographyBounds::set_frac_inlier_threshold(float value) {
  _internal_set_frac_inlier_threshold(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.HomographyBounds.frac_inlier_threshold)
}

// -------------------------------------------------------------------

// MotionEstimationOptions_MixtureHomographyBounds

// optional float min_inlier_coverage = 1 [default = 0.4];
inline bool MotionEstimationOptions_MixtureHomographyBounds::_internal_has_min_inlier_coverage() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MotionEstimationOptions_MixtureHomographyBounds::has_min_inlier_coverage() const {
  return _internal_has_min_inlier_coverage();
}
inline void MotionEstimationOptions_MixtureHomographyBounds::clear_min_inlier_coverage() {
  min_inlier_coverage_ = 0.4f;
  _has_bits_[0] &= ~0x00000001u;
}
inline float MotionEstimationOptions_MixtureHomographyBounds::_internal_min_inlier_coverage() const {
  return min_inlier_coverage_;
}
inline float MotionEstimationOptions_MixtureHomographyBounds::min_inlier_coverage() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.MixtureHomographyBounds.min_inlier_coverage)
  return _internal_min_inlier_coverage();
}
inline void MotionEstimationOptions_MixtureHomographyBounds::_internal_set_min_inlier_coverage(float value) {
  _has_bits_[0] |= 0x00000001u;
  min_inlier_coverage_ = value;
}
inline void MotionEstimationOptions_MixtureHomographyBounds::set_min_inlier_coverage(float value) {
  _internal_set_min_inlier_coverage(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.MixtureHomographyBounds.min_inlier_coverage)
}

// optional int32 max_adjacent_outlier_blocks = 2 [default = 5];
inline bool MotionEstimationOptions_MixtureHomographyBounds::_internal_has_max_adjacent_outlier_blocks() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MotionEstimationOptions_MixtureHomographyBounds::has_max_adjacent_outlier_blocks() const {
  return _internal_has_max_adjacent_outlier_blocks();
}
inline void MotionEstimationOptions_MixtureHomographyBounds::clear_max_adjacent_outlier_blocks() {
  max_adjacent_outlier_blocks_ = 5;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MotionEstimationOptions_MixtureHomographyBounds::_internal_max_adjacent_outlier_blocks() const {
  return max_adjacent_outlier_blocks_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MotionEstimationOptions_MixtureHomographyBounds::max_adjacent_outlier_blocks() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.MixtureHomographyBounds.max_adjacent_outlier_blocks)
  return _internal_max_adjacent_outlier_blocks();
}
inline void MotionEstimationOptions_MixtureHomographyBounds::_internal_set_max_adjacent_outlier_blocks(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  max_adjacent_outlier_blocks_ = value;
}
inline void MotionEstimationOptions_MixtureHomographyBounds::set_max_adjacent_outlier_blocks(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_max_adjacent_outlier_blocks(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.MixtureHomographyBounds.max_adjacent_outlier_blocks)
}

// optional int32 max_adjacent_empty_blocks = 3 [default = 3];
inline bool MotionEstimationOptions_MixtureHomographyBounds::_internal_has_max_adjacent_empty_blocks() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MotionEstimationOptions_MixtureHomographyBounds::has_max_adjacent_empty_blocks() const {
  return _internal_has_max_adjacent_empty_blocks();
}
inline void MotionEstimationOptions_MixtureHomographyBounds::clear_max_adjacent_empty_blocks() {
  max_adjacent_empty_blocks_ = 3;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MotionEstimationOptions_MixtureHomographyBounds::_internal_max_adjacent_empty_blocks() const {
  return max_adjacent_empty_blocks_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MotionEstimationOptions_MixtureHomographyBounds::max_adjacent_empty_blocks() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.MixtureHomographyBounds.max_adjacent_empty_blocks)
  return _internal_max_adjacent_empty_blocks();
}
inline void MotionEstimationOptions_MixtureHomographyBounds::_internal_set_max_adjacent_empty_blocks(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  max_adjacent_empty_blocks_ = value;
}
inline void MotionEstimationOptions_MixtureHomographyBounds::set_max_adjacent_empty_blocks(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_max_adjacent_empty_blocks(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.MixtureHomographyBounds.max_adjacent_empty_blocks)
}

// optional float frac_inlier_threshold = 7 [default = 0.0025];
inline bool MotionEstimationOptions_MixtureHomographyBounds::_internal_has_frac_inlier_threshold() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MotionEstimationOptions_MixtureHomographyBounds::has_frac_inlier_threshold() const {
  return _internal_has_frac_inlier_threshold();
}
inline void MotionEstimationOptions_MixtureHomographyBounds::clear_frac_inlier_threshold() {
  frac_inlier_threshold_ = 0.0025f;
  _has_bits_[0] &= ~0x00000008u;
}
inline float MotionEstimationOptions_MixtureHomographyBounds::_internal_frac_inlier_threshold() const {
  return frac_inlier_threshold_;
}
inline float MotionEstimationOptions_MixtureHomographyBounds::frac_inlier_threshold() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.MixtureHomographyBounds.frac_inlier_threshold)
  return _internal_frac_inlier_threshold();
}
inline void MotionEstimationOptions_MixtureHomographyBounds::_internal_set_frac_inlier_threshold(float value) {
  _has_bits_[0] |= 0x00000008u;
  frac_inlier_threshold_ = value;
}
inline void MotionEstimationOptions_MixtureHomographyBounds::set_frac_inlier_threshold(float value) {
  _internal_set_frac_inlier_threshold(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.MixtureHomographyBounds.frac_inlier_threshold)
}

// -------------------------------------------------------------------

// MotionEstimationOptions_OverlayDetectionOptions

// optional int32 analysis_mask_size = 1 [default = 10];
inline bool MotionEstimationOptions_OverlayDetectionOptions::_internal_has_analysis_mask_size() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MotionEstimationOptions_OverlayDetectionOptions::has_analysis_mask_size() const {
  return _internal_has_analysis_mask_size();
}
inline void MotionEstimationOptions_OverlayDetectionOptions::clear_analysis_mask_size() {
  analysis_mask_size_ = 10;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MotionEstimationOptions_OverlayDetectionOptions::_internal_analysis_mask_size() const {
  return analysis_mask_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MotionEstimationOptions_OverlayDetectionOptions::analysis_mask_size() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.OverlayDetectionOptions.analysis_mask_size)
  return _internal_analysis_mask_size();
}
inline void MotionEstimationOptions_OverlayDetectionOptions::_internal_set_analysis_mask_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  analysis_mask_size_ = value;
}
inline void MotionEstimationOptions_OverlayDetectionOptions::set_analysis_mask_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_analysis_mask_size(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.OverlayDetectionOptions.analysis_mask_size)
}

// optional float strict_near_zero_motion = 2 [default = 0.2];
inline bool MotionEstimationOptions_OverlayDetectionOptions::_internal_has_strict_near_zero_motion() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MotionEstimationOptions_OverlayDetectionOptions::has_strict_near_zero_motion() const {
  return _internal_has_strict_near_zero_motion();
}
inline void MotionEstimationOptions_OverlayDetectionOptions::clear_strict_near_zero_motion() {
  strict_near_zero_motion_ = 0.2f;
  _has_bits_[0] &= ~0x00000004u;
}
inline float MotionEstimationOptions_OverlayDetectionOptions::_internal_strict_near_zero_motion() const {
  return strict_near_zero_motion_;
}
inline float MotionEstimationOptions_OverlayDetectionOptions::strict_near_zero_motion() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.OverlayDetectionOptions.strict_near_zero_motion)
  return _internal_strict_near_zero_motion();
}
inline void MotionEstimationOptions_OverlayDetectionOptions::_internal_set_strict_near_zero_motion(float value) {
  _has_bits_[0] |= 0x00000004u;
  strict_near_zero_motion_ = value;
}
inline void MotionEstimationOptions_OverlayDetectionOptions::set_strict_near_zero_motion(float value) {
  _internal_set_strict_near_zero_motion(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.OverlayDetectionOptions.strict_near_zero_motion)
}

// optional float strict_max_translation_ratio = 3 [default = 0.2];
inline bool MotionEstimationOptions_OverlayDetectionOptions::_internal_has_strict_max_translation_ratio() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MotionEstimationOptions_OverlayDetectionOptions::has_strict_max_translation_ratio() const {
  return _internal_has_strict_max_translation_ratio();
}
inline void MotionEstimationOptions_OverlayDetectionOptions::clear_strict_max_translation_ratio() {
  strict_max_translation_ratio_ = 0.2f;
  _has_bits_[0] &= ~0x00000008u;
}
inline float MotionEstimationOptions_OverlayDetectionOptions::_internal_strict_max_translation_ratio() const {
  return strict_max_translation_ratio_;
}
inline float MotionEstimationOptions_OverlayDetectionOptions::strict_max_translation_ratio() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.OverlayDetectionOptions.strict_max_translation_ratio)
  return _internal_strict_max_translation_ratio();
}
inline void MotionEstimationOptions_OverlayDetectionOptions::_internal_set_strict_max_translation_ratio(float value) {
  _has_bits_[0] |= 0x00000008u;
  strict_max_translation_ratio_ = value;
}
inline void MotionEstimationOptions_OverlayDetectionOptions::set_strict_max_translation_ratio(float value) {
  _internal_set_strict_max_translation_ratio(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.OverlayDetectionOptions.strict_max_translation_ratio)
}

// optional float strict_min_texturedness = 5 [default = 0.1];
inline bool MotionEstimationOptions_OverlayDetectionOptions::_internal_has_strict_min_texturedness() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MotionEstimationOptions_OverlayDetectionOptions::has_strict_min_texturedness() const {
  return _internal_has_strict_min_texturedness();
}
inline void MotionEstimationOptions_OverlayDetectionOptions::clear_strict_min_texturedness() {
  strict_min_texturedness_ = 0.1f;
  _has_bits_[0] &= ~0x00000020u;
}
inline float MotionEstimationOptions_OverlayDetectionOptions::_internal_strict_min_texturedness() const {
  return strict_min_texturedness_;
}
inline float MotionEstimationOptions_OverlayDetectionOptions::strict_min_texturedness() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.OverlayDetectionOptions.strict_min_texturedness)
  return _internal_strict_min_texturedness();
}
inline void MotionEstimationOptions_OverlayDetectionOptions::_internal_set_strict_min_texturedness(float value) {
  _has_bits_[0] |= 0x00000020u;
  strict_min_texturedness_ = value;
}
inline void MotionEstimationOptions_OverlayDetectionOptions::set_strict_min_texturedness(float value) {
  _internal_set_strict_min_texturedness(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.OverlayDetectionOptions.strict_min_texturedness)
}

// optional float loose_near_zero_motion = 4 [default = 1];
inline bool MotionEstimationOptions_OverlayDetectionOptions::_internal_has_loose_near_zero_motion() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MotionEstimationOptions_OverlayDetectionOptions::has_loose_near_zero_motion() const {
  return _internal_has_loose_near_zero_motion();
}
inline void MotionEstimationOptions_OverlayDetectionOptions::clear_loose_near_zero_motion() {
  loose_near_zero_motion_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline float MotionEstimationOptions_OverlayDetectionOptions::_internal_loose_near_zero_motion() const {
  return loose_near_zero_motion_;
}
inline float MotionEstimationOptions_OverlayDetectionOptions::loose_near_zero_motion() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.OverlayDetectionOptions.loose_near_zero_motion)
  return _internal_loose_near_zero_motion();
}
inline void MotionEstimationOptions_OverlayDetectionOptions::_internal_set_loose_near_zero_motion(float value) {
  _has_bits_[0] |= 0x00000010u;
  loose_near_zero_motion_ = value;
}
inline void MotionEstimationOptions_OverlayDetectionOptions::set_loose_near_zero_motion(float value) {
  _internal_set_loose_near_zero_motion(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.OverlayDetectionOptions.loose_near_zero_motion)
}

// optional float overlay_min_ratio = 6 [default = 0.3];
inline bool MotionEstimationOptions_OverlayDetectionOptions::_internal_has_overlay_min_ratio() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool MotionEstimationOptions_OverlayDetectionOptions::has_overlay_min_ratio() const {
  return _internal_has_overlay_min_ratio();
}
inline void MotionEstimationOptions_OverlayDetectionOptions::clear_overlay_min_ratio() {
  overlay_min_ratio_ = 0.3f;
  _has_bits_[0] &= ~0x00000040u;
}
inline float MotionEstimationOptions_OverlayDetectionOptions::_internal_overlay_min_ratio() const {
  return overlay_min_ratio_;
}
inline float MotionEstimationOptions_OverlayDetectionOptions::overlay_min_ratio() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.OverlayDetectionOptions.overlay_min_ratio)
  return _internal_overlay_min_ratio();
}
inline void MotionEstimationOptions_OverlayDetectionOptions::_internal_set_overlay_min_ratio(float value) {
  _has_bits_[0] |= 0x00000040u;
  overlay_min_ratio_ = value;
}
inline void MotionEstimationOptions_OverlayDetectionOptions::set_overlay_min_ratio(float value) {
  _internal_set_overlay_min_ratio(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.OverlayDetectionOptions.overlay_min_ratio)
}

// optional float overlay_min_features = 7 [default = 10];
inline bool MotionEstimationOptions_OverlayDetectionOptions::_internal_has_overlay_min_features() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MotionEstimationOptions_OverlayDetectionOptions::has_overlay_min_features() const {
  return _internal_has_overlay_min_features();
}
inline void MotionEstimationOptions_OverlayDetectionOptions::clear_overlay_min_features() {
  overlay_min_features_ = 10;
  _has_bits_[0] &= ~0x00000001u;
}
inline float MotionEstimationOptions_OverlayDetectionOptions::_internal_overlay_min_features() const {
  return overlay_min_features_;
}
inline float MotionEstimationOptions_OverlayDetectionOptions::overlay_min_features() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.OverlayDetectionOptions.overlay_min_features)
  return _internal_overlay_min_features();
}
inline void MotionEstimationOptions_OverlayDetectionOptions::_internal_set_overlay_min_features(float value) {
  _has_bits_[0] |= 0x00000001u;
  overlay_min_features_ = value;
}
inline void MotionEstimationOptions_OverlayDetectionOptions::set_overlay_min_features(float value) {
  _internal_set_overlay_min_features(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.OverlayDetectionOptions.overlay_min_features)
}

// -------------------------------------------------------------------

// MotionEstimationOptions_ShotBoundaryOptions

// optional float motion_consistency_threshold = 1 [default = 0.02];
inline bool MotionEstimationOptions_ShotBoundaryOptions::_internal_has_motion_consistency_threshold() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MotionEstimationOptions_ShotBoundaryOptions::has_motion_consistency_threshold() const {
  return _internal_has_motion_consistency_threshold();
}
inline void MotionEstimationOptions_ShotBoundaryOptions::clear_motion_consistency_threshold() {
  motion_consistency_threshold_ = 0.02f;
  _has_bits_[0] &= ~0x00000001u;
}
inline float MotionEstimationOptions_ShotBoundaryOptions::_internal_motion_consistency_threshold() const {
  return motion_consistency_threshold_;
}
inline float MotionEstimationOptions_ShotBoundaryOptions::motion_consistency_threshold() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.ShotBoundaryOptions.motion_consistency_threshold)
  return _internal_motion_consistency_threshold();
}
inline void MotionEstimationOptions_ShotBoundaryOptions::_internal_set_motion_consistency_threshold(float value) {
  _has_bits_[0] |= 0x00000001u;
  motion_consistency_threshold_ = value;
}
inline void MotionEstimationOptions_ShotBoundaryOptions::set_motion_consistency_threshold(float value) {
  _internal_set_motion_consistency_threshold(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.ShotBoundaryOptions.motion_consistency_threshold)
}

// optional float appearance_consistency_threshold = 2 [default = 0.075];
inline bool MotionEstimationOptions_ShotBoundaryOptions::_internal_has_appearance_consistency_threshold() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MotionEstimationOptions_ShotBoundaryOptions::has_appearance_consistency_threshold() const {
  return _internal_has_appearance_consistency_threshold();
}
inline void MotionEstimationOptions_ShotBoundaryOptions::clear_appearance_consistency_threshold() {
  appearance_consistency_threshold_ = 0.075f;
  _has_bits_[0] &= ~0x00000002u;
}
inline float MotionEstimationOptions_ShotBoundaryOptions::_internal_appearance_consistency_threshold() const {
  return appearance_consistency_threshold_;
}
inline float MotionEstimationOptions_ShotBoundaryOptions::appearance_consistency_threshold() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.ShotBoundaryOptions.appearance_consistency_threshold)
  return _internal_appearance_consistency_threshold();
}
inline void MotionEstimationOptions_ShotBoundaryOptions::_internal_set_appearance_consistency_threshold(float value) {
  _has_bits_[0] |= 0x00000002u;
  appearance_consistency_threshold_ = value;
}
inline void MotionEstimationOptions_ShotBoundaryOptions::set_appearance_consistency_threshold(float value) {
  _internal_set_appearance_consistency_threshold(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.ShotBoundaryOptions.appearance_consistency_threshold)
}

// -------------------------------------------------------------------

// MotionEstimationOptions

// optional bool estimate_translation_irls = 1 [default = true];
inline bool MotionEstimationOptions::_internal_has_estimate_translation_irls() const {
  bool value = (_has_bits_[1] & 0x00000040u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_estimate_translation_irls() const {
  return _internal_has_estimate_translation_irls();
}
inline void MotionEstimationOptions::clear_estimate_translation_irls() {
  estimate_translation_irls_ = true;
  _has_bits_[1] &= ~0x00000040u;
}
inline bool MotionEstimationOptions::_internal_estimate_translation_irls() const {
  return estimate_translation_irls_;
}
inline bool MotionEstimationOptions::estimate_translation_irls() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.estimate_translation_irls)
  return _internal_estimate_translation_irls();
}
inline void MotionEstimationOptions::_internal_set_estimate_translation_irls(bool value) {
  _has_bits_[1] |= 0x00000040u;
  estimate_translation_irls_ = value;
}
inline void MotionEstimationOptions::set_estimate_translation_irls(bool value) {
  _internal_set_estimate_translation_irls(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.estimate_translation_irls)
}

// optional .mediapipe.MotionEstimationOptions.LinearSimilarityEstimation linear_similarity_estimation = 3 [default = ESTIMATION_LS_IRLS];
inline bool MotionEstimationOptions::_internal_has_linear_similarity_estimation() const {
  bool value = (_has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_linear_similarity_estimation() const {
  return _internal_has_linear_similarity_estimation();
}
inline void MotionEstimationOptions::clear_linear_similarity_estimation() {
  linear_similarity_estimation_ = 4;
  _has_bits_[0] &= ~0x02000000u;
}
inline ::mediapipe::MotionEstimationOptions_LinearSimilarityEstimation MotionEstimationOptions::_internal_linear_similarity_estimation() const {
  return static_cast< ::mediapipe::MotionEstimationOptions_LinearSimilarityEstimation >(linear_similarity_estimation_);
}
inline ::mediapipe::MotionEstimationOptions_LinearSimilarityEstimation MotionEstimationOptions::linear_similarity_estimation() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.linear_similarity_estimation)
  return _internal_linear_similarity_estimation();
}
inline void MotionEstimationOptions::_internal_set_linear_similarity_estimation(::mediapipe::MotionEstimationOptions_LinearSimilarityEstimation value) {
  assert(::mediapipe::MotionEstimationOptions_LinearSimilarityEstimation_IsValid(value));
  _has_bits_[0] |= 0x02000000u;
  linear_similarity_estimation_ = value;
}
inline void MotionEstimationOptions::set_linear_similarity_estimation(::mediapipe::MotionEstimationOptions_LinearSimilarityEstimation value) {
  _internal_set_linear_similarity_estimation(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.linear_similarity_estimation)
}

// optional .mediapipe.MotionEstimationOptions.AffineEstimation affine_estimation = 30 [default = ESTIMATION_AFFINE_NONE];
inline bool MotionEstimationOptions::_internal_has_affine_estimation() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_affine_estimation() const {
  return _internal_has_affine_estimation();
}
inline void MotionEstimationOptions::clear_affine_estimation() {
  affine_estimation_ = 0;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::mediapipe::MotionEstimationOptions_AffineEstimation MotionEstimationOptions::_internal_affine_estimation() const {
  return static_cast< ::mediapipe::MotionEstimationOptions_AffineEstimation >(affine_estimation_);
}
inline ::mediapipe::MotionEstimationOptions_AffineEstimation MotionEstimationOptions::affine_estimation() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.affine_estimation)
  return _internal_affine_estimation();
}
inline void MotionEstimationOptions::_internal_set_affine_estimation(::mediapipe::MotionEstimationOptions_AffineEstimation value) {
  assert(::mediapipe::MotionEstimationOptions_AffineEstimation_IsValid(value));
  _has_bits_[0] |= 0x00004000u;
  affine_estimation_ = value;
}
inline void MotionEstimationOptions::set_affine_estimation(::mediapipe::MotionEstimationOptions_AffineEstimation value) {
  _internal_set_affine_estimation(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.affine_estimation)
}

// optional .mediapipe.MotionEstimationOptions.HomographyEstimation homography_estimation = 5 [default = ESTIMATION_HOMOG_IRLS];
inline bool MotionEstimationOptions::_internal_has_homography_estimation() const {
  bool value = (_has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_homography_estimation() const {
  return _internal_has_homography_estimation();
}
inline void MotionEstimationOptions::clear_homography_estimation() {
  homography_estimation_ = 2;
  _has_bits_[0] &= ~0x04000000u;
}
inline ::mediapipe::MotionEstimationOptions_HomographyEstimation MotionEstimationOptions::_internal_homography_estimation() const {
  return static_cast< ::mediapipe::MotionEstimationOptions_HomographyEstimation >(homography_estimation_);
}
inline ::mediapipe::MotionEstimationOptions_HomographyEstimation MotionEstimationOptions::homography_estimation() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.homography_estimation)
  return _internal_homography_estimation();
}
inline void MotionEstimationOptions::_internal_set_homography_estimation(::mediapipe::MotionEstimationOptions_HomographyEstimation value) {
  assert(::mediapipe::MotionEstimationOptions_HomographyEstimation_IsValid(value));
  _has_bits_[0] |= 0x04000000u;
  homography_estimation_ = value;
}
inline void MotionEstimationOptions::set_homography_estimation(::mediapipe::MotionEstimationOptions_HomographyEstimation value) {
  _internal_set_homography_estimation(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.homography_estimation)
}

// optional bool homography_exact_denominator_scaling = 53 [default = false];
inline bool MotionEstimationOptions::_internal_has_homography_exact_denominator_scaling() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_homography_exact_denominator_scaling() const {
  return _internal_has_homography_exact_denominator_scaling();
}
inline void MotionEstimationOptions::clear_homography_exact_denominator_scaling() {
  homography_exact_denominator_scaling_ = false;
  _has_bits_[0] &= ~0x00100000u;
}
inline bool MotionEstimationOptions::_internal_homography_exact_denominator_scaling() const {
  return homography_exact_denominator_scaling_;
}
inline bool MotionEstimationOptions::homography_exact_denominator_scaling() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.homography_exact_denominator_scaling)
  return _internal_homography_exact_denominator_scaling();
}
inline void MotionEstimationOptions::_internal_set_homography_exact_denominator_scaling(bool value) {
  _has_bits_[0] |= 0x00100000u;
  homography_exact_denominator_scaling_ = value;
}
inline void MotionEstimationOptions::set_homography_exact_denominator_scaling(bool value) {
  _internal_set_homography_exact_denominator_scaling(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.homography_exact_denominator_scaling)
}

// optional bool use_exact_homography_estimation = 54 [default = true];
inline bool MotionEstimationOptions::_internal_has_use_exact_homography_estimation() const {
  bool value = (_has_bits_[1] & 0x00000080u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_use_exact_homography_estimation() const {
  return _internal_has_use_exact_homography_estimation();
}
inline void MotionEstimationOptions::clear_use_exact_homography_estimation() {
  use_exact_homography_estimation_ = true;
  _has_bits_[1] &= ~0x00000080u;
}
inline bool MotionEstimationOptions::_internal_use_exact_homography_estimation() const {
  return use_exact_homography_estimation_;
}
inline bool MotionEstimationOptions::use_exact_homography_estimation() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.use_exact_homography_estimation)
  return _internal_use_exact_homography_estimation();
}
inline void MotionEstimationOptions::_internal_set_use_exact_homography_estimation(bool value) {
  _has_bits_[1] |= 0x00000080u;
  use_exact_homography_estimation_ = value;
}
inline void MotionEstimationOptions::set_use_exact_homography_estimation(bool value) {
  _internal_set_use_exact_homography_estimation(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.use_exact_homography_estimation)
}

// optional bool use_highest_accuracy_for_normal_equations = 55 [default = true];
inline bool MotionEstimationOptions::_internal_has_use_highest_accuracy_for_normal_equations() const {
  bool value = (_has_bits_[1] & 0x00000100u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_use_highest_accuracy_for_normal_equations() const {
  return _internal_has_use_highest_accuracy_for_normal_equations();
}
inline void MotionEstimationOptions::clear_use_highest_accuracy_for_normal_equations() {
  use_highest_accuracy_for_normal_equations_ = true;
  _has_bits_[1] &= ~0x00000100u;
}
inline bool MotionEstimationOptions::_internal_use_highest_accuracy_for_normal_equations() const {
  return use_highest_accuracy_for_normal_equations_;
}
inline bool MotionEstimationOptions::use_highest_accuracy_for_normal_equations() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.use_highest_accuracy_for_normal_equations)
  return _internal_use_highest_accuracy_for_normal_equations();
}
inline void MotionEstimationOptions::_internal_set_use_highest_accuracy_for_normal_equations(bool value) {
  _has_bits_[1] |= 0x00000100u;
  use_highest_accuracy_for_normal_equations_ = value;
}
inline void MotionEstimationOptions::set_use_highest_accuracy_for_normal_equations(bool value) {
  _internal_set_use_highest_accuracy_for_normal_equations(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.use_highest_accuracy_for_normal_equations)
}

// optional float homography_perspective_regularizer = 61 [default = 0];
inline bool MotionEstimationOptions::_internal_has_homography_perspective_regularizer() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_homography_perspective_regularizer() const {
  return _internal_has_homography_perspective_regularizer();
}
inline void MotionEstimationOptions::clear_homography_perspective_regularizer() {
  homography_perspective_regularizer_ = 0;
  _has_bits_[0] &= ~0x01000000u;
}
inline float MotionEstimationOptions::_internal_homography_perspective_regularizer() const {
  return homography_perspective_regularizer_;
}
inline float MotionEstimationOptions::homography_perspective_regularizer() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.homography_perspective_regularizer)
  return _internal_homography_perspective_regularizer();
}
inline void MotionEstimationOptions::_internal_set_homography_perspective_regularizer(float value) {
  _has_bits_[0] |= 0x01000000u;
  homography_perspective_regularizer_ = value;
}
inline void MotionEstimationOptions::set_homography_perspective_regularizer(float value) {
  _internal_set_homography_perspective_regularizer(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.homography_perspective_regularizer)
}

// optional .mediapipe.MotionEstimationOptions.MixtureHomographyEstimation mix_homography_estimation = 12 [default = ESTIMATION_HOMOG_MIX_NONE];
inline bool MotionEstimationOptions::_internal_has_mix_homography_estimation() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_mix_homography_estimation() const {
  return _internal_has_mix_homography_estimation();
}
inline void MotionEstimationOptions::clear_mix_homography_estimation() {
  mix_homography_estimation_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::mediapipe::MotionEstimationOptions_MixtureHomographyEstimation MotionEstimationOptions::_internal_mix_homography_estimation() const {
  return static_cast< ::mediapipe::MotionEstimationOptions_MixtureHomographyEstimation >(mix_homography_estimation_);
}
inline ::mediapipe::MotionEstimationOptions_MixtureHomographyEstimation MotionEstimationOptions::mix_homography_estimation() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.mix_homography_estimation)
  return _internal_mix_homography_estimation();
}
inline void MotionEstimationOptions::_internal_set_mix_homography_estimation(::mediapipe::MotionEstimationOptions_MixtureHomographyEstimation value) {
  assert(::mediapipe::MotionEstimationOptions_MixtureHomographyEstimation_IsValid(value));
  _has_bits_[0] |= 0x00000800u;
  mix_homography_estimation_ = value;
}
inline void MotionEstimationOptions::set_mix_homography_estimation(::mediapipe::MotionEstimationOptions_MixtureHomographyEstimation value) {
  _internal_set_mix_homography_estimation(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.mix_homography_estimation)
}

// optional int32 num_mixtures = 13 [default = 10];
inline bool MotionEstimationOptions::_internal_has_num_mixtures() const {
  bool value = (_has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_num_mixtures() const {
  return _internal_has_num_mixtures();
}
inline void MotionEstimationOptions::clear_num_mixtures() {
  num_mixtures_ = 10;
  _has_bits_[0] &= ~0x08000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MotionEstimationOptions::_internal_num_mixtures() const {
  return num_mixtures_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MotionEstimationOptions::num_mixtures() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.num_mixtures)
  return _internal_num_mixtures();
}
inline void MotionEstimationOptions::_internal_set_num_mixtures(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x08000000u;
  num_mixtures_ = value;
}
inline void MotionEstimationOptions::set_num_mixtures(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_mixtures(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.num_mixtures)
}

// optional float mixture_row_sigma = 14 [default = 0.1];
inline bool MotionEstimationOptions::_internal_has_mixture_row_sigma() const {
  bool value = (_has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_mixture_row_sigma() const {
  return _internal_has_mixture_row_sigma();
}
inline void MotionEstimationOptions::clear_mixture_row_sigma() {
  mixture_row_sigma_ = 0.1f;
  _has_bits_[0] &= ~0x10000000u;
}
inline float MotionEstimationOptions::_internal_mixture_row_sigma() const {
  return mixture_row_sigma_;
}
inline float MotionEstimationOptions::mixture_row_sigma() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.mixture_row_sigma)
  return _internal_mixture_row_sigma();
}
inline void MotionEstimationOptions::_internal_set_mixture_row_sigma(float value) {
  _has_bits_[0] |= 0x10000000u;
  mixture_row_sigma_ = value;
}
inline void MotionEstimationOptions::set_mixture_row_sigma(float value) {
  _internal_set_mixture_row_sigma(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.mixture_row_sigma)
}

// optional float mixture_regularizer = 15 [default = 0.0001];
inline bool MotionEstimationOptions::_internal_has_mixture_regularizer() const {
  bool value = (_has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_mixture_regularizer() const {
  return _internal_has_mixture_regularizer();
}
inline void MotionEstimationOptions::clear_mixture_regularizer() {
  mixture_regularizer_ = 0.0001f;
  _has_bits_[0] &= ~0x20000000u;
}
inline float MotionEstimationOptions::_internal_mixture_regularizer() const {
  return mixture_regularizer_;
}
inline float MotionEstimationOptions::mixture_regularizer() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.mixture_regularizer)
  return _internal_mixture_regularizer();
}
inline void MotionEstimationOptions::_internal_set_mixture_regularizer(float value) {
  _has_bits_[0] |= 0x20000000u;
  mixture_regularizer_ = value;
}
inline void MotionEstimationOptions::set_mixture_regularizer(float value) {
  _internal_set_mixture_regularizer(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.mixture_regularizer)
}

// optional float mixture_regularizer_levels = 42 [default = 3];
inline bool MotionEstimationOptions::_internal_has_mixture_regularizer_levels() const {
  bool value = (_has_bits_[1] & 0x00020000u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_mixture_regularizer_levels() const {
  return _internal_has_mixture_regularizer_levels();
}
inline void MotionEstimationOptions::clear_mixture_regularizer_levels() {
  mixture_regularizer_levels_ = 3;
  _has_bits_[1] &= ~0x00020000u;
}
inline float MotionEstimationOptions::_internal_mixture_regularizer_levels() const {
  return mixture_regularizer_levels_;
}
inline float MotionEstimationOptions::mixture_regularizer_levels() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.mixture_regularizer_levels)
  return _internal_mixture_regularizer_levels();
}
inline void MotionEstimationOptions::_internal_set_mixture_regularizer_levels(float value) {
  _has_bits_[1] |= 0x00020000u;
  mixture_regularizer_levels_ = value;
}
inline void MotionEstimationOptions::set_mixture_regularizer_levels(float value) {
  _internal_set_mixture_regularizer_levels(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.mixture_regularizer_levels)
}

// optional float mixture_regularizer_base = 43 [default = 2.2];
inline bool MotionEstimationOptions::_internal_has_mixture_regularizer_base() const {
  bool value = (_has_bits_[1] & 0x00040000u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_mixture_regularizer_base() const {
  return _internal_has_mixture_regularizer_base();
}
inline void MotionEstimationOptions::clear_mixture_regularizer_base() {
  mixture_regularizer_base_ = 2.2f;
  _has_bits_[1] &= ~0x00040000u;
}
inline float MotionEstimationOptions::_internal_mixture_regularizer_base() const {
  return mixture_regularizer_base_;
}
inline float MotionEstimationOptions::mixture_regularizer_base() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.mixture_regularizer_base)
  return _internal_mixture_regularizer_base();
}
inline void MotionEstimationOptions::_internal_set_mixture_regularizer_base(float value) {
  _has_bits_[1] |= 0x00040000u;
  mixture_regularizer_base_ = value;
}
inline void MotionEstimationOptions::set_mixture_regularizer_base(float value) {
  _internal_set_mixture_regularizer_base(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.mixture_regularizer_base)
}

// optional int32 mixture_rs_analysis_level = 44 [default = 2];
inline bool MotionEstimationOptions::_internal_has_mixture_rs_analysis_level() const {
  bool value = (_has_bits_[1] & 0x00080000u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_mixture_rs_analysis_level() const {
  return _internal_has_mixture_rs_analysis_level();
}
inline void MotionEstimationOptions::clear_mixture_rs_analysis_level() {
  mixture_rs_analysis_level_ = 2;
  _has_bits_[1] &= ~0x00080000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MotionEstimationOptions::_internal_mixture_rs_analysis_level() const {
  return mixture_rs_analysis_level_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MotionEstimationOptions::mixture_rs_analysis_level() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.mixture_rs_analysis_level)
  return _internal_mixture_rs_analysis_level();
}
inline void MotionEstimationOptions::_internal_set_mixture_rs_analysis_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[1] |= 0x00080000u;
  mixture_rs_analysis_level_ = value;
}
inline void MotionEstimationOptions::set_mixture_rs_analysis_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_mixture_rs_analysis_level(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.mixture_rs_analysis_level)
}

// optional int32 irls_rounds = 17 [default = 10];
inline bool MotionEstimationOptions::_internal_has_irls_rounds() const {
  bool value = (_has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_irls_rounds() const {
  return _internal_has_irls_rounds();
}
inline void MotionEstimationOptions::clear_irls_rounds() {
  irls_rounds_ = 10;
  _has_bits_[0] &= ~0x40000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MotionEstimationOptions::_internal_irls_rounds() const {
  return irls_rounds_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MotionEstimationOptions::irls_rounds() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.irls_rounds)
  return _internal_irls_rounds();
}
inline void MotionEstimationOptions::_internal_set_irls_rounds(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x40000000u;
  irls_rounds_ = value;
}
inline void MotionEstimationOptions::set_irls_rounds(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_irls_rounds(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.irls_rounds)
}

// optional float irls_prior_scale = 50 [default = 0.2];
inline bool MotionEstimationOptions::_internal_has_irls_prior_scale() const {
  bool value = (_has_bits_[1] & 0x00400000u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_irls_prior_scale() const {
  return _internal_has_irls_prior_scale();
}
inline void MotionEstimationOptions::clear_irls_prior_scale() {
  irls_prior_scale_ = 0.2f;
  _has_bits_[1] &= ~0x00400000u;
}
inline float MotionEstimationOptions::_internal_irls_prior_scale() const {
  return irls_prior_scale_;
}
inline float MotionEstimationOptions::irls_prior_scale() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.irls_prior_scale)
  return _internal_irls_prior_scale();
}
inline void MotionEstimationOptions::_internal_set_irls_prior_scale(float value) {
  _has_bits_[1] |= 0x00400000u;
  irls_prior_scale_ = value;
}
inline void MotionEstimationOptions::set_irls_prior_scale(float value) {
  _internal_set_irls_prior_scale(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.irls_prior_scale)
}

// optional float irls_motion_magnitude_fraction = 31 [default = 0.08];
inline bool MotionEstimationOptions::_internal_has_irls_motion_magnitude_fraction() const {
  bool value = (_has_bits_[1] & 0x00000400u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_irls_motion_magnitude_fraction() const {
  return _internal_has_irls_motion_magnitude_fraction();
}
inline void MotionEstimationOptions::clear_irls_motion_magnitude_fraction() {
  irls_motion_magnitude_fraction_ = 0.08f;
  _has_bits_[1] &= ~0x00000400u;
}
inline float MotionEstimationOptions::_internal_irls_motion_magnitude_fraction() const {
  return irls_motion_magnitude_fraction_;
}
inline float MotionEstimationOptions::irls_motion_magnitude_fraction() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.irls_motion_magnitude_fraction)
  return _internal_irls_motion_magnitude_fraction();
}
inline void MotionEstimationOptions::_internal_set_irls_motion_magnitude_fraction(float value) {
  _has_bits_[1] |= 0x00000400u;
  irls_motion_magnitude_fraction_ = value;
}
inline void MotionEstimationOptions::set_irls_motion_magnitude_fraction(float value) {
  _internal_set_irls_motion_magnitude_fraction(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.irls_motion_magnitude_fraction)
}

// optional float irls_mixture_fraction_scale = 68 [default = 1.5];
inline bool MotionEstimationOptions::_internal_has_irls_mixture_fraction_scale() const {
  bool value = (_has_bits_[1] & 0x04000000u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_irls_mixture_fraction_scale() const {
  return _internal_has_irls_mixture_fraction_scale();
}
inline void MotionEstimationOptions::clear_irls_mixture_fraction_scale() {
  irls_mixture_fraction_scale_ = 1.5f;
  _has_bits_[1] &= ~0x04000000u;
}
inline float MotionEstimationOptions::_internal_irls_mixture_fraction_scale() const {
  return irls_mixture_fraction_scale_;
}
inline float MotionEstimationOptions::irls_mixture_fraction_scale() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.irls_mixture_fraction_scale)
  return _internal_irls_mixture_fraction_scale();
}
inline void MotionEstimationOptions::_internal_set_irls_mixture_fraction_scale(float value) {
  _has_bits_[1] |= 0x04000000u;
  irls_mixture_fraction_scale_ = value;
}
inline void MotionEstimationOptions::set_irls_mixture_fraction_scale(float value) {
  _internal_set_irls_mixture_fraction_scale(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.irls_mixture_fraction_scale)
}

// optional bool irls_weights_preinitialized = 39 [default = false];
inline bool MotionEstimationOptions::_internal_has_irls_weights_preinitialized() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_irls_weights_preinitialized() const {
  return _internal_has_irls_weights_preinitialized();
}
inline void MotionEstimationOptions::clear_irls_weights_preinitialized() {
  irls_weights_preinitialized_ = false;
  _has_bits_[0] &= ~0x00200000u;
}
inline bool MotionEstimationOptions::_internal_irls_weights_preinitialized() const {
  return irls_weights_preinitialized_;
}
inline bool MotionEstimationOptions::irls_weights_preinitialized() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.irls_weights_preinitialized)
  return _internal_irls_weights_preinitialized();
}
inline void MotionEstimationOptions::_internal_set_irls_weights_preinitialized(bool value) {
  _has_bits_[0] |= 0x00200000u;
  irls_weights_preinitialized_ = value;
}
inline void MotionEstimationOptions::set_irls_weights_preinitialized(bool value) {
  _internal_set_irls_weights_preinitialized(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.irls_weights_preinitialized)
}

// optional bool filter_initialized_irls_weights = 67 [default = false];
inline bool MotionEstimationOptions::_internal_has_filter_initialized_irls_weights() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_filter_initialized_irls_weights() const {
  return _internal_has_filter_initialized_irls_weights();
}
inline void MotionEstimationOptions::clear_filter_initialized_irls_weights() {
  filter_initialized_irls_weights_ = false;
  _has_bits_[0] &= ~0x00400000u;
}
inline bool MotionEstimationOptions::_internal_filter_initialized_irls_weights() const {
  return filter_initialized_irls_weights_;
}
inline bool MotionEstimationOptions::filter_initialized_irls_weights() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.filter_initialized_irls_weights)
  return _internal_filter_initialized_irls_weights();
}
inline void MotionEstimationOptions::_internal_set_filter_initialized_irls_weights(bool value) {
  _has_bits_[0] |= 0x00400000u;
  filter_initialized_irls_weights_ = value;
}
inline void MotionEstimationOptions::set_filter_initialized_irls_weights(bool value) {
  _internal_set_filter_initialized_irls_weights(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.filter_initialized_irls_weights)
}

// optional .mediapipe.MotionEstimationOptions.IrlsOutlierInitialization irls_initialization = 56;
inline bool MotionEstimationOptions::_internal_has_irls_initialization() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || irls_initialization_ != nullptr);
  return value;
}
inline bool MotionEstimationOptions::has_irls_initialization() const {
  return _internal_has_irls_initialization();
}
inline void MotionEstimationOptions::clear_irls_initialization() {
  if (irls_initialization_ != nullptr) irls_initialization_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization& MotionEstimationOptions::_internal_irls_initialization() const {
  const ::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization* p = irls_initialization_;
  return p != nullptr ? *p : reinterpret_cast<const ::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization&>(
      ::mediapipe::_MotionEstimationOptions_IrlsOutlierInitialization_default_instance_);
}
inline const ::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization& MotionEstimationOptions::irls_initialization() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.irls_initialization)
  return _internal_irls_initialization();
}
inline void MotionEstimationOptions::unsafe_arena_set_allocated_irls_initialization(
    ::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization* irls_initialization) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(irls_initialization_);
  }
  irls_initialization_ = irls_initialization;
  if (irls_initialization) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mediapipe.MotionEstimationOptions.irls_initialization)
}
inline ::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization* MotionEstimationOptions::release_irls_initialization() {
  _has_bits_[0] &= ~0x00000020u;
  ::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization* temp = irls_initialization_;
  irls_initialization_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization* MotionEstimationOptions::unsafe_arena_release_irls_initialization() {
  // @@protoc_insertion_point(field_release:mediapipe.MotionEstimationOptions.irls_initialization)
  _has_bits_[0] &= ~0x00000020u;
  ::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization* temp = irls_initialization_;
  irls_initialization_ = nullptr;
  return temp;
}
inline ::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization* MotionEstimationOptions::_internal_mutable_irls_initialization() {
  _has_bits_[0] |= 0x00000020u;
  if (irls_initialization_ == nullptr) {
    auto* p = CreateMaybeMessage<::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization>(GetArena());
    irls_initialization_ = p;
  }
  return irls_initialization_;
}
inline ::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization* MotionEstimationOptions::mutable_irls_initialization() {
  // @@protoc_insertion_point(field_mutable:mediapipe.MotionEstimationOptions.irls_initialization)
  return _internal_mutable_irls_initialization();
}
inline void MotionEstimationOptions::set_allocated_irls_initialization(::mediapipe::MotionEstimationOptions_IrlsOutlierInitialization* irls_initialization) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete irls_initialization_;
  }
  if (irls_initialization) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(irls_initialization);
    if (message_arena != submessage_arena) {
      irls_initialization = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, irls_initialization, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  irls_initialization_ = irls_initialization;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.MotionEstimationOptions.irls_initialization)
}

// optional bool feature_density_normalization = 62 [default = false];
inline bool MotionEstimationOptions::_internal_has_feature_density_normalization() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_feature_density_normalization() const {
  return _internal_has_feature_density_normalization();
}
inline void MotionEstimationOptions::clear_feature_density_normalization() {
  feature_density_normalization_ = false;
  _has_bits_[0] &= ~0x00800000u;
}
inline bool MotionEstimationOptions::_internal_feature_density_normalization() const {
  return feature_density_normalization_;
}
inline bool MotionEstimationOptions::feature_density_normalization() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.feature_density_normalization)
  return _internal_feature_density_normalization();
}
inline void MotionEstimationOptions::_internal_set_feature_density_normalization(bool value) {
  _has_bits_[0] |= 0x00800000u;
  feature_density_normalization_ = value;
}
inline void MotionEstimationOptions::set_feature_density_normalization(bool value) {
  _internal_set_feature_density_normalization(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.feature_density_normalization)
}

// optional int32 feature_mask_size = 63 [default = 10];
inline bool MotionEstimationOptions::_internal_has_feature_mask_size() const {
  bool value = (_has_bits_[1] & 0x02000000u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_feature_mask_size() const {
  return _internal_has_feature_mask_size();
}
inline void MotionEstimationOptions::clear_feature_mask_size() {
  feature_mask_size_ = 10;
  _has_bits_[1] &= ~0x02000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MotionEstimationOptions::_internal_feature_mask_size() const {
  return feature_mask_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MotionEstimationOptions::feature_mask_size() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.feature_mask_size)
  return _internal_feature_mask_size();
}
inline void MotionEstimationOptions::_internal_set_feature_mask_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[1] |= 0x02000000u;
  feature_mask_size_ = value;
}
inline void MotionEstimationOptions::set_feature_mask_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_feature_mask_size(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.feature_mask_size)
}

// optional .mediapipe.MotionEstimationOptions.LongFeatureInitialization long_feature_initialization = 66;
inline bool MotionEstimationOptions::_internal_has_long_feature_initialization() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || long_feature_initialization_ != nullptr);
  return value;
}
inline bool MotionEstimationOptions::has_long_feature_initialization() const {
  return _internal_has_long_feature_initialization();
}
inline void MotionEstimationOptions::clear_long_feature_initialization() {
  if (long_feature_initialization_ != nullptr) long_feature_initialization_->Clear();
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::mediapipe::MotionEstimationOptions_LongFeatureInitialization& MotionEstimationOptions::_internal_long_feature_initialization() const {
  const ::mediapipe::MotionEstimationOptions_LongFeatureInitialization* p = long_feature_initialization_;
  return p != nullptr ? *p : reinterpret_cast<const ::mediapipe::MotionEstimationOptions_LongFeatureInitialization&>(
      ::mediapipe::_MotionEstimationOptions_LongFeatureInitialization_default_instance_);
}
inline const ::mediapipe::MotionEstimationOptions_LongFeatureInitialization& MotionEstimationOptions::long_feature_initialization() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.long_feature_initialization)
  return _internal_long_feature_initialization();
}
inline void MotionEstimationOptions::unsafe_arena_set_allocated_long_feature_initialization(
    ::mediapipe::MotionEstimationOptions_LongFeatureInitialization* long_feature_initialization) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(long_feature_initialization_);
  }
  long_feature_initialization_ = long_feature_initialization;
  if (long_feature_initialization) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mediapipe.MotionEstimationOptions.long_feature_initialization)
}
inline ::mediapipe::MotionEstimationOptions_LongFeatureInitialization* MotionEstimationOptions::release_long_feature_initialization() {
  _has_bits_[0] &= ~0x00000400u;
  ::mediapipe::MotionEstimationOptions_LongFeatureInitialization* temp = long_feature_initialization_;
  long_feature_initialization_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mediapipe::MotionEstimationOptions_LongFeatureInitialization* MotionEstimationOptions::unsafe_arena_release_long_feature_initialization() {
  // @@protoc_insertion_point(field_release:mediapipe.MotionEstimationOptions.long_feature_initialization)
  _has_bits_[0] &= ~0x00000400u;
  ::mediapipe::MotionEstimationOptions_LongFeatureInitialization* temp = long_feature_initialization_;
  long_feature_initialization_ = nullptr;
  return temp;
}
inline ::mediapipe::MotionEstimationOptions_LongFeatureInitialization* MotionEstimationOptions::_internal_mutable_long_feature_initialization() {
  _has_bits_[0] |= 0x00000400u;
  if (long_feature_initialization_ == nullptr) {
    auto* p = CreateMaybeMessage<::mediapipe::MotionEstimationOptions_LongFeatureInitialization>(GetArena());
    long_feature_initialization_ = p;
  }
  return long_feature_initialization_;
}
inline ::mediapipe::MotionEstimationOptions_LongFeatureInitialization* MotionEstimationOptions::mutable_long_feature_initialization() {
  // @@protoc_insertion_point(field_mutable:mediapipe.MotionEstimationOptions.long_feature_initialization)
  return _internal_mutable_long_feature_initialization();
}
inline void MotionEstimationOptions::set_allocated_long_feature_initialization(::mediapipe::MotionEstimationOptions_LongFeatureInitialization* long_feature_initialization) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete long_feature_initialization_;
  }
  if (long_feature_initialization) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(long_feature_initialization);
    if (message_arena != submessage_arena) {
      long_feature_initialization = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, long_feature_initialization, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  long_feature_initialization_ = long_feature_initialization;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.MotionEstimationOptions.long_feature_initialization)
}

// optional .mediapipe.MotionEstimationOptions.IrlsMaskOptions irls_mask_options = 57;
inline bool MotionEstimationOptions::_internal_has_irls_mask_options() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || irls_mask_options_ != nullptr);
  return value;
}
inline bool MotionEstimationOptions::has_irls_mask_options() const {
  return _internal_has_irls_mask_options();
}
inline void MotionEstimationOptions::clear_irls_mask_options() {
  if (irls_mask_options_ != nullptr) irls_mask_options_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::mediapipe::MotionEstimationOptions_IrlsMaskOptions& MotionEstimationOptions::_internal_irls_mask_options() const {
  const ::mediapipe::MotionEstimationOptions_IrlsMaskOptions* p = irls_mask_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::mediapipe::MotionEstimationOptions_IrlsMaskOptions&>(
      ::mediapipe::_MotionEstimationOptions_IrlsMaskOptions_default_instance_);
}
inline const ::mediapipe::MotionEstimationOptions_IrlsMaskOptions& MotionEstimationOptions::irls_mask_options() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.irls_mask_options)
  return _internal_irls_mask_options();
}
inline void MotionEstimationOptions::unsafe_arena_set_allocated_irls_mask_options(
    ::mediapipe::MotionEstimationOptions_IrlsMaskOptions* irls_mask_options) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(irls_mask_options_);
  }
  irls_mask_options_ = irls_mask_options;
  if (irls_mask_options) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mediapipe.MotionEstimationOptions.irls_mask_options)
}
inline ::mediapipe::MotionEstimationOptions_IrlsMaskOptions* MotionEstimationOptions::release_irls_mask_options() {
  _has_bits_[0] &= ~0x00000040u;
  ::mediapipe::MotionEstimationOptions_IrlsMaskOptions* temp = irls_mask_options_;
  irls_mask_options_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mediapipe::MotionEstimationOptions_IrlsMaskOptions* MotionEstimationOptions::unsafe_arena_release_irls_mask_options() {
  // @@protoc_insertion_point(field_release:mediapipe.MotionEstimationOptions.irls_mask_options)
  _has_bits_[0] &= ~0x00000040u;
  ::mediapipe::MotionEstimationOptions_IrlsMaskOptions* temp = irls_mask_options_;
  irls_mask_options_ = nullptr;
  return temp;
}
inline ::mediapipe::MotionEstimationOptions_IrlsMaskOptions* MotionEstimationOptions::_internal_mutable_irls_mask_options() {
  _has_bits_[0] |= 0x00000040u;
  if (irls_mask_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::mediapipe::MotionEstimationOptions_IrlsMaskOptions>(GetArena());
    irls_mask_options_ = p;
  }
  return irls_mask_options_;
}
inline ::mediapipe::MotionEstimationOptions_IrlsMaskOptions* MotionEstimationOptions::mutable_irls_mask_options() {
  // @@protoc_insertion_point(field_mutable:mediapipe.MotionEstimationOptions.irls_mask_options)
  return _internal_mutable_irls_mask_options();
}
inline void MotionEstimationOptions::set_allocated_irls_mask_options(::mediapipe::MotionEstimationOptions_IrlsMaskOptions* irls_mask_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete irls_mask_options_;
  }
  if (irls_mask_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(irls_mask_options);
    if (message_arena != submessage_arena) {
      irls_mask_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, irls_mask_options, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  irls_mask_options_ = irls_mask_options;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.MotionEstimationOptions.irls_mask_options)
}

// optional .mediapipe.MotionEstimationOptions.JointTrackEstimationOptions joint_track_estimation = 59;
inline bool MotionEstimationOptions::_internal_has_joint_track_estimation() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || joint_track_estimation_ != nullptr);
  return value;
}
inline bool MotionEstimationOptions::has_joint_track_estimation() const {
  return _internal_has_joint_track_estimation();
}
inline void MotionEstimationOptions::clear_joint_track_estimation() {
  if (joint_track_estimation_ != nullptr) joint_track_estimation_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions& MotionEstimationOptions::_internal_joint_track_estimation() const {
  const ::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions* p = joint_track_estimation_;
  return p != nullptr ? *p : reinterpret_cast<const ::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions&>(
      ::mediapipe::_MotionEstimationOptions_JointTrackEstimationOptions_default_instance_);
}
inline const ::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions& MotionEstimationOptions::joint_track_estimation() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.joint_track_estimation)
  return _internal_joint_track_estimation();
}
inline void MotionEstimationOptions::unsafe_arena_set_allocated_joint_track_estimation(
    ::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions* joint_track_estimation) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(joint_track_estimation_);
  }
  joint_track_estimation_ = joint_track_estimation;
  if (joint_track_estimation) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mediapipe.MotionEstimationOptions.joint_track_estimation)
}
inline ::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions* MotionEstimationOptions::release_joint_track_estimation() {
  _has_bits_[0] &= ~0x00000080u;
  ::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions* temp = joint_track_estimation_;
  joint_track_estimation_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions* MotionEstimationOptions::unsafe_arena_release_joint_track_estimation() {
  // @@protoc_insertion_point(field_release:mediapipe.MotionEstimationOptions.joint_track_estimation)
  _has_bits_[0] &= ~0x00000080u;
  ::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions* temp = joint_track_estimation_;
  joint_track_estimation_ = nullptr;
  return temp;
}
inline ::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions* MotionEstimationOptions::_internal_mutable_joint_track_estimation() {
  _has_bits_[0] |= 0x00000080u;
  if (joint_track_estimation_ == nullptr) {
    auto* p = CreateMaybeMessage<::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions>(GetArena());
    joint_track_estimation_ = p;
  }
  return joint_track_estimation_;
}
inline ::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions* MotionEstimationOptions::mutable_joint_track_estimation() {
  // @@protoc_insertion_point(field_mutable:mediapipe.MotionEstimationOptions.joint_track_estimation)
  return _internal_mutable_joint_track_estimation();
}
inline void MotionEstimationOptions::set_allocated_joint_track_estimation(::mediapipe::MotionEstimationOptions_JointTrackEstimationOptions* joint_track_estimation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete joint_track_estimation_;
  }
  if (joint_track_estimation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(joint_track_estimation);
    if (message_arena != submessage_arena) {
      joint_track_estimation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, joint_track_estimation, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  joint_track_estimation_ = joint_track_estimation;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.MotionEstimationOptions.joint_track_estimation)
}

// optional .mediapipe.MotionEstimationOptions.LongFeatureBiasOptions long_feature_bias_options = 64;
inline bool MotionEstimationOptions::_internal_has_long_feature_bias_options() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || long_feature_bias_options_ != nullptr);
  return value;
}
inline bool MotionEstimationOptions::has_long_feature_bias_options() const {
  return _internal_has_long_feature_bias_options();
}
inline void MotionEstimationOptions::clear_long_feature_bias_options() {
  if (long_feature_bias_options_ != nullptr) long_feature_bias_options_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions& MotionEstimationOptions::_internal_long_feature_bias_options() const {
  const ::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions* p = long_feature_bias_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions&>(
      ::mediapipe::_MotionEstimationOptions_LongFeatureBiasOptions_default_instance_);
}
inline const ::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions& MotionEstimationOptions::long_feature_bias_options() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.long_feature_bias_options)
  return _internal_long_feature_bias_options();
}
inline void MotionEstimationOptions::unsafe_arena_set_allocated_long_feature_bias_options(
    ::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions* long_feature_bias_options) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(long_feature_bias_options_);
  }
  long_feature_bias_options_ = long_feature_bias_options;
  if (long_feature_bias_options) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mediapipe.MotionEstimationOptions.long_feature_bias_options)
}
inline ::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions* MotionEstimationOptions::release_long_feature_bias_options() {
  _has_bits_[0] &= ~0x00000200u;
  ::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions* temp = long_feature_bias_options_;
  long_feature_bias_options_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions* MotionEstimationOptions::unsafe_arena_release_long_feature_bias_options() {
  // @@protoc_insertion_point(field_release:mediapipe.MotionEstimationOptions.long_feature_bias_options)
  _has_bits_[0] &= ~0x00000200u;
  ::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions* temp = long_feature_bias_options_;
  long_feature_bias_options_ = nullptr;
  return temp;
}
inline ::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions* MotionEstimationOptions::_internal_mutable_long_feature_bias_options() {
  _has_bits_[0] |= 0x00000200u;
  if (long_feature_bias_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions>(GetArena());
    long_feature_bias_options_ = p;
  }
  return long_feature_bias_options_;
}
inline ::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions* MotionEstimationOptions::mutable_long_feature_bias_options() {
  // @@protoc_insertion_point(field_mutable:mediapipe.MotionEstimationOptions.long_feature_bias_options)
  return _internal_mutable_long_feature_bias_options();
}
inline void MotionEstimationOptions::set_allocated_long_feature_bias_options(::mediapipe::MotionEstimationOptions_LongFeatureBiasOptions* long_feature_bias_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete long_feature_bias_options_;
  }
  if (long_feature_bias_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(long_feature_bias_options);
    if (message_arena != submessage_arena) {
      long_feature_bias_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, long_feature_bias_options, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  long_feature_bias_options_ = long_feature_bias_options;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.MotionEstimationOptions.long_feature_bias_options)
}

// optional .mediapipe.MotionEstimationOptions.EstimationPolicy estimation_policy = 58 [default = INDEPENDENT_PARALLEL];
inline bool MotionEstimationOptions::_internal_has_estimation_policy() const {
  bool value = (_has_bits_[1] & 0x01000000u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_estimation_policy() const {
  return _internal_has_estimation_policy();
}
inline void MotionEstimationOptions::clear_estimation_policy() {
  estimation_policy_ = 1;
  _has_bits_[1] &= ~0x01000000u;
}
inline ::mediapipe::MotionEstimationOptions_EstimationPolicy MotionEstimationOptions::_internal_estimation_policy() const {
  return static_cast< ::mediapipe::MotionEstimationOptions_EstimationPolicy >(estimation_policy_);
}
inline ::mediapipe::MotionEstimationOptions_EstimationPolicy MotionEstimationOptions::estimation_policy() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.estimation_policy)
  return _internal_estimation_policy();
}
inline void MotionEstimationOptions::_internal_set_estimation_policy(::mediapipe::MotionEstimationOptions_EstimationPolicy value) {
  assert(::mediapipe::MotionEstimationOptions_EstimationPolicy_IsValid(value));
  _has_bits_[1] |= 0x01000000u;
  estimation_policy_ = value;
}
inline void MotionEstimationOptions::set_estimation_policy(::mediapipe::MotionEstimationOptions_EstimationPolicy value) {
  _internal_set_estimation_policy(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.estimation_policy)
}

// optional int32 coverage_grid_size = 51 [default = 10];
inline bool MotionEstimationOptions::_internal_has_coverage_grid_size() const {
  bool value = (_has_bits_[1] & 0x00800000u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_coverage_grid_size() const {
  return _internal_has_coverage_grid_size();
}
inline void MotionEstimationOptions::clear_coverage_grid_size() {
  coverage_grid_size_ = 10;
  _has_bits_[1] &= ~0x00800000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MotionEstimationOptions::_internal_coverage_grid_size() const {
  return coverage_grid_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MotionEstimationOptions::coverage_grid_size() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.coverage_grid_size)
  return _internal_coverage_grid_size();
}
inline void MotionEstimationOptions::_internal_set_coverage_grid_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[1] |= 0x00800000u;
  coverage_grid_size_ = value;
}
inline void MotionEstimationOptions::set_coverage_grid_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_coverage_grid_size(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.coverage_grid_size)
}

// optional .mediapipe.MotionEstimationOptions.MixtureModelMode mixture_model_mode = 23 [default = SKEW_ROTATION_MIXTURE];
inline bool MotionEstimationOptions::_internal_has_mixture_model_mode() const {
  bool value = (_has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_mixture_model_mode() const {
  return _internal_has_mixture_model_mode();
}
inline void MotionEstimationOptions::clear_mixture_model_mode() {
  mixture_model_mode_ = 2;
  _has_bits_[1] &= ~0x00000001u;
}
inline ::mediapipe::MotionEstimationOptions_MixtureModelMode MotionEstimationOptions::_internal_mixture_model_mode() const {
  return static_cast< ::mediapipe::MotionEstimationOptions_MixtureModelMode >(mixture_model_mode_);
}
inline ::mediapipe::MotionEstimationOptions_MixtureModelMode MotionEstimationOptions::mixture_model_mode() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.mixture_model_mode)
  return _internal_mixture_model_mode();
}
inline void MotionEstimationOptions::_internal_set_mixture_model_mode(::mediapipe::MotionEstimationOptions_MixtureModelMode value) {
  assert(::mediapipe::MotionEstimationOptions_MixtureModelMode_IsValid(value));
  _has_bits_[1] |= 0x00000001u;
  mixture_model_mode_ = value;
}
inline void MotionEstimationOptions::set_mixture_model_mode(::mediapipe::MotionEstimationOptions_MixtureModelMode value) {
  _internal_set_mixture_model_mode(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.mixture_model_mode)
}

// optional bool use_only_lin_sim_inliers_for_homography = 6 [default = true];
inline bool MotionEstimationOptions::_internal_has_use_only_lin_sim_inliers_for_homography() const {
  bool value = (_has_bits_[1] & 0x00000200u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_use_only_lin_sim_inliers_for_homography() const {
  return _internal_has_use_only_lin_sim_inliers_for_homography();
}
inline void MotionEstimationOptions::clear_use_only_lin_sim_inliers_for_homography() {
  use_only_lin_sim_inliers_for_homography_ = true;
  _has_bits_[1] &= ~0x00000200u;
}
inline bool MotionEstimationOptions::_internal_use_only_lin_sim_inliers_for_homography() const {
  return use_only_lin_sim_inliers_for_homography_;
}
inline bool MotionEstimationOptions::use_only_lin_sim_inliers_for_homography() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.use_only_lin_sim_inliers_for_homography)
  return _internal_use_only_lin_sim_inliers_for_homography();
}
inline void MotionEstimationOptions::_internal_set_use_only_lin_sim_inliers_for_homography(bool value) {
  _has_bits_[1] |= 0x00000200u;
  use_only_lin_sim_inliers_for_homography_ = value;
}
inline void MotionEstimationOptions::set_use_only_lin_sim_inliers_for_homography(bool value) {
  _internal_set_use_only_lin_sim_inliers_for_homography(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.use_only_lin_sim_inliers_for_homography)
}

// optional float lin_sim_inlier_threshold = 20 [default = 0.003];
inline bool MotionEstimationOptions::_internal_has_lin_sim_inlier_threshold() const {
  bool value = (_has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_lin_sim_inlier_threshold() const {
  return _internal_has_lin_sim_inlier_threshold();
}
inline void MotionEstimationOptions::clear_lin_sim_inlier_threshold() {
  lin_sim_inlier_threshold_ = 0.003f;
  _has_bits_[0] &= ~0x80000000u;
}
inline float MotionEstimationOptions::_internal_lin_sim_inlier_threshold() const {
  return lin_sim_inlier_threshold_;
}
inline float MotionEstimationOptions::lin_sim_inlier_threshold() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.lin_sim_inlier_threshold)
  return _internal_lin_sim_inlier_threshold();
}
inline void MotionEstimationOptions::_internal_set_lin_sim_inlier_threshold(float value) {
  _has_bits_[0] |= 0x80000000u;
  lin_sim_inlier_threshold_ = value;
}
inline void MotionEstimationOptions::set_lin_sim_inlier_threshold(float value) {
  _internal_set_lin_sim_inlier_threshold(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.lin_sim_inlier_threshold)
}

// optional .mediapipe.MotionEstimationOptions.TranslationBounds stable_translation_bounds = 32;
inline bool MotionEstimationOptions::_internal_has_stable_translation_bounds() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || stable_translation_bounds_ != nullptr);
  return value;
}
inline bool MotionEstimationOptions::has_stable_translation_bounds() const {
  return _internal_has_stable_translation_bounds();
}
inline void MotionEstimationOptions::clear_stable_translation_bounds() {
  if (stable_translation_bounds_ != nullptr) stable_translation_bounds_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::mediapipe::MotionEstimationOptions_TranslationBounds& MotionEstimationOptions::_internal_stable_translation_bounds() const {
  const ::mediapipe::MotionEstimationOptions_TranslationBounds* p = stable_translation_bounds_;
  return p != nullptr ? *p : reinterpret_cast<const ::mediapipe::MotionEstimationOptions_TranslationBounds&>(
      ::mediapipe::_MotionEstimationOptions_TranslationBounds_default_instance_);
}
inline const ::mediapipe::MotionEstimationOptions_TranslationBounds& MotionEstimationOptions::stable_translation_bounds() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.stable_translation_bounds)
  return _internal_stable_translation_bounds();
}
inline void MotionEstimationOptions::unsafe_arena_set_allocated_stable_translation_bounds(
    ::mediapipe::MotionEstimationOptions_TranslationBounds* stable_translation_bounds) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stable_translation_bounds_);
  }
  stable_translation_bounds_ = stable_translation_bounds;
  if (stable_translation_bounds) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mediapipe.MotionEstimationOptions.stable_translation_bounds)
}
inline ::mediapipe::MotionEstimationOptions_TranslationBounds* MotionEstimationOptions::release_stable_translation_bounds() {
  _has_bits_[0] &= ~0x00000002u;
  ::mediapipe::MotionEstimationOptions_TranslationBounds* temp = stable_translation_bounds_;
  stable_translation_bounds_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mediapipe::MotionEstimationOptions_TranslationBounds* MotionEstimationOptions::unsafe_arena_release_stable_translation_bounds() {
  // @@protoc_insertion_point(field_release:mediapipe.MotionEstimationOptions.stable_translation_bounds)
  _has_bits_[0] &= ~0x00000002u;
  ::mediapipe::MotionEstimationOptions_TranslationBounds* temp = stable_translation_bounds_;
  stable_translation_bounds_ = nullptr;
  return temp;
}
inline ::mediapipe::MotionEstimationOptions_TranslationBounds* MotionEstimationOptions::_internal_mutable_stable_translation_bounds() {
  _has_bits_[0] |= 0x00000002u;
  if (stable_translation_bounds_ == nullptr) {
    auto* p = CreateMaybeMessage<::mediapipe::MotionEstimationOptions_TranslationBounds>(GetArena());
    stable_translation_bounds_ = p;
  }
  return stable_translation_bounds_;
}
inline ::mediapipe::MotionEstimationOptions_TranslationBounds* MotionEstimationOptions::mutable_stable_translation_bounds() {
  // @@protoc_insertion_point(field_mutable:mediapipe.MotionEstimationOptions.stable_translation_bounds)
  return _internal_mutable_stable_translation_bounds();
}
inline void MotionEstimationOptions::set_allocated_stable_translation_bounds(::mediapipe::MotionEstimationOptions_TranslationBounds* stable_translation_bounds) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete stable_translation_bounds_;
  }
  if (stable_translation_bounds) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(stable_translation_bounds);
    if (message_arena != submessage_arena) {
      stable_translation_bounds = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stable_translation_bounds, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  stable_translation_bounds_ = stable_translation_bounds;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.MotionEstimationOptions.stable_translation_bounds)
}

// optional .mediapipe.MotionEstimationOptions.SimilarityBounds stable_similarity_bounds = 33;
inline bool MotionEstimationOptions::_internal_has_stable_similarity_bounds() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || stable_similarity_bounds_ != nullptr);
  return value;
}
inline bool MotionEstimationOptions::has_stable_similarity_bounds() const {
  return _internal_has_stable_similarity_bounds();
}
inline void MotionEstimationOptions::clear_stable_similarity_bounds() {
  if (stable_similarity_bounds_ != nullptr) stable_similarity_bounds_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::mediapipe::MotionEstimationOptions_SimilarityBounds& MotionEstimationOptions::_internal_stable_similarity_bounds() const {
  const ::mediapipe::MotionEstimationOptions_SimilarityBounds* p = stable_similarity_bounds_;
  return p != nullptr ? *p : reinterpret_cast<const ::mediapipe::MotionEstimationOptions_SimilarityBounds&>(
      ::mediapipe::_MotionEstimationOptions_SimilarityBounds_default_instance_);
}
inline const ::mediapipe::MotionEstimationOptions_SimilarityBounds& MotionEstimationOptions::stable_similarity_bounds() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.stable_similarity_bounds)
  return _internal_stable_similarity_bounds();
}
inline void MotionEstimationOptions::unsafe_arena_set_allocated_stable_similarity_bounds(
    ::mediapipe::MotionEstimationOptions_SimilarityBounds* stable_similarity_bounds) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stable_similarity_bounds_);
  }
  stable_similarity_bounds_ = stable_similarity_bounds;
  if (stable_similarity_bounds) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mediapipe.MotionEstimationOptions.stable_similarity_bounds)
}
inline ::mediapipe::MotionEstimationOptions_SimilarityBounds* MotionEstimationOptions::release_stable_similarity_bounds() {
  _has_bits_[0] &= ~0x00000004u;
  ::mediapipe::MotionEstimationOptions_SimilarityBounds* temp = stable_similarity_bounds_;
  stable_similarity_bounds_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mediapipe::MotionEstimationOptions_SimilarityBounds* MotionEstimationOptions::unsafe_arena_release_stable_similarity_bounds() {
  // @@protoc_insertion_point(field_release:mediapipe.MotionEstimationOptions.stable_similarity_bounds)
  _has_bits_[0] &= ~0x00000004u;
  ::mediapipe::MotionEstimationOptions_SimilarityBounds* temp = stable_similarity_bounds_;
  stable_similarity_bounds_ = nullptr;
  return temp;
}
inline ::mediapipe::MotionEstimationOptions_SimilarityBounds* MotionEstimationOptions::_internal_mutable_stable_similarity_bounds() {
  _has_bits_[0] |= 0x00000004u;
  if (stable_similarity_bounds_ == nullptr) {
    auto* p = CreateMaybeMessage<::mediapipe::MotionEstimationOptions_SimilarityBounds>(GetArena());
    stable_similarity_bounds_ = p;
  }
  return stable_similarity_bounds_;
}
inline ::mediapipe::MotionEstimationOptions_SimilarityBounds* MotionEstimationOptions::mutable_stable_similarity_bounds() {
  // @@protoc_insertion_point(field_mutable:mediapipe.MotionEstimationOptions.stable_similarity_bounds)
  return _internal_mutable_stable_similarity_bounds();
}
inline void MotionEstimationOptions::set_allocated_stable_similarity_bounds(::mediapipe::MotionEstimationOptions_SimilarityBounds* stable_similarity_bounds) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete stable_similarity_bounds_;
  }
  if (stable_similarity_bounds) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(stable_similarity_bounds);
    if (message_arena != submessage_arena) {
      stable_similarity_bounds = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stable_similarity_bounds, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  stable_similarity_bounds_ = stable_similarity_bounds;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.MotionEstimationOptions.stable_similarity_bounds)
}

// optional .mediapipe.MotionEstimationOptions.HomographyBounds stable_homography_bounds = 11;
inline bool MotionEstimationOptions::_internal_has_stable_homography_bounds() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || stable_homography_bounds_ != nullptr);
  return value;
}
inline bool MotionEstimationOptions::has_stable_homography_bounds() const {
  return _internal_has_stable_homography_bounds();
}
inline void MotionEstimationOptions::clear_stable_homography_bounds() {
  if (stable_homography_bounds_ != nullptr) stable_homography_bounds_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mediapipe::MotionEstimationOptions_HomographyBounds& MotionEstimationOptions::_internal_stable_homography_bounds() const {
  const ::mediapipe::MotionEstimationOptions_HomographyBounds* p = stable_homography_bounds_;
  return p != nullptr ? *p : reinterpret_cast<const ::mediapipe::MotionEstimationOptions_HomographyBounds&>(
      ::mediapipe::_MotionEstimationOptions_HomographyBounds_default_instance_);
}
inline const ::mediapipe::MotionEstimationOptions_HomographyBounds& MotionEstimationOptions::stable_homography_bounds() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.stable_homography_bounds)
  return _internal_stable_homography_bounds();
}
inline void MotionEstimationOptions::unsafe_arena_set_allocated_stable_homography_bounds(
    ::mediapipe::MotionEstimationOptions_HomographyBounds* stable_homography_bounds) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stable_homography_bounds_);
  }
  stable_homography_bounds_ = stable_homography_bounds;
  if (stable_homography_bounds) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mediapipe.MotionEstimationOptions.stable_homography_bounds)
}
inline ::mediapipe::MotionEstimationOptions_HomographyBounds* MotionEstimationOptions::release_stable_homography_bounds() {
  _has_bits_[0] &= ~0x00000001u;
  ::mediapipe::MotionEstimationOptions_HomographyBounds* temp = stable_homography_bounds_;
  stable_homography_bounds_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mediapipe::MotionEstimationOptions_HomographyBounds* MotionEstimationOptions::unsafe_arena_release_stable_homography_bounds() {
  // @@protoc_insertion_point(field_release:mediapipe.MotionEstimationOptions.stable_homography_bounds)
  _has_bits_[0] &= ~0x00000001u;
  ::mediapipe::MotionEstimationOptions_HomographyBounds* temp = stable_homography_bounds_;
  stable_homography_bounds_ = nullptr;
  return temp;
}
inline ::mediapipe::MotionEstimationOptions_HomographyBounds* MotionEstimationOptions::_internal_mutable_stable_homography_bounds() {
  _has_bits_[0] |= 0x00000001u;
  if (stable_homography_bounds_ == nullptr) {
    auto* p = CreateMaybeMessage<::mediapipe::MotionEstimationOptions_HomographyBounds>(GetArena());
    stable_homography_bounds_ = p;
  }
  return stable_homography_bounds_;
}
inline ::mediapipe::MotionEstimationOptions_HomographyBounds* MotionEstimationOptions::mutable_stable_homography_bounds() {
  // @@protoc_insertion_point(field_mutable:mediapipe.MotionEstimationOptions.stable_homography_bounds)
  return _internal_mutable_stable_homography_bounds();
}
inline void MotionEstimationOptions::set_allocated_stable_homography_bounds(::mediapipe::MotionEstimationOptions_HomographyBounds* stable_homography_bounds) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete stable_homography_bounds_;
  }
  if (stable_homography_bounds) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(stable_homography_bounds);
    if (message_arena != submessage_arena) {
      stable_homography_bounds = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stable_homography_bounds, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  stable_homography_bounds_ = stable_homography_bounds;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.MotionEstimationOptions.stable_homography_bounds)
}

// optional .mediapipe.MotionEstimationOptions.MixtureHomographyBounds stable_mixture_homography_bounds = 34;
inline bool MotionEstimationOptions::_internal_has_stable_mixture_homography_bounds() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || stable_mixture_homography_bounds_ != nullptr);
  return value;
}
inline bool MotionEstimationOptions::has_stable_mixture_homography_bounds() const {
  return _internal_has_stable_mixture_homography_bounds();
}
inline void MotionEstimationOptions::clear_stable_mixture_homography_bounds() {
  if (stable_mixture_homography_bounds_ != nullptr) stable_mixture_homography_bounds_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::mediapipe::MotionEstimationOptions_MixtureHomographyBounds& MotionEstimationOptions::_internal_stable_mixture_homography_bounds() const {
  const ::mediapipe::MotionEstimationOptions_MixtureHomographyBounds* p = stable_mixture_homography_bounds_;
  return p != nullptr ? *p : reinterpret_cast<const ::mediapipe::MotionEstimationOptions_MixtureHomographyBounds&>(
      ::mediapipe::_MotionEstimationOptions_MixtureHomographyBounds_default_instance_);
}
inline const ::mediapipe::MotionEstimationOptions_MixtureHomographyBounds& MotionEstimationOptions::stable_mixture_homography_bounds() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.stable_mixture_homography_bounds)
  return _internal_stable_mixture_homography_bounds();
}
inline void MotionEstimationOptions::unsafe_arena_set_allocated_stable_mixture_homography_bounds(
    ::mediapipe::MotionEstimationOptions_MixtureHomographyBounds* stable_mixture_homography_bounds) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stable_mixture_homography_bounds_);
  }
  stable_mixture_homography_bounds_ = stable_mixture_homography_bounds;
  if (stable_mixture_homography_bounds) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mediapipe.MotionEstimationOptions.stable_mixture_homography_bounds)
}
inline ::mediapipe::MotionEstimationOptions_MixtureHomographyBounds* MotionEstimationOptions::release_stable_mixture_homography_bounds() {
  _has_bits_[0] &= ~0x00000008u;
  ::mediapipe::MotionEstimationOptions_MixtureHomographyBounds* temp = stable_mixture_homography_bounds_;
  stable_mixture_homography_bounds_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mediapipe::MotionEstimationOptions_MixtureHomographyBounds* MotionEstimationOptions::unsafe_arena_release_stable_mixture_homography_bounds() {
  // @@protoc_insertion_point(field_release:mediapipe.MotionEstimationOptions.stable_mixture_homography_bounds)
  _has_bits_[0] &= ~0x00000008u;
  ::mediapipe::MotionEstimationOptions_MixtureHomographyBounds* temp = stable_mixture_homography_bounds_;
  stable_mixture_homography_bounds_ = nullptr;
  return temp;
}
inline ::mediapipe::MotionEstimationOptions_MixtureHomographyBounds* MotionEstimationOptions::_internal_mutable_stable_mixture_homography_bounds() {
  _has_bits_[0] |= 0x00000008u;
  if (stable_mixture_homography_bounds_ == nullptr) {
    auto* p = CreateMaybeMessage<::mediapipe::MotionEstimationOptions_MixtureHomographyBounds>(GetArena());
    stable_mixture_homography_bounds_ = p;
  }
  return stable_mixture_homography_bounds_;
}
inline ::mediapipe::MotionEstimationOptions_MixtureHomographyBounds* MotionEstimationOptions::mutable_stable_mixture_homography_bounds() {
  // @@protoc_insertion_point(field_mutable:mediapipe.MotionEstimationOptions.stable_mixture_homography_bounds)
  return _internal_mutable_stable_mixture_homography_bounds();
}
inline void MotionEstimationOptions::set_allocated_stable_mixture_homography_bounds(::mediapipe::MotionEstimationOptions_MixtureHomographyBounds* stable_mixture_homography_bounds) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete stable_mixture_homography_bounds_;
  }
  if (stable_mixture_homography_bounds) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(stable_mixture_homography_bounds);
    if (message_arena != submessage_arena) {
      stable_mixture_homography_bounds = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stable_mixture_homography_bounds, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  stable_mixture_homography_bounds_ = stable_mixture_homography_bounds;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.MotionEstimationOptions.stable_mixture_homography_bounds)
}

// optional float strict_coverage_scale = 41 [default = 1.333];
inline bool MotionEstimationOptions::_internal_has_strict_coverage_scale() const {
  bool value = (_has_bits_[1] & 0x00010000u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_strict_coverage_scale() const {
  return _internal_has_strict_coverage_scale();
}
inline void MotionEstimationOptions::clear_strict_coverage_scale() {
  strict_coverage_scale_ = 1.333f;
  _has_bits_[1] &= ~0x00010000u;
}
inline float MotionEstimationOptions::_internal_strict_coverage_scale() const {
  return strict_coverage_scale_;
}
inline float MotionEstimationOptions::strict_coverage_scale() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.strict_coverage_scale)
  return _internal_strict_coverage_scale();
}
inline void MotionEstimationOptions::_internal_set_strict_coverage_scale(float value) {
  _has_bits_[1] |= 0x00010000u;
  strict_coverage_scale_ = value;
}
inline void MotionEstimationOptions::set_strict_coverage_scale(float value) {
  _internal_set_strict_coverage_scale(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.strict_coverage_scale)
}

// optional bool label_empty_frames_as_valid = 22 [default = true];
inline bool MotionEstimationOptions::_internal_has_label_empty_frames_as_valid() const {
  bool value = (_has_bits_[1] & 0x00001000u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_label_empty_frames_as_valid() const {
  return _internal_has_label_empty_frames_as_valid();
}
inline void MotionEstimationOptions::clear_label_empty_frames_as_valid() {
  label_empty_frames_as_valid_ = true;
  _has_bits_[1] &= ~0x00001000u;
}
inline bool MotionEstimationOptions::_internal_label_empty_frames_as_valid() const {
  return label_empty_frames_as_valid_;
}
inline bool MotionEstimationOptions::label_empty_frames_as_valid() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.label_empty_frames_as_valid)
  return _internal_label_empty_frames_as_valid();
}
inline void MotionEstimationOptions::_internal_set_label_empty_frames_as_valid(bool value) {
  _has_bits_[1] |= 0x00001000u;
  label_empty_frames_as_valid_ = value;
}
inline void MotionEstimationOptions::set_label_empty_frames_as_valid(bool value) {
  _internal_set_label_empty_frames_as_valid(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.label_empty_frames_as_valid)
}

// optional float feature_grid_size = 24 [default = 0.05];
inline bool MotionEstimationOptions::_internal_has_feature_grid_size() const {
  bool value = (_has_bits_[1] & 0x00000002u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_feature_grid_size() const {
  return _internal_has_feature_grid_size();
}
inline void MotionEstimationOptions::clear_feature_grid_size() {
  feature_grid_size_ = 0.05f;
  _has_bits_[1] &= ~0x00000002u;
}
inline float MotionEstimationOptions::_internal_feature_grid_size() const {
  return feature_grid_size_;
}
inline float MotionEstimationOptions::feature_grid_size() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.feature_grid_size)
  return _internal_feature_grid_size();
}
inline void MotionEstimationOptions::_internal_set_feature_grid_size(float value) {
  _has_bits_[1] |= 0x00000002u;
  feature_grid_size_ = value;
}
inline void MotionEstimationOptions::set_feature_grid_size(float value) {
  _internal_set_feature_grid_size(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.feature_grid_size)
}

// optional float spatial_sigma = 25 [default = 0.01];
inline bool MotionEstimationOptions::_internal_has_spatial_sigma() const {
  bool value = (_has_bits_[1] & 0x00000004u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_spatial_sigma() const {
  return _internal_has_spatial_sigma();
}
inline void MotionEstimationOptions::clear_spatial_sigma() {
  spatial_sigma_ = 0.01f;
  _has_bits_[1] &= ~0x00000004u;
}
inline float MotionEstimationOptions::_internal_spatial_sigma() const {
  return spatial_sigma_;
}
inline float MotionEstimationOptions::spatial_sigma() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.spatial_sigma)
  return _internal_spatial_sigma();
}
inline void MotionEstimationOptions::_internal_set_spatial_sigma(float value) {
  _has_bits_[1] |= 0x00000004u;
  spatial_sigma_ = value;
}
inline void MotionEstimationOptions::set_spatial_sigma(float value) {
  _internal_set_spatial_sigma(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.spatial_sigma)
}

// optional int32 temporal_irls_diameter = 26 [default = 20];
inline bool MotionEstimationOptions::_internal_has_temporal_irls_diameter() const {
  bool value = (_has_bits_[1] & 0x00000008u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_temporal_irls_diameter() const {
  return _internal_has_temporal_irls_diameter();
}
inline void MotionEstimationOptions::clear_temporal_irls_diameter() {
  temporal_irls_diameter_ = 20;
  _has_bits_[1] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MotionEstimationOptions::_internal_temporal_irls_diameter() const {
  return temporal_irls_diameter_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MotionEstimationOptions::temporal_irls_diameter() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.temporal_irls_diameter)
  return _internal_temporal_irls_diameter();
}
inline void MotionEstimationOptions::_internal_set_temporal_irls_diameter(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[1] |= 0x00000008u;
  temporal_irls_diameter_ = value;
}
inline void MotionEstimationOptions::set_temporal_irls_diameter(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_temporal_irls_diameter(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.temporal_irls_diameter)
}

// optional float temporal_sigma = 27 [default = 5];
inline bool MotionEstimationOptions::_internal_has_temporal_sigma() const {
  bool value = (_has_bits_[1] & 0x00000010u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_temporal_sigma() const {
  return _internal_has_temporal_sigma();
}
inline void MotionEstimationOptions::clear_temporal_sigma() {
  temporal_sigma_ = 5;
  _has_bits_[1] &= ~0x00000010u;
}
inline float MotionEstimationOptions::_internal_temporal_sigma() const {
  return temporal_sigma_;
}
inline float MotionEstimationOptions::temporal_sigma() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.temporal_sigma)
  return _internal_temporal_sigma();
}
inline void MotionEstimationOptions::_internal_set_temporal_sigma(float value) {
  _has_bits_[1] |= 0x00000010u;
  temporal_sigma_ = value;
}
inline void MotionEstimationOptions::set_temporal_sigma(float value) {
  _internal_set_temporal_sigma(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.temporal_sigma)
}

// optional float feature_sigma = 28 [default = 30];
inline bool MotionEstimationOptions::_internal_has_feature_sigma() const {
  bool value = (_has_bits_[1] & 0x00000020u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_feature_sigma() const {
  return _internal_has_feature_sigma();
}
inline void MotionEstimationOptions::clear_feature_sigma() {
  feature_sigma_ = 30;
  _has_bits_[1] &= ~0x00000020u;
}
inline float MotionEstimationOptions::_internal_feature_sigma() const {
  return feature_sigma_;
}
inline float MotionEstimationOptions::feature_sigma() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.feature_sigma)
  return _internal_feature_sigma();
}
inline void MotionEstimationOptions::_internal_set_feature_sigma(float value) {
  _has_bits_[1] |= 0x00000020u;
  feature_sigma_ = value;
}
inline void MotionEstimationOptions::set_feature_sigma(float value) {
  _internal_set_feature_sigma(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.feature_sigma)
}

// optional bool filter_5_taps = 29 [default = false];
inline bool MotionEstimationOptions::_internal_has_filter_5_taps() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_filter_5_taps() const {
  return _internal_has_filter_5_taps();
}
inline void MotionEstimationOptions::clear_filter_5_taps() {
  filter_5_taps_ = false;
  _has_bits_[0] &= ~0x00010000u;
}
inline bool MotionEstimationOptions::_internal_filter_5_taps() const {
  return filter_5_taps_;
}
inline bool MotionEstimationOptions::filter_5_taps() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.filter_5_taps)
  return _internal_filter_5_taps();
}
inline void MotionEstimationOptions::_internal_set_filter_5_taps(bool value) {
  _has_bits_[0] |= 0x00010000u;
  filter_5_taps_ = value;
}
inline void MotionEstimationOptions::set_filter_5_taps(bool value) {
  _internal_set_filter_5_taps(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.filter_5_taps)
}

// optional bool frame_confidence_weighting = 48 [default = true];
inline bool MotionEstimationOptions::_internal_has_frame_confidence_weighting() const {
  bool value = (_has_bits_[1] & 0x00002000u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_frame_confidence_weighting() const {
  return _internal_has_frame_confidence_weighting();
}
inline void MotionEstimationOptions::clear_frame_confidence_weighting() {
  frame_confidence_weighting_ = true;
  _has_bits_[1] &= ~0x00002000u;
}
inline bool MotionEstimationOptions::_internal_frame_confidence_weighting() const {
  return frame_confidence_weighting_;
}
inline bool MotionEstimationOptions::frame_confidence_weighting() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.frame_confidence_weighting)
  return _internal_frame_confidence_weighting();
}
inline void MotionEstimationOptions::_internal_set_frame_confidence_weighting(bool value) {
  _has_bits_[1] |= 0x00002000u;
  frame_confidence_weighting_ = value;
}
inline void MotionEstimationOptions::set_frame_confidence_weighting(bool value) {
  _internal_set_frame_confidence_weighting(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.frame_confidence_weighting)
}

// optional float reset_confidence_threshold = 49 [default = 0.4];
inline bool MotionEstimationOptions::_internal_has_reset_confidence_threshold() const {
  bool value = (_has_bits_[1] & 0x00200000u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_reset_confidence_threshold() const {
  return _internal_has_reset_confidence_threshold();
}
inline void MotionEstimationOptions::clear_reset_confidence_threshold() {
  reset_confidence_threshold_ = 0.4f;
  _has_bits_[1] &= ~0x00200000u;
}
inline float MotionEstimationOptions::_internal_reset_confidence_threshold() const {
  return reset_confidence_threshold_;
}
inline float MotionEstimationOptions::reset_confidence_threshold() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.reset_confidence_threshold)
  return _internal_reset_confidence_threshold();
}
inline void MotionEstimationOptions::_internal_set_reset_confidence_threshold(float value) {
  _has_bits_[1] |= 0x00200000u;
  reset_confidence_threshold_ = value;
}
inline void MotionEstimationOptions::set_reset_confidence_threshold(float value) {
  _internal_set_reset_confidence_threshold(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.reset_confidence_threshold)
}

// optional .mediapipe.MotionEstimationOptions.IRLSWeightFilter irls_weight_filter = 35 [default = IRLS_FILTER_NONE];
inline bool MotionEstimationOptions::_internal_has_irls_weight_filter() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_irls_weight_filter() const {
  return _internal_has_irls_weight_filter();
}
inline void MotionEstimationOptions::clear_irls_weight_filter() {
  irls_weight_filter_ = 0;
  _has_bits_[0] &= ~0x00008000u;
}
inline ::mediapipe::MotionEstimationOptions_IRLSWeightFilter MotionEstimationOptions::_internal_irls_weight_filter() const {
  return static_cast< ::mediapipe::MotionEstimationOptions_IRLSWeightFilter >(irls_weight_filter_);
}
inline ::mediapipe::MotionEstimationOptions_IRLSWeightFilter MotionEstimationOptions::irls_weight_filter() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.irls_weight_filter)
  return _internal_irls_weight_filter();
}
inline void MotionEstimationOptions::_internal_set_irls_weight_filter(::mediapipe::MotionEstimationOptions_IRLSWeightFilter value) {
  assert(::mediapipe::MotionEstimationOptions_IRLSWeightFilter_IsValid(value));
  _has_bits_[0] |= 0x00008000u;
  irls_weight_filter_ = value;
}
inline void MotionEstimationOptions::set_irls_weight_filter(::mediapipe::MotionEstimationOptions_IRLSWeightFilter value) {
  _internal_set_irls_weight_filter(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.irls_weight_filter)
}

// optional bool overlay_detection = 36 [default = false];
inline bool MotionEstimationOptions::_internal_has_overlay_detection() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_overlay_detection() const {
  return _internal_has_overlay_detection();
}
inline void MotionEstimationOptions::clear_overlay_detection() {
  overlay_detection_ = false;
  _has_bits_[0] &= ~0x00020000u;
}
inline bool MotionEstimationOptions::_internal_overlay_detection() const {
  return overlay_detection_;
}
inline bool MotionEstimationOptions::overlay_detection() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.overlay_detection)
  return _internal_overlay_detection();
}
inline void MotionEstimationOptions::_internal_set_overlay_detection(bool value) {
  _has_bits_[0] |= 0x00020000u;
  overlay_detection_ = value;
}
inline void MotionEstimationOptions::set_overlay_detection(bool value) {
  _internal_set_overlay_detection(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.overlay_detection)
}

// optional int32 overlay_analysis_chunk_size = 37 [default = 8];
inline bool MotionEstimationOptions::_internal_has_overlay_analysis_chunk_size() const {
  bool value = (_has_bits_[1] & 0x00000800u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_overlay_analysis_chunk_size() const {
  return _internal_has_overlay_analysis_chunk_size();
}
inline void MotionEstimationOptions::clear_overlay_analysis_chunk_size() {
  overlay_analysis_chunk_size_ = 8;
  _has_bits_[1] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MotionEstimationOptions::_internal_overlay_analysis_chunk_size() const {
  return overlay_analysis_chunk_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MotionEstimationOptions::overlay_analysis_chunk_size() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.overlay_analysis_chunk_size)
  return _internal_overlay_analysis_chunk_size();
}
inline void MotionEstimationOptions::_internal_set_overlay_analysis_chunk_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[1] |= 0x00000800u;
  overlay_analysis_chunk_size_ = value;
}
inline void MotionEstimationOptions::set_overlay_analysis_chunk_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_overlay_analysis_chunk_size(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.overlay_analysis_chunk_size)
}

// optional .mediapipe.MotionEstimationOptions.OverlayDetectionOptions overlay_detection_options = 38;
inline bool MotionEstimationOptions::_internal_has_overlay_detection_options() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || overlay_detection_options_ != nullptr);
  return value;
}
inline bool MotionEstimationOptions::has_overlay_detection_options() const {
  return _internal_has_overlay_detection_options();
}
inline void MotionEstimationOptions::clear_overlay_detection_options() {
  if (overlay_detection_options_ != nullptr) overlay_detection_options_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::mediapipe::MotionEstimationOptions_OverlayDetectionOptions& MotionEstimationOptions::_internal_overlay_detection_options() const {
  const ::mediapipe::MotionEstimationOptions_OverlayDetectionOptions* p = overlay_detection_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::mediapipe::MotionEstimationOptions_OverlayDetectionOptions&>(
      ::mediapipe::_MotionEstimationOptions_OverlayDetectionOptions_default_instance_);
}
inline const ::mediapipe::MotionEstimationOptions_OverlayDetectionOptions& MotionEstimationOptions::overlay_detection_options() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.overlay_detection_options)
  return _internal_overlay_detection_options();
}
inline void MotionEstimationOptions::unsafe_arena_set_allocated_overlay_detection_options(
    ::mediapipe::MotionEstimationOptions_OverlayDetectionOptions* overlay_detection_options) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(overlay_detection_options_);
  }
  overlay_detection_options_ = overlay_detection_options;
  if (overlay_detection_options) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mediapipe.MotionEstimationOptions.overlay_detection_options)
}
inline ::mediapipe::MotionEstimationOptions_OverlayDetectionOptions* MotionEstimationOptions::release_overlay_detection_options() {
  _has_bits_[0] &= ~0x00000010u;
  ::mediapipe::MotionEstimationOptions_OverlayDetectionOptions* temp = overlay_detection_options_;
  overlay_detection_options_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mediapipe::MotionEstimationOptions_OverlayDetectionOptions* MotionEstimationOptions::unsafe_arena_release_overlay_detection_options() {
  // @@protoc_insertion_point(field_release:mediapipe.MotionEstimationOptions.overlay_detection_options)
  _has_bits_[0] &= ~0x00000010u;
  ::mediapipe::MotionEstimationOptions_OverlayDetectionOptions* temp = overlay_detection_options_;
  overlay_detection_options_ = nullptr;
  return temp;
}
inline ::mediapipe::MotionEstimationOptions_OverlayDetectionOptions* MotionEstimationOptions::_internal_mutable_overlay_detection_options() {
  _has_bits_[0] |= 0x00000010u;
  if (overlay_detection_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::mediapipe::MotionEstimationOptions_OverlayDetectionOptions>(GetArena());
    overlay_detection_options_ = p;
  }
  return overlay_detection_options_;
}
inline ::mediapipe::MotionEstimationOptions_OverlayDetectionOptions* MotionEstimationOptions::mutable_overlay_detection_options() {
  // @@protoc_insertion_point(field_mutable:mediapipe.MotionEstimationOptions.overlay_detection_options)
  return _internal_mutable_overlay_detection_options();
}
inline void MotionEstimationOptions::set_allocated_overlay_detection_options(::mediapipe::MotionEstimationOptions_OverlayDetectionOptions* overlay_detection_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete overlay_detection_options_;
  }
  if (overlay_detection_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(overlay_detection_options);
    if (message_arena != submessage_arena) {
      overlay_detection_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, overlay_detection_options, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  overlay_detection_options_ = overlay_detection_options;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.MotionEstimationOptions.overlay_detection_options)
}

// optional .mediapipe.MotionEstimationOptions.ShotBoundaryOptions shot_boundary_options = 60;
inline bool MotionEstimationOptions::_internal_has_shot_boundary_options() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || shot_boundary_options_ != nullptr);
  return value;
}
inline bool MotionEstimationOptions::has_shot_boundary_options() const {
  return _internal_has_shot_boundary_options();
}
inline void MotionEstimationOptions::clear_shot_boundary_options() {
  if (shot_boundary_options_ != nullptr) shot_boundary_options_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::mediapipe::MotionEstimationOptions_ShotBoundaryOptions& MotionEstimationOptions::_internal_shot_boundary_options() const {
  const ::mediapipe::MotionEstimationOptions_ShotBoundaryOptions* p = shot_boundary_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::mediapipe::MotionEstimationOptions_ShotBoundaryOptions&>(
      ::mediapipe::_MotionEstimationOptions_ShotBoundaryOptions_default_instance_);
}
inline const ::mediapipe::MotionEstimationOptions_ShotBoundaryOptions& MotionEstimationOptions::shot_boundary_options() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.shot_boundary_options)
  return _internal_shot_boundary_options();
}
inline void MotionEstimationOptions::unsafe_arena_set_allocated_shot_boundary_options(
    ::mediapipe::MotionEstimationOptions_ShotBoundaryOptions* shot_boundary_options) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(shot_boundary_options_);
  }
  shot_boundary_options_ = shot_boundary_options;
  if (shot_boundary_options) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mediapipe.MotionEstimationOptions.shot_boundary_options)
}
inline ::mediapipe::MotionEstimationOptions_ShotBoundaryOptions* MotionEstimationOptions::release_shot_boundary_options() {
  _has_bits_[0] &= ~0x00000100u;
  ::mediapipe::MotionEstimationOptions_ShotBoundaryOptions* temp = shot_boundary_options_;
  shot_boundary_options_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::mediapipe::MotionEstimationOptions_ShotBoundaryOptions* MotionEstimationOptions::unsafe_arena_release_shot_boundary_options() {
  // @@protoc_insertion_point(field_release:mediapipe.MotionEstimationOptions.shot_boundary_options)
  _has_bits_[0] &= ~0x00000100u;
  ::mediapipe::MotionEstimationOptions_ShotBoundaryOptions* temp = shot_boundary_options_;
  shot_boundary_options_ = nullptr;
  return temp;
}
inline ::mediapipe::MotionEstimationOptions_ShotBoundaryOptions* MotionEstimationOptions::_internal_mutable_shot_boundary_options() {
  _has_bits_[0] |= 0x00000100u;
  if (shot_boundary_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::mediapipe::MotionEstimationOptions_ShotBoundaryOptions>(GetArena());
    shot_boundary_options_ = p;
  }
  return shot_boundary_options_;
}
inline ::mediapipe::MotionEstimationOptions_ShotBoundaryOptions* MotionEstimationOptions::mutable_shot_boundary_options() {
  // @@protoc_insertion_point(field_mutable:mediapipe.MotionEstimationOptions.shot_boundary_options)
  return _internal_mutable_shot_boundary_options();
}
inline void MotionEstimationOptions::set_allocated_shot_boundary_options(::mediapipe::MotionEstimationOptions_ShotBoundaryOptions* shot_boundary_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete shot_boundary_options_;
  }
  if (shot_boundary_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(shot_boundary_options);
    if (message_arena != submessage_arena) {
      shot_boundary_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shot_boundary_options, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  shot_boundary_options_ = shot_boundary_options;
  // @@protoc_insertion_point(field_set_allocated:mediapipe.MotionEstimationOptions.shot_boundary_options)
}

// optional bool output_refined_irls_weights = 40 [default = true];
inline bool MotionEstimationOptions::_internal_has_output_refined_irls_weights() const {
  bool value = (_has_bits_[1] & 0x00004000u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_output_refined_irls_weights() const {
  return _internal_has_output_refined_irls_weights();
}
inline void MotionEstimationOptions::clear_output_refined_irls_weights() {
  output_refined_irls_weights_ = true;
  _has_bits_[1] &= ~0x00004000u;
}
inline bool MotionEstimationOptions::_internal_output_refined_irls_weights() const {
  return output_refined_irls_weights_;
}
inline bool MotionEstimationOptions::output_refined_irls_weights() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.output_refined_irls_weights)
  return _internal_output_refined_irls_weights();
}
inline void MotionEstimationOptions::_internal_set_output_refined_irls_weights(bool value) {
  _has_bits_[1] |= 0x00004000u;
  output_refined_irls_weights_ = value;
}
inline void MotionEstimationOptions::set_output_refined_irls_weights(bool value) {
  _internal_set_output_refined_irls_weights(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.output_refined_irls_weights)
}

// optional .mediapipe.MotionEstimationOptions.HomographyIrlsWeightInitialization homography_irls_weight_initialization = 45 [default = IRLS_WEIGHT_PERIMETER_GAUSSIAN];
inline bool MotionEstimationOptions::_internal_has_homography_irls_weight_initialization() const {
  bool value = (_has_bits_[1] & 0x00100000u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_homography_irls_weight_initialization() const {
  return _internal_has_homography_irls_weight_initialization();
}
inline void MotionEstimationOptions::clear_homography_irls_weight_initialization() {
  homography_irls_weight_initialization_ = 3;
  _has_bits_[1] &= ~0x00100000u;
}
inline ::mediapipe::MotionEstimationOptions_HomographyIrlsWeightInitialization MotionEstimationOptions::_internal_homography_irls_weight_initialization() const {
  return static_cast< ::mediapipe::MotionEstimationOptions_HomographyIrlsWeightInitialization >(homography_irls_weight_initialization_);
}
inline ::mediapipe::MotionEstimationOptions_HomographyIrlsWeightInitialization MotionEstimationOptions::homography_irls_weight_initialization() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.homography_irls_weight_initialization)
  return _internal_homography_irls_weight_initialization();
}
inline void MotionEstimationOptions::_internal_set_homography_irls_weight_initialization(::mediapipe::MotionEstimationOptions_HomographyIrlsWeightInitialization value) {
  assert(::mediapipe::MotionEstimationOptions_HomographyIrlsWeightInitialization_IsValid(value));
  _has_bits_[1] |= 0x00100000u;
  homography_irls_weight_initialization_ = value;
}
inline void MotionEstimationOptions::set_homography_irls_weight_initialization(::mediapipe::MotionEstimationOptions_HomographyIrlsWeightInitialization value) {
  _internal_set_homography_irls_weight_initialization(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.homography_irls_weight_initialization)
}

// optional bool irls_use_l0_norm = 46 [default = true];
inline bool MotionEstimationOptions::_internal_has_irls_use_l0_norm() const {
  bool value = (_has_bits_[1] & 0x00008000u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_irls_use_l0_norm() const {
  return _internal_has_irls_use_l0_norm();
}
inline void MotionEstimationOptions::clear_irls_use_l0_norm() {
  irls_use_l0_norm_ = true;
  _has_bits_[1] &= ~0x00008000u;
}
inline bool MotionEstimationOptions::_internal_irls_use_l0_norm() const {
  return irls_use_l0_norm_;
}
inline bool MotionEstimationOptions::irls_use_l0_norm() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.irls_use_l0_norm)
  return _internal_irls_use_l0_norm();
}
inline void MotionEstimationOptions::_internal_set_irls_use_l0_norm(bool value) {
  _has_bits_[1] |= 0x00008000u;
  irls_use_l0_norm_ = value;
}
inline void MotionEstimationOptions::set_irls_use_l0_norm(bool value) {
  _internal_set_irls_use_l0_norm(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.irls_use_l0_norm)
}

// optional bool domain_limited_irls_scaling = 65 [default = false];
inline bool MotionEstimationOptions::_internal_has_domain_limited_irls_scaling() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_domain_limited_irls_scaling() const {
  return _internal_has_domain_limited_irls_scaling();
}
inline void MotionEstimationOptions::clear_domain_limited_irls_scaling() {
  domain_limited_irls_scaling_ = false;
  _has_bits_[0] &= ~0x00040000u;
}
inline bool MotionEstimationOptions::_internal_domain_limited_irls_scaling() const {
  return domain_limited_irls_scaling_;
}
inline bool MotionEstimationOptions::domain_limited_irls_scaling() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.domain_limited_irls_scaling)
  return _internal_domain_limited_irls_scaling();
}
inline void MotionEstimationOptions::_internal_set_domain_limited_irls_scaling(bool value) {
  _has_bits_[0] |= 0x00040000u;
  domain_limited_irls_scaling_ = value;
}
inline void MotionEstimationOptions::set_domain_limited_irls_scaling(bool value) {
  _internal_set_domain_limited_irls_scaling(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.domain_limited_irls_scaling)
}

// optional bool deactivate_stable_motion_estimation = 47 [default = false];
inline bool MotionEstimationOptions::_internal_has_deactivate_stable_motion_estimation() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_deactivate_stable_motion_estimation() const {
  return _internal_has_deactivate_stable_motion_estimation();
}
inline void MotionEstimationOptions::clear_deactivate_stable_motion_estimation() {
  deactivate_stable_motion_estimation_ = false;
  _has_bits_[0] &= ~0x00080000u;
}
inline bool MotionEstimationOptions::_internal_deactivate_stable_motion_estimation() const {
  return deactivate_stable_motion_estimation_;
}
inline bool MotionEstimationOptions::deactivate_stable_motion_estimation() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.deactivate_stable_motion_estimation)
  return _internal_deactivate_stable_motion_estimation();
}
inline void MotionEstimationOptions::_internal_set_deactivate_stable_motion_estimation(bool value) {
  _has_bits_[0] |= 0x00080000u;
  deactivate_stable_motion_estimation_ = value;
}
inline void MotionEstimationOptions::set_deactivate_stable_motion_estimation(bool value) {
  _internal_set_deactivate_stable_motion_estimation(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.deactivate_stable_motion_estimation)
}

// optional bool project_valid_motions_down = 52 [default = false];
inline bool MotionEstimationOptions::_internal_has_project_valid_motions_down() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_project_valid_motions_down() const {
  return _internal_has_project_valid_motions_down();
}
inline void MotionEstimationOptions::clear_project_valid_motions_down() {
  project_valid_motions_down_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool MotionEstimationOptions::_internal_project_valid_motions_down() const {
  return project_valid_motions_down_;
}
inline bool MotionEstimationOptions::project_valid_motions_down() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.project_valid_motions_down)
  return _internal_project_valid_motions_down();
}
inline void MotionEstimationOptions::_internal_set_project_valid_motions_down(bool value) {
  _has_bits_[0] |= 0x00001000u;
  project_valid_motions_down_ = value;
}
inline void MotionEstimationOptions::set_project_valid_motions_down(bool value) {
  _internal_set_project_valid_motions_down(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.project_valid_motions_down)
}

// optional bool estimate_similarity = 2 [deprecated = true];
inline bool MotionEstimationOptions::_internal_has_estimate_similarity() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool MotionEstimationOptions::has_estimate_similarity() const {
  return _internal_has_estimate_similarity();
}
inline void MotionEstimationOptions::clear_estimate_similarity() {
  estimate_similarity_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool MotionEstimationOptions::_internal_estimate_similarity() const {
  return estimate_similarity_;
}
inline bool MotionEstimationOptions::estimate_similarity() const {
  // @@protoc_insertion_point(field_get:mediapipe.MotionEstimationOptions.estimate_similarity)
  return _internal_estimate_similarity();
}
inline void MotionEstimationOptions::_internal_set_estimate_similarity(bool value) {
  _has_bits_[0] |= 0x00002000u;
  estimate_similarity_ = value;
}
inline void MotionEstimationOptions::set_estimate_similarity(bool value) {
  _internal_set_estimate_similarity(value);
  // @@protoc_insertion_point(field_set:mediapipe.MotionEstimationOptions.estimate_similarity)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mediapipe

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::mediapipe::MotionEstimationOptions_LinearSimilarityEstimation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mediapipe::MotionEstimationOptions_LinearSimilarityEstimation>() {
  return ::mediapipe::MotionEstimationOptions_LinearSimilarityEstimation_descriptor();
}
template <> struct is_proto_enum< ::mediapipe::MotionEstimationOptions_AffineEstimation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mediapipe::MotionEstimationOptions_AffineEstimation>() {
  return ::mediapipe::MotionEstimationOptions_AffineEstimation_descriptor();
}
template <> struct is_proto_enum< ::mediapipe::MotionEstimationOptions_HomographyEstimation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mediapipe::MotionEstimationOptions_HomographyEstimation>() {
  return ::mediapipe::MotionEstimationOptions_HomographyEstimation_descriptor();
}
template <> struct is_proto_enum< ::mediapipe::MotionEstimationOptions_MixtureHomographyEstimation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mediapipe::MotionEstimationOptions_MixtureHomographyEstimation>() {
  return ::mediapipe::MotionEstimationOptions_MixtureHomographyEstimation_descriptor();
}
template <> struct is_proto_enum< ::mediapipe::MotionEstimationOptions_EstimationPolicy> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mediapipe::MotionEstimationOptions_EstimationPolicy>() {
  return ::mediapipe::MotionEstimationOptions_EstimationPolicy_descriptor();
}
template <> struct is_proto_enum< ::mediapipe::MotionEstimationOptions_MixtureModelMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mediapipe::MotionEstimationOptions_MixtureModelMode>() {
  return ::mediapipe::MotionEstimationOptions_MixtureModelMode_descriptor();
}
template <> struct is_proto_enum< ::mediapipe::MotionEstimationOptions_IRLSWeightFilter> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mediapipe::MotionEstimationOptions_IRLSWeightFilter>() {
  return ::mediapipe::MotionEstimationOptions_IRLSWeightFilter_descriptor();
}
template <> struct is_proto_enum< ::mediapipe::MotionEstimationOptions_HomographyIrlsWeightInitialization> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mediapipe::MotionEstimationOptions_HomographyIrlsWeightInitialization>() {
  return ::mediapipe::MotionEstimationOptions_HomographyIrlsWeightInitialization_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <x/google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_mediapipe_2futil_2ftracking_2fmotion_5festimation_2eproto
